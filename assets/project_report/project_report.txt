Directory Structure:
├── ../
│   ├── assets/
│   │   ├── common_ocean_scenarios/
│   │   │   ├── Florida/
│   │   │   ├── HandcraftedTwoVesselEncounters_01_24/
│   │   │   ├── MiddleEastCoast/
│   │   │   ├── UpperWestCoast/
│   │   ├── figures/
│   │   │   ├── wang2024/
│   │   ├── functional_models/
│   │   │   ├── all/
│   │   │   │   ├── 2vessel_scenarios/
│   │   │   │   ├── 3vessel_scenarios/
│   │   │   │   ├── 4vessel_scenarios/
│   │   │   │   ├── 5vessel_scenarios/
│   │   │   │   ├── 6vessel_scenarios/
│   │   │   ├── ambiguous/
│   │   │   │   ├── 2vessel_scenarios/
│   │   │   │   ├── 3vessel_scenarios/
│   │   │   │   ├── 4vessel_scenarios/
│   │   │   │   ├── 5vessel_scenarios/
│   │   │   │   ├── 6vessel_scenarios/
│   │   ├── gen_data/
│   │   │   ├── RRTStar_algo/
│   │   │   │   ├── 4vessel/
│   │   │   │   │   ├── test - 2025-02-07T11-13-32.032756/
│   │   │   ├── parameter_optimization_2/
│   │   │   │   ├── None/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_category/
│   │   │   │   │   ├── pymoo_NSGA3_algorithm_actor/
│   │   │   │   │   ├── pymoo_NSGA3_algorithm_category/
│   │   │   ├── test_2_vessel_scenarios/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_2_vessel_scenarios_long/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_3_vessel_scenarios/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_3_vessel_scenarios_long/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_4_vessel_scenarios/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_4_vessel_scenarios_long/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── common_ocean_benchmark/
│   │   │   │   │   ├── ais_source/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_5_vessel_scenarios/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_5_vessel_scenarios_long/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_6_vessel_scenarios/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   │   ├── test_6_vessel_scenarios_long/
│   │   │   │   ├── SBO/
│   │   │   │   │   ├── pymoo_NSGA2_algorithm_actor/
│   │   │   │   ├── scenic_distribution/
│   │   │   │   │   ├── scenic_sampling/
│   │   ├── images/
│   │   │   ├── exported_plots/
│   │   ├── project_report/
│   │   ├── scenic/
│   │   │   ├── 2vessel_scenario.scenic
│   │   │   ├── 3vessel_scenario.scenic
│   │   │   ├── 4vessel_scenario.scenic
│   │   │   ├── 5vessel_scenario.scenic
│   │   │   ├── 6vessel_scenario.scenic
│   │   │   ├── scenic_base.scenic
│   ├── media/
│   │   ├── Tex/
│   │   ├── images/
│   │   │   ├── manim_first/
│   │   ├── texts/
│   │   ├── videos/
│   │   │   ├── manim_first/
│   │   │   │   ├── 1080p60/
│   │   │   │   ├── 480p15/
│   │   │   │   │   ├── partial_movie_files/
│   │   │   │   │   │   ├── PointsWithVectorsAndRadius/
│   │   │   │   │   │   │   ├── partial_movie_file_list.txt
│   ├── refinery_functional_models/
│   │   ├── COLREGS4_v6.PROBLEM
│   ├── src/
│   │   ├── commonocean/
│   │   │   ├── common/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── file_reader.py
│   │   │   │   ├── file_writer.py
│   │   │   │   ├── solution.py
│   │   │   ├── planning/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── goal.py
│   │   │   │   ├── planning_problem.py
│   │   │   ├── prediction/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── prediction.py
│   │   │   ├── scenario/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── obstacle.py
│   │   │   │   ├── scenario.py
│   │   │   │   ├── state.py
│   │   │   │   ├── traffic_sign.py
│   │   │   │   ├── trajectory.py
│   │   │   │   ├── waters.py
│   │   │   ├── visualization/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── draw_dispatch_cr.py
│   │   │   │   ├── planning.py
│   │   │   │   ├── scenario.py
│   │   │   │   ├── traffic_sign.py
│   │   │   │   ├── util.py
│   │   │   ├── __init__.py
│   │   ├── concrete_level/
│   │   │   ├── common_ocean/
│   │   │   │   ├── common/
│   │   │   │   ├── planning/
│   │   │   │   ├── prediction/
│   │   │   │   ├── scenario/
│   │   │   │   ├── visualization/
│   │   │   ├── models/
│   │   │   │   ├── concrete_scene.py
│   │   │   │   ├── concrete_vessel.py
│   │   │   │   ├── multi_level_scenario.py
│   │   │   │   ├── rrt_models.py
│   │   │   │   ├── trajectories.py
│   │   │   │   ├── trajectory_manager.py
│   │   │   │   ├── vessel_order_graph.py
│   │   │   │   ├── vessel_state.py
│   │   │   ├── trajectory_generation/
│   │   │   │   ├── bidirectional_rrt_star_fnd.py
│   │   │   │   ├── path_interpolator.py
│   │   │   │   ├── scene_builder.py
│   │   │   │   ├── trajectory_builder.py
│   │   │   │   ├── trajectory_data.py
│   │   │   │   ├── trajectory_generator.py
│   │   │   ├── concrete_scene_abstractor.py
│   │   │   ├── data_parser.py
│   │   ├── evaluation/
│   │   │   ├── chi_square_kl_div.py
│   │   │   ├── fishers_exact_odds_ratio.py
│   │   │   ├── mann_whitney_u_cliff_delta.py
│   │   │   ├── permutation_evenness_test.py
│   │   │   ├── risk_evaluation.py
│   │   │   ├── vessel_type_sampler.py
│   │   ├── functional_level/
│   │   │   ├── metamodels/
│   │   │   │   ├── functional_object.py
│   │   │   │   ├── functional_scenario.py
│   │   │   │   ├── interpretation.py
│   │   │   ├── models/
│   │   │   │   ├── MSR/
│   │   │   │   ├── functional_model_manager.py
│   │   │   │   ├── model_parser.py
│   │   │   │   ├── object_generator.py
│   │   ├── logical_level/
│   │   │   ├── constraint_satisfaction/
│   │   │   │   ├── evolutionary_computation/
│   │   │   │   │   ├── evolutionary_algorithms/
│   │   │   │   │   │   ├── evolutionary_algorithm_base.py
│   │   │   │   │   │   ├── pygad_ga_algorithm.py
│   │   │   │   │   │   ├── pymoo_nsga2_algorithm.py
│   │   │   │   │   │   ├── pymoo_nsga3_algorithm.py
│   │   │   │   │   │   ├── pymoo_nsga_algorithm.py
│   │   │   │   │   │   ├── pyswarm_pso_algorithm.py
│   │   │   │   │   │   ├── scipy_de_algorithm.py
│   │   │   │   │   ├── aggregates.py
│   │   │   │   │   ├── evaluation_data.py
│   │   │   │   ├── assignments.py
│   │   │   │   ├── evaluation_cache.py
│   │   │   │   ├── scenic_sampling.py
│   │   │   ├── mapping/
│   │   │   │   ├── instance_initializer.py
│   │   │   │   ├── logical_scenario_builder.py
│   │   │   ├── models/
│   │   │   │   ├── SBO/
│   │   │   │   ├── actor_variable.py
│   │   │   │   ├── logical_model_manager.py
│   │   │   │   ├── logical_scenario.py
│   │   │   │   ├── penalty.py
│   │   │   │   ├── relation_constraints.py
│   │   │   │   ├── values.py
│   │   │   │   ├── vessel_types.py
│   │   ├── media/
│   │   │   ├── images/
│   │   │   │   ├── manim_first/
│   │   │   ├── videos/
│   │   │   │   ├── 1080p60/
│   │   │   │   │   ├── partial_movie_files/
│   │   │   │   │   │   ├── PointsWithVectorsAndRadius/
│   │   │   │   ├── manim_first/
│   │   │   │   │   ├── 1080p60/
│   │   │   │   │   │   ├── partial_movie_files/
│   │   │   │   │   │   │   ├── PointsWithVectorsAndRadius/
│   │   ├── scripts/
│   │   │   ├── manim/
│   │   │   │   ├── manim_first.py
│   │   │   ├── annotate_risk_vectors.py
│   │   │   ├── common_ocean_scenario_parser.py
│   │   │   ├── eval_vis.py
│   │   │   ├── evaluation_main.py
│   │   │   ├── generate_project_outline.py
│   │   │   ├── generate_trajectories.py
│   │   │   ├── hyperparam_test.py
│   │   │   ├── scenic_script.py
│   │   │   ├── table_browser.py
│   │   │   ├── test_algorithm.py
│   │   │   ├── trajectory_viewer.py
│   │   │   ├── wang24_eval.py
│   │   ├── utils/
│   │   │   ├── asv_utils.py
│   │   │   ├── file_system_utils.py
│   │   │   ├── math_utils.py
│   │   │   ├── scenario.py
│   │   │   ├── serializable.py
│   │   ├── visualization/
│   │   │   ├── colreg_scenarios/
│   │   │   │   ├── plot_components/
│   │   │   │   │   ├── main_plot_components/
│   │   │   │   │   │   ├── additional_vo_cone_component.py
│   │   │   │   │   │   ├── angle_circle_component.py
│   │   │   │   │   │   ├── centered_angle_circle_component.py
│   │   │   │   │   │   ├── distance_component.py
│   │   │   │   │   │   ├── drawing_component.py
│   │   │   │   │   │   ├── legend_component.py
│   │   │   │   │   │   ├── prime_component.py
│   │   │   │   │   │   ├── ship_image_component.py
│   │   │   │   │   │   ├── ship_markings_component.py
│   │   │   │   │   │   ├── vo_cone_component.py
│   │   │   │   │   ├── metric_components/
│   │   │   │   │   │   ├── proximity_metrics_component.py
│   │   │   │   │   │   ├── risk_metric_component.py
│   │   │   │   │   ├── plot_component.py
│   │   │   │   ├── scenario_animation.py
│   │   │   │   ├── scenario_metrics_plot.py
│   │   │   │   ├── scenario_plot.py
│   │   │   │   ├── scenario_plot_manager.py
│   │   │   ├── evaluation_plots/
│   │   │   │   ├── diversity_plot.py
│   │   │   │   ├── diversity_statistics_table.py
│   │   │   │   ├── eval_plot_manager.py
│   │   │   │   ├── risk_vector_plot.py
│   │   │   │   ├── runtime_plot.py
│   │   │   │   ├── runtime_statistics_table.py
│   │   │   │   ├── scenario_type_statistics_plot.py
│   │   │   │   ├── scenario_type_statistics_table.py
│   │   │   │   ├── success_rate_plot.py
│   │   │   ├── manim/
│   │   │   ├── __init__.py
│   │   │   ├── dash_thread.py
│   │   │   ├── plotting_utils.py
│   │   │   ├── trajectory_visualizer.py
│   ├── README.md
│   ├── pip
│   ├── requirements.txt

Files Content:
<src\commonocean\__init__.py>
import numpy
SCENARIO_VERSION = '2022a'
SUPPORTED_COMMONOCEAN_VERSIONS = {'2022a'}
TWO_PI = 2.0 * numpy.pi
</src\commonocean\__init__.py>

<src\commonocean\common\file_reader.py>
from xml.etree import ElementTree
from commonocean.planning.goal import GoalRegion
from commonocean.planning.planning_problem import PlanningProblemSet, PlanningProblem
from commonocean.scenario.scenario import *
from commonocean.scenario.obstacle import *
from commonocean.scenario.traffic_sign import *
from commonocean.scenario.waters import Shallow, Waterway, WatersNetwork
from commonroad.common.util import AngleInterval
from commonroad.geometry.shape import *
from commonocean.scenario.trajectory import Trajectory
from commonocean.scenario.state import GeneralState
# Tunneling from CR-IO #
from commonroad.common.reader.file_reader_xml import read_value_exact_or_interval as read_value_exact_or_interval_CR
from commonroad.common.reader.file_reader_xml import read_time as read_time_CR
from commonroad.common.reader.file_reader_xml import ShapeFactory, RectangleFactory, CircleFactory, PolygonFactory, PointFactory, PointListFactory
########################
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2023a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
def read_value_exact_or_interval(xml_node: ElementTree.Element) \
 -> Union[float, Interval]:
 """
 :param xml_node: XML element
 :return: Interval
 """
 return read_value_exact_or_interval_CR(xml_node)
def read_time(xml_node: ElementTree.Element) -> Union[int, Interval]:
 """
 :param xml_node: XML element
 :return: Interval
 """
 return read_time_CR(xml_node)
class CommonOceanFileReader:
 """ Class which reads CommonOcean XML-files. The XML-files are composed of
 (1) a formal representation of the water network,
 (2) static and dynamic obstacles,
 (3) the planning problem of the ego vehicle(s). """
 def __init__(self, filename: str):
 """
 :param filename: full path + filename of the CommonOcean XML-file,
 """
 self._filename = filename
 self._tree = None
 self._dt = None
 self._benchmark_id = None
 self._meta_data = None
 def open(self) -> Tuple[Scenario, PlanningProblemSet]:
 """
 Reads a CommonOcean XML-file.
 :return: the scenario containing the water network and the obstacles and the planning problem set \
 containing the planning problems---initial states and goal regions--for all ego vessels.
 """
 self._read_header()
 scenario = self._open_scenario()
 planning_problem_set = self._open_planning_problem_set(scenario._waters_network)
 return scenario, planning_problem_set
 def open_waters_network(self) -> WatersNetwork:
 """
 Reads the water network of a CommonOcean XML-file.
 :return: object of class WatersNetwork
 """
 self._read_header()
 return WatersNetworkFactory.create_from_xml_node(self._tree)
 def _open_scenario(self) -> Scenario:
 """
 Reads the water network and obstacles from the CommonOcean XML-file.
 :return: object of class scenario containing the water network and the obstacles
 """
 scenario = ScenarioFactory.create_from_xml_node(self._tree, self._dt, self._benchmark_id,
 self._commonocean_version, self._meta_data)
 return scenario
 def _open_planning_problem_set(self, waters_network: WatersNetwork) -> PlanningProblemSet:
 """
 Reads all planning problems from the CommonOcean XML-file.
 :return: object of class PlanningProblemSet containing the planning problems for all ego vessels.
 """
 planning_problem_set = PlanningProblemSetFactory.create_from_xml_node(self._tree, waters_network)
 return planning_problem_set
 def _read_header(self):
 """ Parses the CommonOcean XML-file into element tree; reads the global time step size of the time-discrete
 scenario and the CommonOcean benchmark ID."""
 self._parse_file()
 self._dt = self._get_dt()
 self._benchmark_id = self._get_benchmark_id()
 self._commonocean_version = self._get_commonocean_version()
 self._meta_data = {'author': self._get_author(),
 'affiliation': self._get_affiliation(),
 'source': self._get_source(),
 'tags': self._get_tags(),
 'location': Location()}
 def _parse_file(self):
 """ Parses the CommonOcean XML-file into element tree."""
 self._tree = ElementTree.parse(self._filename)
 def _get_dt(self) -> float:
 """ Reads the time step size of the time-discrete scenario."""
 return float(self._tree.getroot().get('timeStepSize'))
 def _get_benchmark_id(self) -> str:
 """ Reads the unique CommonOcean benchmark ID of the scenario."""
 return self._tree.getroot().get('benchmarkID')
 def _get_commonocean_version(self) -> str:
 """ Reads the CommonOcean version of the XML-file."""
 return self._tree.getroot().get('commonOceanVersion')
 def _get_author(self) -> str:
 """ Reads the author of the scenario."""
 return self._tree.getroot().get('author')
 def _get_affiliation(self) -> str:
 """ Reads the affiliation of the author of the scenario."""
 return self._tree.getroot().get('affiliation')
 def _get_source(self) -> str:
 """ Reads the source of the scenario."""
 return self._tree.getroot().get('source')
 def _get_tags(self) -> Set[Tag]:
 """ Reads the tags of the scenario."""
 tags_string = self._tree.getroot().get('tags')
 if tags_string is None:
 return None
 else:
 splits = tags_string.split()
 tags = set()
 for tag in splits:
 try:
 tags.add(Tag(tag))
 except ValueError:
 warnings.warn('Scenario tag \'{}\' not valid.'.format(tag), stacklevel=2)
 return tags
class ScenarioFactory:
 """ Class to create an object of class Scenario from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, dt: float, benchmark_id: str, commonocean_version: str,
 meta_data: dict):
 """
 :param xml_node: XML element
 :param dt: time step size of the scenario
 :param benchmark_id: unique CommonOcean benchmark ID
 :param commonocean_version: CommonOcean version of the file
 :return: CommonOcean scenario
 """
 meta_data["tags"] = TagsFactory.create_from_xml_node(xml_node)
 meta_data["location"] = LocationFactory.create_from_xml_node(xml_node)
 scenario_id = ScenarioID.from_benchmark_id(benchmark_id, commonocean_version)
 scenario = Scenario(dt, scenario_id, **meta_data)
 with warnings.catch_warnings():
 warnings.filterwarnings("ignore")
 scenario.add_objects(WatersNetworkFactory.create_from_xml_node(xml_node))
 scenario.add_objects(cls._obstacles(xml_node, scenario._waters_network))
 scenario.add_objects(cls._shallows(xml_node))
 return scenario
 @classmethod
 def _obstacles(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) -> List[Obstacle]:
 """
 Reads all obstacles specified in a CommonOcean XML-file.
 :param xml_node: XML element
 :param waters_network: WatersNetwork
 :return: list of static and dynamic obstacles specified in the CommonOcean XML-file
 """
 obstacles = []
 for o in xml_node.findall('staticObstacle'):
 obstacles.append(StaticObstacleFactory.create_from_xml_node(o, waters_network))
 for o in xml_node.findall('dynamicObstacle'):
 obstacles.append(DynamicObstacleFactory.create_from_xml_node(o, waters_network))
 return obstacles
 @classmethod
 def _shallows(cls, xml_node: ElementTree.Element) -> List[Shallow]:
 """
 Reads all shallows specified in a CommonOcean XML-file.
 :param xml_node: XML element
 :return: list of shallows specified in the CommonOcean XML-file
 """
 shallows = []
 for d in xml_node.findall('shallow'):
 shallows.append(ShallowFactory.create_from_xml_node(d))
 return shallows
class ShallowFactory:
 """ Class to create a shallow from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Shallow:
 """
 :param xml_node: XML element
 :return: shallow
 """
 shape = ShapeFactory.create_from_xml_node(xml_node.find('shape'))
 if xml_node.find('depth') is None:
 return Shallow(shape)
 else:
 depth = float(xml_node.find('depth').find('exact').text)
 return Shallow(shape, depth)
class TagsFactory:
 """ Class to create a tag set from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Set[Tag]:
 """
 :param xml_node: XML element
 :return: set of tags
 """
 tags = set()
 tag_element = xml_node.find('scenarioTags')
 if tag_element is not None:
 for elem in Tag:
 if tag_element.find(elem.value) is not None:
 tags.add(elem)
 return tags
 else:
 return None
class LocationFactory:
 """ Class to create a location from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Union[Location, None]:
 """
 :param xml_node: XML element
 :return: location object
 """
 if xml_node.find('location') is not None:
 location_element = xml_node.find('location')
 geo_name_id = int(location_element.find('geoNameId').text)
 gps_latitude = float(location_element.find('gpsLatitude').text)
 gps_longitude = float(location_element.find('gpsLongitude').text)
 if location_element.find('geoTransformation') is not None:
 geo_transformation = GeoTransformationFactory.create_from_xml_node(
 location_element.find('geoTransformation'))
 else:
 geo_transformation = None
 if location_element.find('environment') is not None:
 environment = EnvironmentFactory.create_from_xml_node(
 location_element.find('environment'))
 else:
 environment = None
 return Location(geo_name_id, gps_latitude, gps_longitude, geo_transformation, environment)
 else:
 return None
class GeoTransformationFactory:
 """ Class to create a geotransformation object of an XML element according to the CommonOcean specification."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> GeoTransformation:
 """
 :param xml_node: XML element
 :return: GeoTransformation object
 """
 geo_reference = xml_node.find('geoReference').text
 x_translation = float(xml_node.find('xTranslation').text)
 y_translation = float(xml_node.find('yTranslation').text)
 z_rotation = float(xml_node.find('zRotation').text)
 scaling = float(xml_node.find('scaling').text)
 return GeoTransformation(geo_reference, x_translation, y_translation, z_rotation, scaling)
class EnvironmentFactory:
 """ Class to create a environment object of an XML element according to the CommonOcean specification."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Environment:
 """
 :param xml_node: XML element
 :return: Environment object
 """
 time = TimeFactory.create_from_xml_node(xml_node.find('time').text)
 weather = Weather(xml_node.find('weather').text)
 sea_state = SeaState(xml_node.find('seaState').text)
 time_of_day = TimeOfDay(xml_node.find('timeOfDay').text)
 return Environment(time, time_of_day, weather, sea_state)
class TimeFactory:
 """ Class to create a time object of an XML element."""
 @classmethod
 def create_from_xml_node(cls, time_text: str) -> Time:
 """
 :param time_text: time as string
 :return: time object
 """
 year = int(time_text[0:4])
 month = int(time_text[5:7])
 day = int(time_text[8:10])
 hours = int(time_text[11:13])
 minutes = int(time_text[14:16])
 return Time(year, month, day, hours, minutes)
class WatersNetworkFactory:
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> WatersNetwork:
 """
 Reads all waters specified in a CommonOcean XML-file.
 :param xml_node: XML element
 :return: list of waters
 """
 shape = StaticObstacleFactory.read_shape(xml_node.find('navigationableArea'))
 waters_network = WatersNetwork(shape.center, shape.length, shape.width, shape.orientation)
 waters = []
 assigned_traffic_signs = []
 for waters_node in xml_node.findall('waterway'):
 waters.append(WaterwayFactory.create_from_xml_node(waters_node))
 for traffic_sign_ref in waters_node.findall('trafficSignRef'):
 if traffic_sign_ref.get("ref") is not None:
 assigned_traffic_signs.append(int(traffic_sign_ref.get("ref")))
 else:
 raise ValueError('<WatersNetworkFactory/create_from_xml_node>: Unknown type of traffic sign reference: %s.'
 % traffic_sign_ref.get("ref"))
 for water in waters:
 waters_network.add_waters(water)
 for traffic_sign_node in xml_node.findall('trafficSign'):
 unassigned = True
 if int(traffic_sign_node.get('id')) in assigned_traffic_signs:
 waters_network.add_traffic_sign(TrafficSignFactory.create_from_xml_node(traffic_sign_node), [None, None])
 else:
 waters_network.add_traffic_sign(TrafficSignFactory.create_from_xml_node(traffic_sign_node), [])
 return waters_network
class WaterwayFactory:
 """ Class to create an object of class Waters from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Waters:
 """
 :param xml_node: XML element
 :return: object of class Waterway according to the CommonOcean specification.
 """
 waters_id = int(xml_node.get('id'))
 left_vertices = cls._vertices(xml_node.find('leftBound'))
 right_vertices = cls._vertices(xml_node.find('rightBound'))
 center_vertices = 0.5 * (left_vertices + right_vertices)
 # center_vertices = right_vertices
 predecessors = cls._predecessors(xml_node)
 successors = cls._successors(xml_node)
 waters_type = cls._waters_type(xml_node)
 traffic_signs = cls._traffic_signs(xml_node)
 return Waterway(
 left_vertices=left_vertices, center_vertices=center_vertices, right_vertices=right_vertices,
 waters_id=waters_id,
 waters_type=waters_type,
 predecessor=predecessors, successor=successors,
 traffic_signs=traffic_signs)
 @classmethod
 def _vertices(cls, xml_node: ElementTree.Element) -> np.ndarray:
 """
 Reads the vertices of the water boundary.
 :param xml_node: XML element
 :return: The vertices of the boundary of the Waterway described as a polyline
 """
 return PointListFactory.create_from_xml_node(xml_node)
 @classmethod
 def _predecessors(cls, xml_node: ElementTree.Element) -> List[int]:
 """
 Reads all predecessor waters.
 :param xml_node: XML element
 :return: list of IDs of all predecessor waters
 """
 predecessors = list()
 for l in xml_node.findall('predecessor'):
 predecessors.append(int(l.get('ref')))
 return predecessors
 @classmethod
 def _successors(cls, xml_node: ElementTree.Element) -> List[int]:
 """
 Reads all successor waters.
 :param xml_node: XML element
 :return: list of IDs of all successor waters
 """
 successors = list()
 for l in xml_node.findall('successor'):
 successors.append(int(l.get('ref')))
 return successors
 @classmethod
 def _waters_type(cls, xml_node: ElementTree.Element) -> WatersType:
 """
 Reads the water types of the water.
 :param xml_node: XML element
 :return: set of water types for a water
 """
 for f_type in xml_node.findall('watersType'):
 if WatersType(f_type.text) is not None:
 waters_type = (WatersType(f_type.text))
 else:
 raise ValueError('<WaterwayFactory/_waters_type>: Unkown type of water: %s.' % f_type.text)
 return waters_type
 @classmethod
 def _traffic_signs(cls, xml_node: ElementTree.Element) -> Union[Set[int], None]:
 """
 Reads the traffic sign references of the water.
 :param xml_node: XML element
 :return: set of traffic sign IDs (None if not specified).
 """
 traffic_signs = set()
 for traffic_sign_ref in xml_node.findall('trafficSignRef'):
 if traffic_sign_ref.get("ref") is not None:
 traffic_signs.add(int(traffic_sign_ref.get("ref")))
 else:
 raise ValueError('<WaterwayFactory/_traffic_signs>: Unknown type of traffic sign reference: %s.'
 % traffic_sign_ref.get("ref"))
 return traffic_signs
class TrafficSignFactory:
 """ Class to create an object of class TrafficSign from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> TrafficSign:
 """
 :param xml_node: XML element
 :param first_traffic_sign_occurence: set of first occurences of traffic sign
 :param waters_network: CommonOcean waters network
 :return: object of class TrafficSign according to the CommonOcean specification.
 """
 traffic_sign_id = int(xml_node.get('id'))
 traffic_sign_elements = []
 for element in xml_node.findall('trafficSignElement'):
 traffic_sign_elements.append(TrafficSignElementFactory.create_from_xml_node(element))
 if xml_node.find('position') is not None:
 position = PointFactory.create_from_xml_node(xml_node.find('position').find('point'))
 if xml_node.get('virtual') is not None:
 if xml_node.get('virtual').text == "true":
 virtual = True
 elif xml_node.get('virtual').text == "false":
 virtual = False
 else:
 raise ValueError()
 else:
 virtual = False
 return TrafficSign(traffic_sign_id=traffic_sign_id, position=position,
 traffic_sign_elements=traffic_sign_elements, virtual=virtual)
class TrafficSignElementFactory:
 """ Class to create an object of class TrafficSignElement from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> TrafficSignElement:
 """
 :param xml_node: XML element
 :return: object of class TrafficSignElement according to the CommonOcean specification.
 """
 traffic_sign_element_id = TrafficSignElementID(xml_node.find('trafficSignID').text)
 additional_values = []
 for additional_value in xml_node.findall('additionalValue'):
 additional_values.append(additional_value.text)
 return TrafficSignElement(traffic_sign_element_id=traffic_sign_element_id,
 additional_values=additional_values)
class ObstacleFactory(ABC):
 """ Class to create an Obstacle from an XML element."""
 @classmethod
 def read_type(cls, xml_node: ElementTree.Element) -> ObstacleType:
 """
 :param xml_node: XML element
 :return: object of class ObstacleType according to the CommonOcean specification.
 """
 obstacle_type = None
 if xml_node.find('type') is not None:
 if ObstacleType(xml_node.find('type').text) is not None:
 obstacle_type = ObstacleType(xml_node.find('type').text)
 else:
 raise ValueError('Type of obstacle is unknown. Got type: {}'.format(xml_node.find('type').text))
 return obstacle_type
 @classmethod
 def read_id(cls, xml_node: ElementTree.Element) -> int:
 """
 :param xml_node: XML element
 :return: int.
 """
 obstacle_id = int(xml_node.get('id'))
 return obstacle_id
 @classmethod
 def read_depth(cls, xml_node: ElementTree.Element) -> Union[None, float]:
 """
 :param xml_node: XML element
 :return: int.
 """
 if xml_node.find('depth') is None:
 return None
 else:
 depth_text = xml_node.find('depth').text
 if depth_text != "inf":
 depth = float(depth_text)
 else:
 depth = np.inf
 return depth
 @classmethod
 def read_initial_state(cls, xml_node: ElementTree.Element) -> GeneralState:
 """
 :param xml_node: XML element
 :return: object of class CustomState according to the CommonRoad specification.
 """
 initial_state = StateFactory.create_from_xml_node(xml_node)
 return initial_state
 @classmethod
 def read_shape(cls, xml_node: ElementTree.Element) -> Shape:
 """
 :param xml_node: XML element
 :return: object of class Shape.
 """
 shape = ShapeFactory.create_from_xml_node(xml_node)
 return shape
class StaticObstacleFactory(ObstacleFactory):
 """ Class to create a Static Obstacle from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) -> StaticObstacle:
 """
 :param xml_node: XML element
 :param xml_node: waters network element
 :return: object of class StaticObstacle according to the CommonOcean specification.
 """
 obstacle_type = StaticObstacleFactory.read_type(xml_node)
 obstacle_id = StaticObstacleFactory.read_id(xml_node)
 initial_state = StaticObstacleFactory.read_initial_state(xml_node.find('initialState'))
 shape = StaticObstacleFactory.read_shape(xml_node.find('shape'))
 depth = StaticObstacleFactory.read_depth(xml_node)
 return StaticObstacle(obstacle_id=obstacle_id, obstacle_type=obstacle_type,
 obstacle_shape=shape, initial_state=initial_state, depth = depth)
class DynamicObstacleFactory(ObstacleFactory):
 """ Class to create a Dynamic Obstacle from an XML element."""
 @staticmethod
 def find_obstacle_shape_lanelets(initial_state: GeneralState, state_list: List[GeneralState], waters_network: WatersNetwork,
 obstacle_id: int, shape: Shape) -> Dict[int, Set[int]]:
 """
 Extracts for each shape the corresponding waters it is on
 :param initial_state: initial CommonOcean state
 :param state_list: trajectory state list
 :param waters_network: CommonOcean water network
 :param obstacle_id: ID of obstacle
 :param shape: shape of obstacle
 :return: list of IDs of all predecessor waters
 """
 compl_state_list = [initial_state] + state_list
 lanelet_ids_per_state = {}
 for state in compl_state_list:
 rotated_shape = shape.rotate_translate_local(state.position, state.orientation)
 lanelet_ids = waters_network.find_water_by_shape(rotated_shape)
 for l_id in lanelet_ids:
 waters_network.find_lanelet_by_id(l_id).add_dynamic_obstacle_to_lanelet(obstacle_id=obstacle_id,
 time_step=state.time_step)
 lanelet_ids_per_state[state.time_step] = set(lanelet_ids)
 return lanelet_ids_per_state
 @staticmethod
 def find_obstacle_center_lanelets(initial_state: GeneralState, state_list: List[GeneralState],
 waters_network: WatersNetwork) -> Dict[int, Set[int]]:
 """
 Extracts for each shape the corresponding waters it is on
 :param initial_state: initial CommonOcean state
 :param state_list: trajectory state list
 :param waters_network: CommonOcean water network
 :return: list of IDs of all predecessor waters
 """
 compl_state_list = [initial_state] + state_list
 lanelet_ids_per_state = {}
 for state in compl_state_list:
 lanelet_ids = waters_network.find_lanelet_by_position([state.position])[0]
 lanelet_ids_per_state[state.time_step] = set(lanelet_ids)
 return lanelet_ids_per_state
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) -> DynamicObstacle:
 """
 :param xml_node: XML element
 :param xml_node: waters network element
 :return: object of class DynamicObstacle according to the CommonOcean specification.
 """
 obstacle_type = DynamicObstacleFactory.read_type(xml_node)
 obstacle_id = DynamicObstacleFactory.read_id(xml_node)
 shape = DynamicObstacleFactory.read_shape(xml_node.find('shape'))
 initial_state = DynamicObstacleFactory.read_initial_state(xml_node.find('initialState'))
 depth = DynamicObstacleFactory.read_depth(xml_node)
 prediction = None
 # if xml_node.find('trajectory') is not None:
 # trajectory = TrajectoryFactory.create_from_xml_node(xml_node.find('trajectory'))
 # shape_waters_assignment = None
 # center_waters_assignment = None
 # prediction = TrajectoryPrediction(trajectory, shape, center_waters_assignment, shape_waters_assignment)
 # elif xml_node.find('occupancySet') is not None:
 # prediction = SetBasedPredictionFactory.create_from_xml_node(xml_node.find('occupancySet'))
 # else:
 # prediction = None
 return DynamicObstacle(obstacle_id=obstacle_id, obstacle_type=obstacle_type,
 obstacle_shape=shape, initial_state=initial_state, prediction=prediction, depth=depth)
class TrajectoryFactory:
 """ Class to create a Trajectory from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) \
 -> Trajectory:
 """
 :param xml_node: XML element
 :return: object of class Trajectory according to the CommonOcean specification.
 """
 state_list = list()
 for state_node in xml_node.findall('state'):
 state_list.append(StateFactory.create_from_xml_node(state_node))
 if isinstance(state_list[0].time_step, Interval):
 t0 = min(state_list[0].time_step)
 else:
 t0 = state_list[0].time_step
 return Trajectory(t0, state_list)
class SetBasedPredictionFactory:
 """ Class to create a SetBasedPrediction from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> SetBasedPrediction:
 """
 :param xml_node: XML element
 :return: object of class SetBasedPrediction according to the CommonOcean specification.
 """
 occupancies = list()
 for occupancy in xml_node.findall('occupancy'):
 occupancies.append(OccupancyFactory.create_from_xml_node(occupancy))
 if isinstance(occupancies[0].time_step, Interval):
 t0 = min(occupancies[0].time_step)
 else:
 t0 = occupancies[0].time_step
 return SetBasedPrediction(t0, occupancies)
class OccupancyFactory:
 """ Class to create a Occupancy from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element) -> Occupancy:
 """
 :param xml_node: XML element
 :return: object of class Occupancy according to the CommonOcean specification.
 """
 shape = ShapeFactory.create_from_xml_node(xml_node.find('shape'))
 time = read_time(xml_node.find('time'))
 return Occupancy(time, shape)
class PlanningProblemSetFactory:
 """ Class to create a PlanningProblemSet from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) \
 -> PlanningProblemSet:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: object of class PlanningProblemSet according to the CommonOcean specification.
 """
 planning_problem_set = PlanningProblemSet()
 for p in xml_node.findall('planningProblem'):
 planning_problem_set.add_planning_problem(
 PlanningProblemFactory.create_from_xml_node(p, waters_network))
 return planning_problem_set
class PlanningProblemFactory:
 """ Class to create a PlanningProblem from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) \
 -> PlanningProblem:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: object of class PlanningProblem according to the CommonOcean specification.
 """
 planning_problem_id = int(xml_node.get('id'))
 initial_state = cls._add_initial_state(xml_node)
 goal_region = GoalRegionFactory.create_from_xml_node(xml_node, waters_network)
 if xml_node.find('waypoint') is not None:
 waypoints = WaypointFactory.create_from_xml_node(xml_node, waters_network)
 max_lateral_deviation = float(xml_node.get('maxLateralDeviation'))
 else:
 waypoints= None
 max_lateral_deviation = None
 return PlanningProblem(planning_problem_id, initial_state, goal_region, waypoints, max_lateral_deviation)
 @classmethod
 def _add_initial_state(cls, xml_node: ElementTree.Element) \
 -> GeneralState:
 """
 :param xml_node: XML element
 :return: object of class CustomState according to the CommonRoad specification.
 """
 initial_state = StateFactory.create_from_xml_node(xml_node.find('initialState'))
 return initial_state
class GoalRegionFactory:
 """ Class to create a GoalRegion from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: WatersNetwork) \
 -> GoalRegion:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: object of class GoalRegion according to the CommonOcean specification.
 """
 state_list = list()
 waters_of_goal_position = defaultdict(list)
 for idx, goal_state_node in enumerate(xml_node.findall('goalState')):
 state_list.append(StateFactory.create_from_xml_node(goal_state_node, waters_network))
 if goal_state_node.find('position') is not None \
 and goal_state_node.find('position').find('water') is not None:
 for f in goal_state_node.find('position').findall('water'):
 waters_of_goal_position[idx].append(int(f.get('ref')))
 if not waters_of_goal_position:
 waters_of_goal_position = None
 return GoalRegion(state_list, waters_of_goal_position)
class WaypointFactory:
 """ Class to create a Waypoint from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: Union[WatersNetwork, None] = None) -> GoalRegion:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: object of class GoalRegion according to the CommonOcean specification.
 """
 waypoint_list = list()
 for waypoint_node in xml_node.findall('waypoint'):
 waypoint_list.append(StateFactory.create_from_xml_node(waypoint_node, waters_network))
 return GoalRegion(waypoint_list)
class StateFactory:
 """ Class to create a CustomState from an XML element."""
 @classmethod
 def create_from_xml_node(cls, xml_node: ElementTree.Element, waters_network: Union[WatersNetwork, None] = None) \
 -> GeneralState:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: object of class CustomState according to the CommonOcean specification.
 """
 state_args = dict()
 if xml_node.find('position') is not None:
 position = cls._read_position(xml_node.find('position'), waters_network)
 state_args['position'] = position
 if xml_node.find('time') is not None:
 state_args['time_step'] = read_time(xml_node.find('time'))
 if xml_node.find('orientation') is not None:
 orientation = cls._read_orientation(xml_node.find('orientation'))
 state_args['orientation'] = orientation
 if xml_node.find('velocity') is not None:
 speed = read_value_exact_or_interval(xml_node.find('velocity'))
 state_args['velocity'] = speed
 if xml_node.find('acceleration') is not None:
 acceleration = read_value_exact_or_interval(xml_node.find('acceleration'))
 state_args['acceleration'] = acceleration
 return GeneralState(**state_args)
 @classmethod
 def _read_position(cls, xml_node: ElementTree.Element,
 waters_network: Union[WatersNetwork, None] = None) \
 -> Union[np.ndarray, Shape]:
 """
 :param xml_node: XML element
 :param waters_network: object of class WatersNetwork
 :return: position (np array) of the Shape according to the CommonOcean specification.
 """
 if xml_node.find('point') is not None:
 position = PointFactory.create_from_xml_node(xml_node.find('point'))
 elif (xml_node.find('rectangle') is not None
 or xml_node.find('circle') is not None
 or xml_node.find('polygon') is not None):
 position = ShapeFactory.create_from_xml_node(xml_node)
 elif waters_network is not None and xml_node.find('water') is not None:
 position_list = list()
 for l in xml_node.findall('water'):
 waterway = waters_network.find_waterway_by_id(int(l.get('ref')))
 polygon = waterway.convert_to_polygon()
 position_list.append(polygon)
 position = ShapeGroup(position_list)
 else:
 raise Exception()
 return position
 @classmethod
 def _read_orientation(cls, xml_node: ElementTree.Element) -> Union[float, AngleInterval]:
 """
 :param xml_node: XML element
 :return: float of AngleInterval according to the CommonOcean specification.
 """
 if xml_node.find('exact') is not None:
 value = float(xml_node.find('exact').text)
 elif xml_node.find('intervalStart') is not None \
 and xml_node.find('intervalEnd') is not None:
 value = AngleInterval(
 float(xml_node.find('intervalStart').text),
 float(xml_node.find('intervalEnd').text))
 else:
 raise Exception()
 return value
</src\commonocean\common\file_reader.py>

<src\commonocean\common\file_writer.py>
import datetime
import enum
import pathlib
import os
from typing import Union, List, Set
import numpy as np
import decimal
import warnings
from commonocean import SCENARIO_VERSION
from lxml import etree, objectify
from commonroad.common.util import Interval
from commonroad.geometry.shape import Rectangle, Circle, ShapeGroup, Polygon
from commonocean.prediction.prediction import SetBasedPrediction, TrajectoryPrediction
from commonocean.scenario.trajectory import Trajectory
from commonocean.scenario.state import GeneralState
from commonocean.planning.planning_problem import PlanningProblemSet, PlanningProblem
from commonocean.scenario.waters import Waters, WatersType, WatersNetwork, Waterway, Shallow
from commonocean.scenario.obstacle import ObstacleRole, ObstacleType, DynamicObstacle, StaticObstacle, Obstacle, \
 Occupancy, Shape
from commonocean.scenario.scenario import Scenario, Tag, Location, GeoTransformation, Weather, Environment, SeaState, TimeOfDay
from commonocean.scenario.traffic_sign import TrafficSign
# Tunneling from CR-IO #
from commonroad.common.writer.file_writer_xml import float_to_str as float_to_str_CR
from commonroad.common.writer.file_writer_xml import create_exact_node_float as create_exact_node_float_CR
from commonroad.common.writer.file_writer_xml import create_exact_node_int as create_exact_node_int_CR
from commonroad.common.writer.file_writer_xml import create_interval_node_float as create_interval_node_float_CR
from commonroad.common.writer.file_writer_xml import create_interval_node_int as create_interval_node_int_CR
from commonroad.common.writer.file_writer_xml import Point, Pointlist
########################
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
"""
File Writer for scenarios to commonocean xml-format
"""
class DecimalPrecision:
 """
 Represents the decimal precision of the process
 """
 decimals = 4
precision = DecimalPrecision
def float_to_str(f):
 """
 Convert the given float to a string,
 without resorting to scientific notation
 """
 return float_to_str_CR(f)
def create_exact_node_float(value: Union[int, float]) -> etree.Element:
 """
 creates element node for exact value
 :param value: exact value
 :return: node for exact value
 """
 return create_exact_node_float_CR(value)
def create_exact_node_int(value: Union[int]) -> etree.Element:
 """
 creates element node for exact value
 :param value: exact value
 :return: node for exact value
 """
 return create_exact_node_int_CR(value)
def create_interval_node_float(interval: Interval) -> List[etree.Element]:
 """
 creates ElementTree.Element for an interval
 :param interval:
 :return: list of Element nodes with start and end of interval
 """
 return create_interval_node_float_CR(interval)
def create_interval_node_int(interval: Interval) -> List[etree.Element]:
 """
 creates ElementTree.Element for an interval
 :param interval:
 :return: list of Element nodes with start and end of interval
 """
 return create_interval_node_int_CR(interval)
class OverwriteExistingFile(enum.Enum):
 """
 Specifies whether an existing file will be overwritten or skipped
 """
 ASK_USER_INPUT = 0
 ALWAYS = 1
 SKIP = 2
class CommonOceanFileWriter:
 def __init__(
 self,
 scenario: Scenario,
 planning_problem_set: PlanningProblemSet,
 author: str = None,
 affiliation: str = None,
 source: str = None,
 tags: Set[Tag] = None,
 location: Location = None,
 decimal_precision: int = 8,
 ):
 """
 Initialize the FileWriter with a scenario and tags for the xml-header
 :param scenario: scenario that should be written later
 :param planning_problem_set: corresponding planning problem to the scenario
 :param author: author's name
 :param affiliation: affiliation of the author
 :param source: source of dataset (d.h. database, handcrafted, etc.)
 :param tags: list of keywords describing the scenario (e.g. waters type,
 required maneuver etc., see commonocean.cps.cit.tum.de for full list))
 :param decimal_precision: number of decimal places used when writing float values
 """
 assert not (author is None and scenario.author is None)
 assert not (affiliation is None and scenario.affiliation is None)
 assert not (source is None and scenario.source is None)
 assert not (tags is None and scenario.tags is None)
 self.scenario: Scenario = scenario
 self.planning_problem_set: PlanningProblemSet = planning_problem_set
 self._root_node = etree.Element('commonOcean')
 self.author = author if author is not None else scenario.author
 self.affiliation = affiliation if affiliation is not None else scenario.affiliation
 self.source = source if source is not None else scenario.source
 self.location = location if location is not None else scenario.location
 self.tags = tags if tags is not None else scenario.tags
 precision.decimals = decimal_precision
 @property
 def root_node(self):
 return self._root_node
 @root_node.setter
 def root_node(self, root_node):
 warnings.warn(
 '<CommonOceanFileWriter/root_node> root_node of CommonOceanFileWriter is immutable'
 )
 @property
 def author(self):
 return self._author
 @author.setter
 def author(self, author):
 assert isinstance(
 author, str
 ), '<CommonOceanFileWriter/author> author must be a string, but has type {}'.format(
 type(author)
 )
 self._author = author
 @property
 def affiliation(self):
 return self._affiliation
 @affiliation.setter
 def affiliation(self, affiliation):
 assert isinstance(
 affiliation, str
 ), '<CommonOceanFileWriter/affiliation> affiliation must be a string, but has type {}'.format(
 type(affiliation)
 )
 self._affiliation = affiliation
 @property
 def source(self):
 return self._source
 @source.setter
 def source(self, source):
 assert isinstance(
 source, str
 ), '<CommonOceanFileWriter/source> source must be a string, but has type {}'.format(
 type(source)
 )
 self._source = source
 @property
 def tags(self):
 return self._tags
 @tags.setter
 def tags(self, tags):
 for tag in tags:
 assert isinstance(tag, Tag), '<CommonOceanFileWriter/tags> tag must ' \
 'be a enum of type Tag, but has type {}'.format(type(tag))
 self._tags = tags
 def _write_header(self):
 self._root_node.set('timeStepSize', str(self.scenario.dt))
 self._root_node.set('commonOceanVersion', SCENARIO_VERSION)
 self._root_node.set('author', self.author)
 self._root_node.set('affiliation', self.affiliation)
 self._root_node.set('source', self.source)
 try:
 if self.scenario.scenario_id:
 self._root_node.set('benchmarkID', str(self.scenario.scenario_id))
 except:
 self._root_node.set('benchmarkID', '-1')
 print('Warning: No scenario_id set.')
 self._root_node.set('date', datetime.datetime.today().strftime('%Y-%m-%d'))
 def _add_all_objects_from_scenario(self):
 if self.location is not None:
 self._root_node.append(LocationXMLNode.create_node(self.location))
 else:
 self._root_node.append(LocationXMLNode.create_node(Location()))
 self._root_node.append(TagXMLNode.create_node(self.tags))
 self._root_node.append(WatersNetworkXMLNode.create_node(self.scenario._waters_network))
 for w in self.scenario.waterways:
 self._root_node.append(WaterwaysXMLNode.create_node(w))
 for sign in self.scenario._waters_network.traffic_signs:
 self._root_node.append(TrafficSignXMLNode.create_node(sign))
 for o in self.scenario.obstacles:
 self._root_node.append(ObstacleXMLNode.create_node(o))
 for s in self.scenario.shallows:
 self._root_node.append(ShallowXMLNode.create_node(s))
 def _add_all_planning_problems_from_planning_problem_set(self):
 for (
 planning_problem
 ) in self.planning_problem_set.planning_problem_dict.values():
 self._root_node.append(PlanningProblemXMLNode.create_node(planning_problem))
 def _dump(self):
 rough_string = etree.tostring(
 self._root_node, pretty_print=True, encoding='UTF-8'
 )
 rough_string = rough_string
 return rough_string
 def write_to_file(
 self,
 filename: Union[str, None] = None,
 overwrite_existing_file: OverwriteExistingFile = OverwriteExistingFile.ASK_USER_INPUT,
 check_validity: bool = False
 ):
 """
 Write a scenario including planning-problem. If file already exists, it will be overwritten of skipped
 :param filename: filename of the xml output file. If 'None', the Benchmark ID is taken
 :param overwrite_existing_file: Specify whether an already existing file should be overwritten or skipped
 :param check_validity: check xml file against .xsd definition
 :return:
 """
 if filename is None:
 filename = str(self.scenario.scenario_id)
 if pathlib.Path(filename).is_file():
 if overwrite_existing_file is OverwriteExistingFile.ASK_USER_INPUT:
 overwrite = input(
 'File {} already exists, replace old file (or else skip)? (y/n)'.format(
 filename
 )
 )
 elif overwrite_existing_file is OverwriteExistingFile.SKIP:
 overwrite = 'n'
 else:
 overwrite = 'y'
 if overwrite is 'n':
 print('Writing of file {} skipped'.format(filename))
 return
 else:
 print('Replace file {}'.format(filename))
 self._write_header()
 self._add_all_objects_from_scenario()
 self._add_all_planning_problems_from_planning_problem_set()
 if check_validity:
 self.check_validity_of_commonocean_file(self._dump())
 tree = etree.ElementTree(self._root_node)
 tree.write(filename, pretty_print=True, xml_declaration=True, encoding="utf-8")
 def write_scenario_to_file(
 self,
 filename: Union[str, None] = None,
 overwrite_existing_file: OverwriteExistingFile = OverwriteExistingFile.ASK_USER_INPUT
 ):
 """
 Write a scenario without planning-problem. If file already exists, it will be overwritten of skipped.
 :param filename: filename of the xml output file. If 'None', the Benchmark ID is taken
 :param OverwriteExistingFile: Specify whether an already existing file should be overwritten or skipped
 :return: None
 """
 if filename is None:
 filename = str(self.scenario.scenario_id)
 if pathlib.Path(filename).is_file():
 if overwrite_existing_file is OverwriteExistingFile.ASK_USER_INPUT:
 overwrite = input(
 'File {} already exists, replace old file (or else skip)? (y/n)'.format(
 filename
 )
 )
 elif overwrite_existing_file is OverwriteExistingFile.SKIP:
 overwrite = 'n'
 else:
 overwrite = 'y'
 if overwrite is 'n':
 print(
 'Writing skipped for file, since it already exists {}'.format(
 filename
 )
 )
 return
 else:
 print('Replace file {}'.format(filename))
 self._write_header()
 self._add_all_objects_from_scenario()
 tree = etree.ElementTree(self._root_node)
 tree.write(filename, pretty_print=True, xml_declaration=True, encoding="utf-8")
 @staticmethod
 def check_validity_of_commonocean_file(commonocean_str: str):
 """Check the validity of a generated xml_string in terms of
 commonocean with an existing XSD schema.
 Throw an error if it is not valid.
 Args:
 commonocean_str: XML formatted string which should be checked.
 """
 with open(
 os.path.dirname(os.path.abspath(__file__)) + '/XML_commonOcean_XSD.xsd',
 'rb',
 ) as schema_file:
 schema = etree.XMLSchema(etree.parse(schema_file))
 parser = objectify.makeparser(schema=schema, encoding='utf-8')
 try:
 etree.fromstring(commonocean_str, parser)
 except etree.XMLSyntaxError as error:
 raise Exception(
 'Could not produce valid CommmonOcean file! Error: {}'.format(error.msg)
 )
class LocationXMLNode:
 """ Class to create a XML element from a Location."""
 @classmethod
 def create_node(cls, location: Location) -> etree.Element:
 """
 Create XML-Node for a location
 :param location: location object
 :return: node
 """
 location_node = etree.Element('location')
 geo_name_id_node = etree.Element("geoNameId")
 geo_name_id_node.text = str(location.geo_name_id)
 location_node.append(geo_name_id_node)
 gps_latitude_node = etree.Element("gpsLatitude")
 gps_latitude_node.text = str(location.gps_latitude)
 location_node.append(gps_latitude_node)
 gps_longitude_node = etree.Element("gpsLongitude")
 gps_longitude_node.text = str(location.gps_longitude)
 location_node.append(gps_longitude_node)
 if location.geo_transformation is not None:
 location_node.append(GeoTransformationXMLNode.create_node(location.geo_transformation))
 if location.environment is not None:
 location_node.append(EnvironmentXMLNode.create_node(location.environment))
 return location_node
class GeoTransformationXMLNode:
 """ Class to create a XML element from a GeoTransformation."""
 @classmethod
 def create_node(cls, geo_transformation: GeoTransformation) -> etree.Element:
 """
 Create XML-Node for a location
 :param geo_transformation: GeoTransformation object
 :return: node
 """
 geotransform_node = etree.Element('geoTransformation')
 geo_reference_node = etree.Element("geoReference")
 geo_reference_node.text = geo_transformation.geo_reference
 geotransform_node.append(geo_reference_node)
 additional_transformation_node = etree.Element('additionalTransformation')
 x_translation_node = etree.Element("xTranslation")
 x_translation_node.text = str(geo_transformation.x_translation)
 additional_transformation_node.append(x_translation_node)
 y_translation_node = etree.Element("yTranslation")
 y_translation_node.text = str(geo_transformation.y_translation)
 additional_transformation_node.append(y_translation_node)
 z_rotation_node = etree.Element("zRotation")
 z_rotation_node.text = str(geo_transformation.z_rotation)
 additional_transformation_node.append(z_rotation_node)
 scaling_node = etree.Element("scaling")
 scaling_node.text = str(geo_transformation.scaling)
 additional_transformation_node.append(scaling_node)
 geotransform_node.append(additional_transformation_node)
 return geotransform_node
class EnvironmentXMLNode:
 """ Class to create a XML element from a Environment."""
 @classmethod
 def create_node(cls, environment: Environment) -> etree.Element:
 """
 Create XML-Node for a environment
 :param environment: Environment object
 :return: node
 """
 environment_node = etree.Element('environment')
 if environment.time_of_day.value is not TimeOfDay.UNKNOWN:
 time_node = etree.Element('time')
 if environment.time.month < 10:
 time_node.text = str(environment.time.year) + "-0" + str(environment.time.month)
 else:
 time_node.text = str(environment.time.year) + "-" + str(environment.time.month)
 if environment.time.day < 10:
 time_node.text = time_node.text + "-0" + str(environment.time.day)
 else:
 time_node.text = time_node.text + "-" + str(environment.time.day)
 if environment.time.hours < 10:
 time_node.text = time_node.text + "-0" + str(environment.time.hours)
 else:
 time_node.text = time_node.text + "-0" + str(environment.time.hours)
 if environment.time.minutes < 10:
 time_node.text = time_node.text + ":0" + str(environment.time.minutes)
 else:
 time_node.text = time_node.text + ":" + str(environment.time.minutes)
 environment_node.append(time_node)
 time_of_day_node = etree.Element('timeOfDay')
 time_of_day_node.text = environment.time_of_day.value
 environment_node.append(time_of_day_node)
 if environment.weather.value is not Weather.UNKNOWN:
 weather_node = etree.Element('weather')
 weather_node.text = environment.weather.value
 environment_node.append(weather_node)
 if environment.seastate.value is not SeaState.UNKNOWN:
 underground_node = etree.Element('seaState')
 underground_node.text = environment.seastate.value
 environment_node.append(underground_node)
 return environment_node
class TagXMLNode:
 """ Class to create a XML element from a Tag."""
 @classmethod
 def create_node(cls, tags: Set[Tag]) -> etree.Element:
 """
 Create XML-Node for a tag element
 :param tags: list of tags of the scenario
 :return: node
 """
 tags_node = etree.Element('scenarioTags')
 for tag in tags:
 tags_node.append(etree.Element(tag.value))
 return tags_node
class WatersNetworkXMLNode:
 """ Class to create a XML element from a WatersNetwork."""
 @classmethod
 def create_node(cls, watersnetwork: WatersNetwork) -> etree.Element:
 """
 Create XML-Node for a waters network element
 :param watersnetwork: list of of the scenario
 :return: node
 """
 watersnetwork_node = etree.Element('navigationableArea')
 watersnetwork_node.extend(ShapeXMLNode.create_node(watersnetwork.navigationable_area))
 return watersnetwork_node
class WaterwaysXMLNode:
 """ Class to create a XML element from a Waterway."""
 @classmethod
 def create_node(cls, waters: Waterway) -> etree.Element:
 """
 Create XML-Node for a Water
 :param waters: water for creating a node
 :return: node
 """
 waters_node = etree.Element('waterway')
 waters_node.set('id', str(waters.waters_id))
 left_boundary = etree.Element('leftBound')
 Pointlist.create_from_numpy_array(waters.left_vertices).add_points_to_node(
 left_boundary
 )
 waters_node.append(left_boundary)
 right_boundary = etree.Element('rightBound')
 Pointlist.create_from_numpy_array(waters.right_vertices).add_points_to_node(
 right_boundary
 )
 waters_node.append(right_boundary)
 waters_type_node = etree.Element('watersType')
 waters_type_node.text = str(waters.waters_type.value)
 waters_node.append(waters_type_node)
 for l in waters.predecessor:
 predecessor = etree.Element('predecessor')
 predecessor.set('ref', str(l))
 waters_node.append(predecessor)
 for l in waters.successor:
 successor = etree.Element('successor')
 successor.set('ref', str(l))
 waters_node.append(successor)
 if waters.traffic_signs:
 for traffic_sign in waters.traffic_signs:
 traffic_sign_node = TrafficSignXMLNode.create_ref_node(traffic_sign)
 waters_node.append(traffic_sign_node)
 return waters_node
class ShallowXMLNode:
 """ Class to create a XML element from a Shallow."""
 @classmethod
 def create_node(cls, shallow: Shallow) -> etree.Element:
 """
 Create XML-Node for a Shallow
 :param shallow: shallow for creating a node
 :return: node
 """
 shallow_node = etree.Element('shallow')
 shallow_node.set('id', str(shallow.waters_id))
 waters_type_node = etree.Element('watersType')
 waters_type_node.text = str(shallow.waters_type.value)
 shallow_node.append(waters_type_node)
 shape_node = etree.Element('shape')
 shape_node.extend(ShapeXMLNode.create_node(shallow.shape))
 shallow_node.append(shape_node)
 depth_node = etree.Element('depth')
 depth_node.append(create_exact_node_float(shallow.depth))
 shallow_node.append(depth_node)
 return shallow_node
class ObstacleXMLNode:
 """ Class to create a XML element from an Obstacle."""
 @classmethod
 def create_node(cls, obstacle: Union[Obstacle, DynamicObstacle, StaticObstacle]) -> etree.Element:
 """
 Create XML-Node for an Obstacle
 :param obstacle: Obstacle for creating a node
 :return:
 """
 if type(obstacle) == DynamicObstacle:
 return DynamicObstacleXMLNode.create_node(obstacle)
 elif type(obstacle) == StaticObstacle:
 return StaticObstacleXMLNode.create_node(obstacle)
 else:
 raise Exception()
 @classmethod
 def create_obstacle_node_header(
 cls, obstacle_id: int, obstacle_role: ObstacleRole, obstacle_type: ObstacleType, depth: float
 ):
 """
 Create the header of XML-Node for an Obstacle
 :param obstacle_id: id of the obstacle
 :param obstacle_role: role of the obstacle
 :param obstacle_type: type of the obstacle
 :return: node
 """
 obstacle_node = etree.Element(obstacle_role.value+'Obstacle')
 obstacle_node.set('id', str(obstacle_id))
 type_node = etree.Element('type')
 type_node.text = obstacle_type.value
 obstacle_node.append(type_node)
 depth_node = etree.Element('depth')
 depth_node.text = str(depth)
 obstacle_node.append(depth_node)
 return obstacle_node
class StaticObstacleXMLNode:
 """ Class to create a XML element from a StaticObstacle."""
 @classmethod
 def create_node(cls, static_obstacle: StaticObstacle) -> etree.Element:
 """
 Create XML-Node for a StaticObstacle
 :param static_obstacle: static_obstacle for creating a node
 :return: node
 """
 node = ObstacleXMLNode.create_obstacle_node_header(
 static_obstacle.obstacle_id,
 static_obstacle.obstacle_role,
 static_obstacle.obstacle_type,
 static_obstacle.depth
 )
 shape_node = etree.Element('shape')
 shape_node.extend(ShapeXMLNode.create_node(static_obstacle.obstacle_shape))
 node.append(shape_node)
 initial_state_node = etree.Element('initialState')
 StateXMLNode.create_state_node(
 static_obstacle.initial_state,
 initial_state_node,
 time_step=static_obstacle.initial_state.time_step,
 )
 node.append(initial_state_node)
 return node
class DynamicObstacleXMLNode:
 """ Class to create a XML element from a DynamicObstacle."""
 @classmethod
 def create_node(cls, dynamic_obstacle: DynamicObstacle) -> etree.Element:
 """
 Create XML-Node for a DynamicObstacle
 :param dynamic_obstacle: dynamic_obstacle for creating a node
 :return: node
 """
 obstacle_node = ObstacleXMLNode.create_obstacle_node_header(
 dynamic_obstacle.obstacle_id,
 dynamic_obstacle.obstacle_role,
 dynamic_obstacle.obstacle_type,
 dynamic_obstacle.depth
 )
 shape_node = etree.Element('shape')
 shape_node.extend(
 ShapeXMLNode.create_node(
 dynamic_obstacle.obstacle_shape, dynamic_obstacle_shape=True
 )
 )
 obstacle_node.append(shape_node)
 initial_state_node = etree.Element('initialState')
 StateXMLNode.create_state_node(
 dynamic_obstacle.initial_state,
 initial_state_node,
 time_step=dynamic_obstacle.initial_state.time_step,
 )
 obstacle_node.append(initial_state_node)
 if isinstance(dynamic_obstacle.prediction, SetBasedPrediction):
 obstacle_node.append(
 cls._create_occupancy_node(dynamic_obstacle.prediction.occupancy_set)
 )
 elif isinstance(dynamic_obstacle.prediction, TrajectoryPrediction):
 obstacle_node.append(
 cls._create_trajectory_node(dynamic_obstacle.prediction.trajectory)
 )
 return obstacle_node
 @classmethod
 def _create_trajectory_node(cls, trajectory: Trajectory) -> etree.Element:
 """
 Create XML-Node for a Trajectory
 :param trajectory: trajectory for creating a node
 :return: node
 """
 traj_node = etree.Element('trajectory')
 for state in trajectory.state_list:
 state_node = etree.Element('state')
 traj_node.append(
 StateXMLNode.create_state_node(state, state_node, state.time_step)
 )
 return traj_node
 @classmethod
 def _create_occupancy_node(cls, occupancy_set: List[Occupancy]) -> etree.Element:
 """
 Create XML-Node for an occupancy_set
 :param occupancy_set: occupancy_set for creating a node
 :return: node
 """
 occupancy_set_node = etree.Element('occupancySet')
 for occupancy in occupancy_set:
 occupancy_set_node.append(OccupancyXMLNode.create_node(occupancy))
 return occupancy_set_node
class OccupancyXMLNode:
 """ Class to create a XML element from a Occupancy."""
 @classmethod
 def create_node(cls, occupancy: Occupancy) -> etree.Element:
 """
 Create XML-Node for an Occupancy
 :param occupancy: occupancy for creating a node
 :return: node
 """
 occupancy_node = etree.Element('occupancy')
 shape_node = etree.Element('shape')
 shape_node.extend(ShapeXMLNode.create_node(occupancy.shape))
 occupancy_node.append(shape_node)
 time_node = etree.Element('time')
 time = occupancy.time_step
 if isinstance(occupancy.time_step, Interval):
 time_node.extend(create_interval_node_int(time))
 else:
 time_node.append(create_exact_node_int(time))
 occupancy_node.append(time_node)
 return occupancy_node
class ShapeXMLNode:
 """ Class to create a XML element from a Shape."""
 @classmethod
 def create_node(cls, shape, dynamic_obstacle_shape=False) -> List[etree.Element]:
 """
 Create XML-Node for a shape
 :param shape: shape for creating a node
 :param dynamic_obstacle_shape: specify whether the shape belongs to an dynamic obstacle or not
 :return: node
 """
 if type(shape) == ShapeGroup:
 shape_node_list = []
 for s in shape.shapes:
 shape_node_list.append(
 cls._create_single_element(s, dynamic_obstacle_shape)
 )
 else:
 shape_node = cls._create_single_element(shape, dynamic_obstacle_shape)
 shape_node_list = [shape_node]
 return shape_node_list
 @classmethod
 def _create_single_element(
 cls, shape: Shape, dynamic_obstacle_shape: bool
 ) -> etree.Element:
 """
 Create XML-Node for a single shape element
 :param shape: shape for creating a node
 :param dynamic_obstacle_shape: specify whether the shape belongs to an dynamic obstacle or not
 :return: node
 """
 if type(shape) == Rectangle:
 node = RectangleXMLNode.create_rectangle_node(shape, dynamic_obstacle_shape)
 elif type(shape) == Circle:
 node = CircleXMLNode.create_circle_node(shape, dynamic_obstacle_shape)
 elif type(shape) == Polygon:
 node = PolygonXMLNode.create_polygon_node(shape, dynamic_obstacle_shape)
 else:
 raise TypeError(
 '<ShapeXMLNode/_create_single_element> Expected type Polygon, Circle or Rectangle but got %s'
 % (type(shape))
 )
 return node
class RectangleXMLNode:
 """ Class to create a XML element from a Rectangle."""
 @classmethod
 def create_rectangle_node(
 cls, rectangle: Rectangle, dynamic_obstacle_shape=False
 ) -> etree.Element:
 """
 Create XML-Node for a rectangle
 :param rectangle: rectangle for creating a node
 :param dynamic_obstacle_shape: specify whether the shape belongs to an dynamic obstacle or not
 :return: node
 """
 rectangle_node = etree.Element('rectangle')
 length_node = etree.Element('length')
 length_node.text = str(rectangle.length)
 rectangle_node.append(length_node)
 width_node = etree.Element('width')
 width_node.text = str(rectangle.width)
 rectangle_node.append(width_node)
 if not dynamic_obstacle_shape:
 orientation_node = etree.Element('orientation')
 orientation_node.text = str(np.float64(rectangle.orientation))
 rectangle_node.append(orientation_node)
 center_node = etree.Element('center')
 x_node = etree.Element('x')
 x_node.text = str(np.float64(rectangle.center[0]))
 center_node.append(x_node)
 y_node = etree.Element('y')
 y_node.text = str(np.float64(rectangle.center[1]))
 center_node.append(y_node)
 rectangle_node.append(center_node)
 return rectangle_node
class CircleXMLNode:
 """ Class to create a XML element from a Circle."""
 @classmethod
 def create_circle_node(
 cls, circle: Circle, dynamic_obstacle_shape=False
 ) -> etree.Element:
 """
 Create XML-Node for a circle
 :param circle: circle for creating a node
 :param dynamic_obstacle_shape: specify whether the shape belongs to an dynamic obstacle or not
 :return: node
 """
 circle_node = etree.Element('circle')
 radius_node = etree.Element('radius')
 radius_node.text = str(np.float64(circle.radius))
 circle_node.append(radius_node)
 if not dynamic_obstacle_shape:
 center_node = etree.Element('center')
 x_node = etree.Element('x')
 x_node.text = str(np.float64(circle.center[0]))
 center_node.append(x_node)
 y_node = etree.Element('y')
 y_node.text = str(np.float64(circle.center[1]))
 center_node.append(y_node)
 circle_node.append(center_node)
 return circle_node
class PolygonXMLNode:
 """ Class to create a XML element from a Polygon."""
 @classmethod
 def create_polygon_node(
 cls, polygon: Polygon, dynamic_obstacle_shape: bool = False
 ) -> etree.Element:
 """
 Create XML-Node for a polygon
 :param polygon: polygon for creating a node
 :param dynamic_obstacle_shape: specify whether the shape belongs to an dynamic obstacle or not
 :return: node
 """
 polygon_node = etree.Element('polygon')
 for p in polygon.vertices:
 polygon_node.append(Point(p[0], p[1]).create_node())
 return polygon_node
class StateXMLNode:
 """ Class to create a XML element from a CustomState."""
 @classmethod
 def create_waypoint_node(cls, state: GeneralState, waypoint_water_ids: List[int]) -> etree.Element:
 """
 Create XML-Node for a state
 :param state: CommonOcean state
 :param waypoint_water_ids: contains a list of water ids if a waypoint state's position is specified water id(s)
 :return: node
 """
 state_node = etree.Element('waypoint')
 if hasattr(state, 'position') or len(waypoint_water_ids) > 0:
 position = etree.Element('position')
 position = cls._write_goal_position(position, state.position, waypoint_water_ids)
 state_node.append(position)
 if hasattr(state, 'orientation'):
 orientation = etree.Element('orientation')
 orientation = cls._write_value_exact_or_interval(
 orientation, state.orientation
 )
 state_node.append(orientation)
 if hasattr(state, 'time_step'):
 time = etree.Element('time')
 time = cls._write_goal_time_exact_or_interval(time, state.time_step)
 state_node.append(time)
 if hasattr(state, 'velocity'):
 velocity = etree.Element('velocity')
 velocity = cls._write_value_exact_or_interval(velocity, state.velocity)
 state_node.append(velocity)
 if hasattr(state, 'acceleration'):
 acceleration = etree.Element('acceleration')
 acceleration = cls._write_value_exact_or_interval(
 acceleration, state.acceleration
 )
 state_node.append(acceleration)
 if hasattr(state, 'yaw_rate'):
 yaw_rate = etree.Element('yawRate')
 yaw_rate = cls._write_value_exact_or_interval(yaw_rate, state.yaw_rate)
 state_node.append(yaw_rate)
 return state_node
 @classmethod
 def create_goal_state_node(cls, state: GeneralState, goal_waters_ids: List[int]) -> etree.Element:
 """
 Create XML-Node for a state
 :param state: CommonOcean state
 :param goal_waters_ids: contains a list of water ids if a goal state's position is specified water id(s)
 :return: node
 """
 state_node = etree.Element('goalState')
 if hasattr(state, 'position') or len(goal_waters_ids) > 0:
 position = etree.Element('position')
 position = cls._write_goal_position(position, state.position, goal_waters_ids)
 state_node.append(position)
 if hasattr(state, 'orientation'):
 orientation = etree.Element('orientation')
 orientation = cls._write_value_exact_or_interval(
 orientation, state.orientation
 )
 state_node.append(orientation)
 if hasattr(state, 'time_step'):
 time = etree.Element('time')
 time = cls._write_goal_time_exact_or_interval(time, state.time_step)
 state_node.append(time)
 if hasattr(state, 'velocity'):
 velocity = etree.Element('velocity')
 velocity = cls._write_value_exact_or_interval(velocity, state.velocity)
 state_node.append(velocity)
 if hasattr(state, 'acceleration'):
 acceleration = etree.Element('acceleration')
 acceleration = cls._write_value_exact_or_interval(
 acceleration, state.acceleration
 )
 state_node.append(acceleration)
 if hasattr(state, 'yaw_rate'):
 yaw_rate = etree.Element('yawRate')
 yaw_rate = cls._write_value_exact_or_interval(yaw_rate, state.yaw_rate)
 state_node.append(yaw_rate)
 return state_node
 @classmethod
 def _write_goal_position(
 cls, node: etree.Element, position: Union[Shape, int, list], goal_waters_ids: List[int],
 ) -> etree.Element:
 """
 Create XML-Node for a goal position
 :param node: node of the GoalState
 :param position: either (list of) shape elements or water ids specifying the goal position
 :return: node
 """
 if len(goal_waters_ids) > 0:
 for id in goal_waters_ids:
 waters = etree.Element('water')
 waters.set('ref', str(id))
 node.append(waters)
 elif isinstance(position, int):
 waters = etree.Element('water')
 waters.set('ref', str(position))
 node.append(waters)
 elif(
 isinstance(position, Rectangle)
 or isinstance(position, Circle)
 or isinstance(position, Polygon)
 ):
 node.extend(ShapeXMLNode.create_node(position))
 elif isinstance(position, ShapeGroup):
 node.extend(ShapeXMLNode.create_node(position))
 elif type(position) is list:
 raise ValueError('A goal state cannot contain multiple items. Use a list of goal states instead.')
 else:
 raise ValueError('Case should not occur, position={}, goal_waters_ids={}.'.format(position,
 goal_waters_ids))
 return node
 @classmethod
 def _write_goal_time_exact_or_interval(
 cls, node: etree.Element, time_step: Union[Interval, float, int]
 ) -> etree.Element:
 """
 Create XML-Node for a goal time
 :param node: node of the GoalState
 :param time_step: contains time interval or time_step of goal time
 :return: node
 """
 if isinstance(time_step, int):
 node.append(create_exact_node_int(time_step))
 elif isinstance(time_step, Interval):
 node.extend(
 create_interval_node_int(Interval(time_step.start, time_step.end))
 )
 else:
 raise Exception()
 return node
 @classmethod
 def _write_value_exact_or_interval(
 cls, node: etree.Element, var: Union[Interval, float, int]
 ):
 """
 Create XML-Node for a goal value
 :param node: node of the GoalState
 :param var: contains interval or exact_value of goal state value
 :return: node
 """
 if isinstance(var, (float, int)):
 node.append(create_exact_node_float(var))
 elif isinstance(var, Interval):
 node.extend(create_interval_node_float(var))
 else:
 raise Exception()
 return node
 @classmethod
 def create_state_node(
 cls, state: GeneralState, state_node: etree.Element, time_step: int
 ) -> etree.Element:
 """
 Create XML-Node for a state
 :param state: value of the state
 :param state_node: node of the overlying state
 :return: node
 """
 if hasattr(state, 'position'):
 position = etree.Element('position')
 if type(state.position) in [np.ndarray, list]:
 position.append(
 Point.create_from_numpy_array(state.position).create_node()
 )
 state_node.append(position)
 elif isinstance(state.position, Shape):
 position.extend(ShapeXMLNode.create_node(state.position))
 state_node.append(position)
 else:
 raise Exception()
 if hasattr(state, 'orientation'):
 orientation = etree.Element('orientation')
 orientation = cls._write_value_exact_or_interval(
 orientation, state.orientation
 )
 state_node.append(orientation)
 time_node = etree.Element('time')
 time_node.append(create_exact_node_int(time_step))
 state_node.append(time_node)
 if hasattr(state, 'velocity'):
 velocity = etree.Element('velocity')
 velocity = cls._write_value_exact_or_interval(velocity, state.velocity)
 state_node.append(velocity)
 if hasattr(state, 'acceleration'):
 acceleration = etree.Element('acceleration')
 acceleration = cls._write_value_exact_or_interval(
 acceleration, state.acceleration
 )
 state_node.append(acceleration)
 if hasattr(state, 'yaw_rate'):
 yaw_rate = etree.Element('yawRate')
 yaw_rate = cls._write_value_exact_or_interval(yaw_rate, state.yaw_rate)
 state_node.append(yaw_rate)
 return state_node
class PlanningProblemXMLNode:
 """ Class to create a XML element from a PlanningProblem."""
 @classmethod
 def create_node(cls, planning_problem: PlanningProblem) -> etree.Element:
 """
 Create a xml-Node for a single planning_problem
 :param planning_problem: planning problem for creating the node
 :return:
 """
 planning_problem_node = etree.Element('planningProblem')
 planning_problem_node.set('id', str(planning_problem.planning_problem_id))
 if planning_problem.max_lateral_deviation is not None:
 planning_problem_node.set('maxLateralDeviation', str(planning_problem.max_lateral_deviation))
 initial_state_node = etree.Element('initialState')
 planning_problem_node.append(
 StateXMLNode.create_state_node(
 planning_problem.initial_state,
 initial_state_node,
 planning_problem.initial_state.time_step,
 )
 )
 for state_id, goal_state in enumerate(planning_problem.goal.state_list):
 if (
 planning_problem.goal.waters_of_goal_position is not None
 and state_id in planning_problem.goal.waters_of_goal_position
 ):
 goal_waters_ids: List[
 int
 ] = planning_problem.goal.waters_of_goal_position[state_id]
 else:
 goal_waters_ids = []
 planning_problem_node.append(
 StateXMLNode.create_goal_state_node(goal_state, goal_waters_ids)
 )
 if planning_problem.waypoints is not None:
 for waypoint in planning_problem.waypoints:
 state = waypoint.state_list[0]
 planning_problem_node.append(
 StateXMLNode.create_waypoint_node(state, [])
 )
 return planning_problem_node
class TrafficSignXMLNode:
 """ Class to create a XML element from a TrafficSign."""
 @classmethod
 def create_node(cls, traffic_sign: TrafficSign) -> etree.Element:
 """
 Create XML-Node for a state
 :param traffic_sign: TrafficSign object
 :return: node
 """
 traffic_sign_node = etree.Element('trafficSign')
 traffic_sign_node.set('id', str(traffic_sign.traffic_sign_id))
 for element in traffic_sign.traffic_sign_elements:
 element_node = etree.Element('trafficSignElement')
 sign_id_node = etree.Element('trafficSignID')
 sign_id_node.text = str(element.traffic_sign_element_id.value)
 if str(element.traffic_sign_element_id.value) == '':
 warnings.warn('<FileWriter>: Invalid traffic sign ID!')
 element_node.append(sign_id_node)
 for value in element.additional_values:
 value_node = etree.Element('additionalValue')
 value_node.text = str(value)
 element_node.append(value_node)
 traffic_sign_node.append(element_node)
 if traffic_sign.position is not None:
 position_node = etree.Element('position')
 position_node.append(Point(traffic_sign.position[0],
 traffic_sign.position[1]).create_node())
 traffic_sign_node.append(position_node)
 if traffic_sign.virtual is not None:
 virtual_node = etree.Element('virtual')
 virtual_node.text = str(traffic_sign.virtual).lower()
 traffic_sign_node.append(virtual_node)
 return traffic_sign_node
 @classmethod
 def create_ref_node(cls, traffic_sign_ref) -> etree.Element:
 traffic_sign_ref_node = etree.Element('trafficSignRef')
 traffic_sign_ref_node.set('ref', str(traffic_sign_ref))
 return traffic_sign_ref_node
</src\commonocean\common\file_writer.py>

<src\commonocean\common\solution.py>
import math
import os
import platform
import re
import subprocess
from xml.dom import minidom
import numpy as np
import xml.etree.ElementTree as et
from enum import Enum, unique
from typing import List, Tuple, Union, Dict
from datetime import datetime
import vesselmodels.parameters_vessel_1 as p1
import vesselmodels.parameters_vessel_2 as p2
import vesselmodels.parameters_vessel_3 as p3
from commonroad.common.validity import is_real_number, is_positive
from commonroad.geometry.shape import Rectangle
from commonocean.prediction.prediction import TrajectoryPrediction
from commonocean.scenario.obstacle import DynamicObstacle, ObstacleType
from commonocean.scenario.scenario import ScenarioID
from commonocean.scenario.trajectory import Trajectory
from commonocean.scenario.state import GeneralState
# Tunneling from CR-IO #
from commonroad.common.solution import SolutionException, StateTypeException, SolutionReaderException
########################
__author__ = "Bruno Maione, Hanna Krasowski"
__copyright__ = "TUM Cyber-Physical Systems Group"
__credits__ = ""
__version__ = "2022.1"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "Released"
@unique
class VesselType(Enum):
 Vessel1 = 1
 Vessel2 = 2
 Vessel3 = 3
vessel_parameters = {VesselType.Vessel1: p1.parameters_vessel_1(),
 VesselType.Vessel2: p2.parameters_vessel_2(),
 VesselType.Vessel3: p3.parameters_vessel_3()}
@unique
class VesselModel(Enum):
 PM = 0
 VP = 1
 YP = 2
 TF = 3
@unique
class CostFunction(Enum):
 JB1 = 0
 VRCO1 = 1
 RC1 = 2
 SB1 = 3
@unique
class StateFields(Enum):
 """
 State Fields enum class for defining the state fields for vessel models for different trajectory types.
 PM | VP | YP | TF -> Corresponding state fields for trajectory states
 __Name__Input -> Input fields for correspondent vessel models
 Note: If you change the order of field names, don't forget to change the order on the XMLStateFields enum as well,
 because the indexes have to match.
 """
 PMVP = ['position', 'velocity', 'velocity_y', 'time_step']
 PMVPInput = ['acceleration', 'acceleration_y', 'time_step']
 YP = ['position', 'orientation', 'velocity', 'time_step']
 YPInput = ['acceleration', 'yaw_rate', 'time_step']
 TF = ['position', 'orientation', 'velocity', 'velocity_y', 'yaw_rate', 'time_step']
 TFInput = ['force_orientation','force_lateral','yaw_moment', 'time_step']
@unique
class XMLStateFields(Enum):
 """
 XML names of the state fields for vessel models for different trajectory types.
 PM | VP | YP | TF -> Corresponding xml names of the state fields for trajectory states
 __Name__Input -> XML names of the input fields for correspondent vessel models.
 Note: If you change the order of xml names, don't forget to change the order on the StateFields enum as well,
 because the indexes have to match.
 """
 PMVP = [('x', 'y'), 'xVelocityFront', 'yVelocityFront', 'time']
 PMVPInput = ['xAcceleration', 'yAcceleration', 'time']
 YP = [('x', 'y'), 'orientation', 'xVelocityFront', 'time']
 YPInput = ['xAcceleration', 'yawRate', 'time']
 TF = [('x', 'y'), 'orientation', 'xVelocityFront', 'yVelocityFront', 'yawRate', 'time']
 TFInput = ['forceOrientation', 'forceLateral', 'yawMoment', 'time']
@unique
class StateType(Enum):
 """
 State Type enum class.
 PM | VP | YP | TF -> Corresponding state type for trajectory states
 __Name__Input -> Input type correspondent vessel models
 """
 PMVP = 'pmvpState'
 YP = 'ypState'
 TF = 'tfState'
 PMVPInput = 'PMVPInput'
 YPInput = 'YPInput'
 TFInput = 'TFInput'
 @property
 def fields(self) -> List[str]:
 """
 Returns the state fields for the state type.
 :return: State fields as list
 """
 return StateFields[self.name].value
 @property
 def xml_fields(self) -> List[str]:
 """
 Returns the xml state fields for the state type.
 :return: XML names of the state fields as list
 """
 return XMLStateFields[self.name].value
 @classmethod
 def get_state_type(cls, state: GeneralState, desired_vessel_model: VesselModel = None) -> 'StateType':
 """
 Returns the corresponding StateType for the given State object by matching State object's attributes
 to the state fields.
 :param state: CommonOcean State object
 :param desired_vessel_model: check if given vessel_model is supported first
 :return: corresponding StateType
 """
 # put desired_vessel_model first
 attrs = state.attributes
 if desired_vessel_model.name == 'PM' or desired_vessel_model.name == 'VP':
 search_name = 'PMVP'
 else:
 search_name = str(desired_vessel_model.name)
 if desired_vessel_model is not None:
 state_fields_all = [StateFields[search_name], StateFields.YPInput, StateFields.TFInput, StateFields.PMVPInput]
 state_fields_add = []
 for sf in StateFields:
 if sf not in state_fields_all:
 state_fields_add.append(sf)
 state_fields_all += state_fields_add
 for state_fields in state_fields_all:
 if not len(attrs) >= len(state_fields.value):
 continue # >=
 if not all([sf in attrs for sf in state_fields.value]):
 continue
 return cls[state_fields.name]
 else:
 state_fields_all = StateFields
 for state_fields in state_fields_all:
 if not len(attrs) == len(state_fields.value):
 continue # ==
 if not all([sf in attrs for sf in state_fields.value]):
 continue
 return cls[state_fields.name]
 raise StateTypeException('Given state is not valid!')
 @classmethod
 def check_state_type(cls, vessel_model: VesselModel) -> None:
 """
 Checks whether vessel model can be supported by trajectory.
 :param vessel_model: vessel model enum
 :return: bool
 """
 StateFields(vessel_model.name)
@unique
class TrajectoryType(Enum):
 """
 Trajectory Type enum class.
 PM | VP | YP | TF -> Corresponding trajectory type for the vessel models
 __Name__Input -> InputVector type for PM, VP, YP and TF vessel models
 """
 PMVP = 'pmvpTrajectory'
 PMVPInput = 'PMVPInputVector'
 YP = 'ypTrajectory'
 YPInput = 'YPInputVector'
 TF = 'tfTrajectory'
 TFInput = 'TFInputVector'
 @property
 def state_type(self) -> StateType:
 """
 Returns the StateType corresponding to the TrajectoryType
 :return: StateType
 """
 return StateType[self.name]
 @classmethod
 def get_trajectory_type(cls, trajectory: Trajectory,
 desired_vessel_model: VesselModel = None) -> 'TrajectoryType':
 """
 Returns the corresponding TrajectoryType for the given Trajectory object based on the StateType of its states.
 :param trajectory: CommonOcean Trajectory object
 :param desired_vessel_model: check if given vessel_model is supported first
 :return: corresponding TrajectoryType
 """
 state_type = StateType.get_state_type(trajectory.state_list[0], desired_vessel_model)
 return cls[state_type.name]
 def valid_vessel_model(self, vessel_model: VesselModel) -> bool:
 """
 Checks whether given vessel model is valid for the TrajectoryType.
 :param vessel_model: CommonOcean enum for vessel models
 :return: True if the vessel model is valid for the TrajectoryType
 """
 return any([
 self.name == 'PMVP' and vessel_model == VesselModel.PM,
 self.name == 'PMVP' and vessel_model == VesselModel.VP,
 self.name == 'YP' and vessel_model == VesselModel.YP,
 self.name == 'TF' and vessel_model == VesselModel.TF,
 self.name == 'PMVPInput' and vessel_model == VesselModel.PM,
 self.name == 'PMVPInput' and vessel_model == VesselModel.VP,
 self.name == 'YPInput' and vessel_model == VesselModel.YP,
 self.name == 'TFInput' and vessel_model == VesselModel.TF,
 self.name == vessel_model.name
 ])
class SupportedCostFunctions(Enum):
 """
 Enum class for specifying which cost functions are supported for which vessel model
 """
 PM = [cost_function for cost_function in CostFunction] # Supports all cost functions
 VP = [cost_function for cost_function in CostFunction] # Supports all cost functions
 YP = [cost_function for cost_function in CostFunction] # Supports all cost functions
 TF = [cost_function for cost_function in CostFunction] # Supports all cost functions
class PlanningProblemSolution:
 def __init__(self,
 planning_problem_id: int,
 vessel_model: VesselModel,
 vessel_type: VesselType,
 cost_function: CostFunction,
 trajectory: Trajectory):
 """
 Constructor for the PlanningProblemSolution class.
 :param planning_problem_id: ID of the planning problem
 :param vessel_model: VesselModel used for the solution
 :param vessel_type: VesselType used for the solution
 :param cost_function: CostFunction the solution will be evaluated with
 :param trajectory: Ego vessel's trajectory for the solution.
 """
 self.planning_problem_id = planning_problem_id
 self._vessel_model = vessel_model
 self.vessel_type = vessel_type
 self._cost_function = cost_function
 self._trajectory = trajectory
 self._trajectory_type = TrajectoryType.get_trajectory_type(self._trajectory, self.vessel_model)
 self._check_trajectory_supported(self._vessel_model, self._trajectory_type)
 self._check_cost_supported(self._vessel_model, self._cost_function)
 @staticmethod
 def _check_cost_supported(vessel_model: VesselModel, cost_function: CostFunction) -> bool:
 """
 Checks whether given cost function is supported by the given vessel model.
 :param vessel_model: VesselModel
 :param cost_function: CostFunction
 :return: True if supported.
 """
 supported_costs = SupportedCostFunctions[vessel_model.name].value
 if cost_function not in supported_costs:
 raise SolutionException("Cost function %s isn't supported for %s model!" % (cost_function.name,
 vessel_model.name))
 return True
 def _check_trajectory_supported(self, vessel_model: VesselModel, trajectory_type: TrajectoryType) -> bool:
 """
 Checks whether given vessel model is valid for the given trajectory type.
 :param vessel_model: VesselModel
 :param trajectory_type: TrajectoryType
 :return: True if valid.
 """
 ######################## ATTENTION ########################
 if self._vessel_model == VesselModel.PM and self._trajectory_type == TrajectoryType.PMVP:
 for state in self._trajectory.state_list:
 if not hasattr(state, 'orientation'):
 state.orientation = math.atan2(state.velocity_y, state.velocity)
 if self._vessel_model == VesselModel.VP and self._trajectory_type == TrajectoryType.PMVP:
 for state in self._trajectory.state_list:
 if not hasattr(state, 'orientation'):
 state.orientation = math.atan2(state.velocity_y, state.velocity)
 ######################## ATTENTION ########################
 if not trajectory_type.valid_vessel_model(vessel_model):
 raise SolutionException('Vessel model %s is not valid for the trajectory type %s!'
 % (vessel_model.name, trajectory_type.name))
 return True
 @property
 def vessel_model(self) -> VesselModel:
 """ VesselModel of the PlanningProblemSolution """
 return self._vessel_model
 @vessel_model.setter
 def vessel_model(self, vessel_model: VesselModel):
 self._check_trajectory_supported(vessel_model, self._trajectory_type)
 self._check_cost_supported(vessel_model, self.cost_function)
 self._vessel_model = vessel_model
 @property
 def cost_function(self) -> CostFunction:
 """ CostFunction of the PlanningProblemSolution """
 return self._cost_function
 @cost_function.setter
 def cost_function(self, cost_function: CostFunction):
 self._check_cost_supported(self.vessel_model, cost_function)
 self._cost_function = cost_function
 @property
 def trajectory(self) -> Trajectory:
 """ Trajectory of the PlanningProblemSolution """
 return self._trajectory
 @trajectory.setter
 def trajectory(self, trajectory: Trajectory):
 trajectory_type = TrajectoryType.get_trajectory_type(trajectory)
 self._check_trajectory_supported(self.vessel_model, trajectory_type)
 self._trajectory = trajectory
 self._trajectory_type = trajectory_type
 @property
 def trajectory_type(self) -> TrajectoryType:
 """
 TrajectoryType of the PlanningProblemSolution.
 Dynamically assigned when there is a change of trajectory.
 """
 return self._trajectory_type
 @property
 def vessel_id(self) -> str:
 """
 Returns the Vessel id as string.
 Example:
 VesselModel = VP
 VesselType = Vessel1
 Vessel ID = VP1
 :return: vessel model ID
 """
 return self.vessel_model.name + str(self.vessel_type.value)
 @property
 def cost_id(self) -> str:
 """
 Returns cost function id as str.
 Example:
 CostFunction = JB1
 Cost ID = JB1
 :return: Cost function ID
 """
 return self.cost_function.name
class Solution:
 """Stores a solution to a CommonOcean benchmark and additional meta data."""
 def __init__(self,
 scenario_id: ScenarioID,
 planning_problem_solutions: List[PlanningProblemSolution],
 date: datetime = datetime.today(),
 computation_time: Union[float, None] = None,
 processor_name: Union[str, None] = None):
 """
 :param scenario_id: Scenario ID of the Solution
 :param planning_problem_solutions: List of PlanningProblemSolution for corresponding
 to the planning problems of the scenario
 :param date: The date solution was produced. Default=datetime.today()
 :param computation_time: The computation time measured in seconds for the Solution. Default=None
 :param processor_name: The processor model used for the Solution. Determined automatically if set to 'auto'.
 Default=None.
 """
 self.scenario_id = scenario_id
 self._planning_problem_solutions: Dict[int, PlanningProblemSolution] = {}
 self.planning_problem_solutions = planning_problem_solutions
 self.date = date
 self._computation_time = None
 self.computation_time = computation_time
 self.processor_name = processor_name
 @property
 def planning_problem_solutions(self) -> List[PlanningProblemSolution]:
 return list(self._planning_problem_solutions.values())
 @planning_problem_solutions.setter
 def planning_problem_solutions(self, planning_problem_solutions: List[PlanningProblemSolution]):
 self._planning_problem_solutions = {s.planning_problem_id: s for s in planning_problem_solutions}
 @property
 def benchmark_id(self) -> str:
 """
 Returns the benchmark id of the solution as string.
 Example:
 Scenario ID = TEYP
 VesselModel = VP
 VesselType = Vessel1
 CostFunction = JB1
 Version = 2022a
 Benchmark ID = VP1:JB1:TEYP:2022a
 Collaborative Solution Example:
 Scenario ID = TEYP
 1st VesselModel = VP
 1st VesselType = Vessel1
 1st CostFunction = JB1
 2nd VesselModel = PM
 2nd VesselType = Vessel3
 2nd CostFunction = RC1
 Version = 2020a
 Benchmark ID = [VP1,PM3]:[JB1,RC1]:TEYP:2020a
 :return: Benchmark ID
 """
 vessels_ids = self.vessels_ids
 cost_ids = self.cost_ids
 vessels_str = vessels_ids[0] if len(vessels_ids) == 1 else '[%s]' % ','.join(vessels_ids)
 costs_str = cost_ids[0] if len(cost_ids) == 1 else '[%s]' % ','.join(cost_ids)
 return '%s:%s:%s:%s' % (vessels_str, costs_str, str(self.scenario_id), self.scenario_id.scenario_version)
 @property
 def vessels_ids(self) -> List[str]:
 """
 Returns the list of vessel ids of all PlanningProblemSolutions of the Solution
 Example:
 1st PlanningProblemSolution Vessel ID = VP1
 2nd PlanningProblemSolution Vessel ID = VP3
 Vessel IDS = [VP1, VP3]
 :return: List of vessel IDs
 """
 return [pp_solution.vessel_id for pp_solution in self.planning_problem_solutions]
 @property
 def cost_ids(self) -> List[str]:
 """
 Returns the list of cost ids of all PlanningProblemSolutions of the Solution
 Example:
 1st PlanningProblemSolution Cost ID = JB1
 2nd PlanningProblemSolution Cost ID = RC1
 Cost IDS = [JB1, RC1]
 :return: List of cost function IDs
 """
 return [pp_solution.cost_id for pp_solution in self.planning_problem_solutions]
 @property
 def planning_problem_ids(self) -> List[int]:
 """
 Returns the list of planning problem ids of all PlanningProblemSolutions of the Solution
 Example:
 1st PlanningProblemSolution planning_problem_id = 0
 2nd PlanningProblemSolution planning_problem_id = 1
 planning_problem_ids = [0, 1]
 :return: List of planning problem ids
 """
 return [pp_solution.planning_problem_id for pp_solution in self.planning_problem_solutions]
 @property
 def trajectory_types(self) -> List[TrajectoryType]:
 """
 Returns the list of trajectory types of all PlanningProblemSolutions of the Solution
 Example:
 1st PlanningProblemSolution trajectory_type = TrajectoryType.VP
 2nd PlanningProblemSolution trajectory_type = TrajectoryType.TF
 trajectory_types = [TrajectoryType.VP, TrajectoryType.TF]
 :return: List of trajectory types
 """
 return [pp_solution.trajectory_type for pp_solution in self.planning_problem_solutions]
 @property
 def computation_time(self) -> Union[None, float]:
 """
 Return the computation time [s] for the trajectory.
 :return:
 """
 return self._computation_time
 @computation_time.setter
 def computation_time(self, computation_time):
 if computation_time is not None:
 assert is_real_number(computation_time), "<Solution> computation_time provided as type {}," \
 "but expected type float," \
 "measured in seconds!".format(type(computation_time))
 assert is_positive(computation_time), "<Solution> computation_time needs to be positive!"\
 .format(type(computation_time))
 self._computation_time = computation_time
 def create_dynamic_obstacle(self) -> Dict[int, DynamicObstacle]:
 """
 Creates dynamic obstacle(s) from solution(s) for every planning problem.
 :return:
 """
 obs = {}
 for pp_id, solution in self._planning_problem_solutions.items():
 shape = Rectangle(length=vessel_parameters[solution.vessel_type].l,
 width=vessel_parameters[solution.vessel_type].w)
 trajectory = Trajectory(initial_time_step=solution.trajectory.initial_time_step + 1,
 state_list=solution.trajectory.state_list[1:])
 prediction = TrajectoryPrediction(trajectory, shape=shape)
 obs[pp_id] = DynamicObstacle(obstacle_id=pp_id,
 obstacle_type=ObstacleType.MOTORVESSEL,
 obstacle_shape=shape,
 initial_state=solution.trajectory.state_list[0],
 prediction=prediction)
 return obs
class CommonOceanSolutionReader:
 """Reads solution xml files created with the CommonOceanSolutionWriter"""
 @classmethod
 def open(cls, filepath: str) -> Solution:
 """
 Opens and parses the Solution XML file located on the given path.
 :param filepath: Path to the file.
 :return: Solution
 """
 tree = et.parse(filepath)
 root_node = tree.getroot()
 return cls._parse_solution(root_node)
 @classmethod
 def fromstring(cls, file: str) -> Solution:
 """
 Parses the given Solution XML string.
 :param file: xml file as string
 :return: Solution
 """
 root_node = et.fromstring(file)
 return cls._parse_solution(root_node)
 @classmethod
 def _parse_solution(cls, root_node: et.Element) -> Solution:
 """ Parses the Solution XML root node. """ # TODO
 benchmark_id, date, computation_time, processor_name = cls._parse_header(root_node)
 vessels_ids, cost_ids, scenario_id = cls._parse_benchmark_id(benchmark_id)
 pp_solutions = [cls._parse_planning_problem_solution(vessels_ids[idx], cost_ids[idx], trajectory_node)
 for idx, trajectory_node in enumerate(root_node)]
 return Solution(scenario_id, pp_solutions, date, computation_time, processor_name)
 @staticmethod
 def _parse_header(root_node: et.Element) -> Tuple[str, Union[None, datetime], Union[None, float], Union[None, str]]:
 """ Parses the header attributes for the given Solution XML root node. """
 benchmark_id = root_node.get('benchmark_id')
 if not benchmark_id:
 SolutionException("Solution xml does not have a benchmark id!")
 date = root_node.attrib.get('date', None) # None if not found
 if date is not None:
 try:
 date = datetime.strptime(date, '%Y-%m-%dT%H:%M:%S')
 except ValueError:
 # backward compatibility with old solution files
 date = datetime.strptime(date, '%Y-%m-%d')
 computation_time = root_node.attrib.get('computation_time', None)
 if computation_time is not None:
 computation_time = float(computation_time)
 processor_name = root_node.attrib.get('processor_name', None)
 return benchmark_id, date, computation_time, processor_name
 @classmethod
 def _parse_planning_problem_solution(cls, vessel_id: str, cost_id: str,
 trajectory_node: et.Element) -> PlanningProblemSolution:
 """ Parses PlanningProblemSolution from the given XML node. """
 vessel_model, vessel_type = cls._parse_vessel_id(vessel_id)
 if cost_id not in [cfunc.name for cfunc in CostFunction]:
 raise SolutionReaderException("Invalid Cost ID: " + cost_id)
 cost_function = CostFunction[cost_id]
 pp_id, trajectory = cls._parse_trajectory(trajectory_node)
 return PlanningProblemSolution(pp_id, vessel_model, vessel_type, cost_function, trajectory)
 @classmethod
 def _parse_trajectory(cls, trajectory_node: et.Element) -> Tuple[int, Trajectory]:
 """ Parses Trajectory and planning problem id from the given XML node. """
 if trajectory_node.tag not in [ttype.value for ttype in TrajectoryType]:
 raise SolutionReaderException("Invalid Trajectory Type: " + trajectory_node.tag)
 trajectory_type = TrajectoryType(trajectory_node.tag)
 planning_problem_id = int(trajectory_node.get('planningProblem'))
 state_list = [cls._parse_state(trajectory_type.state_type, state_node) for state_node in trajectory_node]
 state_list = sorted(state_list, key=lambda state: state.time_step)
 return planning_problem_id, Trajectory(initial_time_step=state_list[0].time_step, state_list=state_list)
 @classmethod
 def _parse_sub_element(cls, state_node: et.Element, name: str, as_float: bool = True) -> Union[float, int]:
 """ Parses the sub elements from the given XML node. """
 elem = state_node.find(name)
 if elem is None:
 raise SolutionReaderException("Element '%s' couldn't be found in the xml node!" % name)
 value = float(elem.text) if as_float else int(elem.text)
 return value
 @classmethod
 def _parse_state(cls, state_type: StateType, state_node: et.Element) -> GeneralState:
 """ Parses State from the given XML node. """
 if not state_node.tag == state_type.value:
 raise SolutionReaderException("Given xml node is not a '%s' node!" % state_type.value)
 state_vals = {}
 for mapping in list(zip(state_type.xml_fields, state_type.fields)):
 xml_name = mapping[0]
 field_name = mapping[1]
 if isinstance(xml_name, tuple):
 state_vals[field_name] = np.array([cls._parse_sub_element(state_node, name) for name in xml_name])
 else:
 state_vals[field_name] = cls._parse_sub_element(state_node, xml_name, as_float=(not xml_name == 'time'))
 return GeneralState(**state_vals)
 @staticmethod
 def _parse_benchmark_id(benchmark_id: str) -> (List[str], List[str], str):
 """ Parses the given benchmark id string. """
 segments = benchmark_id.replace(' ', '').split(':')
 if len(segments) != 4:
 raise SolutionReaderException("Invalid Benchmark ID: " + benchmark_id)
 vessel_model_ids = re.sub(r'[\[\]]', '', segments[0]).split(',')
 cost_function_ids = re.sub(r'[\[\]]', '', segments[1]).split(',')
 scenario_id = ScenarioID.from_benchmark_id(segments[2], segments[3])
 return vessel_model_ids, cost_function_ids, scenario_id
 @staticmethod
 def _parse_vessel_id(vessel_id: str) -> Tuple[VesselModel, VesselType]:
 """ Parses the given vessel id string. """
 if not len(vessel_id) == 3:
 raise SolutionReaderException("Invalid Vessel ID: " + vessel_id)
 if not vessel_id[:2] in [vmodel.name for vmodel in VesselModel]:
 raise SolutionReaderException("Invalid Vessel ID: " + vessel_id)
 if not int(vessel_id[2]) in [vtype.value for vtype in VesselType]:
 raise SolutionReaderException("Invalid Vessel ID: " + vessel_id)
 return VesselModel[vessel_id[:2]], VesselType(int(vessel_id[2]))
class CommonOceanSolutionWriter:
 def __init__(self, solution: Solution):
 """
 Creates the xml file for the given solution that can be dumped as string, or written to file later on.
 :param solution: Solution.
 """
 assert isinstance(solution, Solution)
 self.solution = solution
 self._solution_root = self._serialize_solution(self.solution)
 @staticmethod
 def _get_processor_name() -> Union[str, None]:
 # TODO: compare cpu names with the list of cpu names used on web server
 delete_from_cpu_name = ['(R)', '(TM)']
 def strip_substrings(string: str):
 for del_string in delete_from_cpu_name:
 string = string.replace(del_string, '')
 return string
 if platform.system() == "Windows":
 name_tmp = platform.processor()
 for del_str in delete_from_cpu_name:
 name_tmp.replace(del_str, '')
 return strip_substrings(name_tmp)
 elif platform.system() == "Darwin":
 os.environ['PATH'] = os.environ['PATH'] + os.pathsep + '/usr/sbin'
 command = "sysctl -n machdep.cpu.brand_string"
 return str(subprocess.check_output(command, shell=True).strip())
 elif platform.system() == "Linux":
 command = "cat /proc/cpuinfo"
 all_info = str(subprocess.check_output(command, shell=True).strip())
 for line in all_info.split("\\n"):
 if "model name" in line:
 name_tmp = re.sub(".*model name.*: ", "", line, 1)
 return strip_substrings(name_tmp)
 return None
 @classmethod
 def _serialize_solution(cls, solution: Solution) -> et.Element:
 """ Serializes the given solution. """
 root_node = cls._create_root_node(solution)
 for pp_solution in solution.planning_problem_solutions:
 trajectory_node = cls._create_trajectory_node(pp_solution.trajectory_type,
 pp_solution.planning_problem_id,
 pp_solution.trajectory)
 root_node.append(trajectory_node)
 return root_node
 @classmethod
 def _create_root_node(cls, solution: Solution) -> et.Element:
 """ Creates the root node of the Solution XML. """
 root_node = et.Element('CommonOceanSolution')
 root_node.set('benchmark_id', solution.benchmark_id)
 if solution.computation_time is not None:
 root_node.set('computation_time', str(solution.computation_time))
 if solution.date is not None:
 root_node.set('date', solution.date.strftime('%Y-%m-%dT%H:%M:%S'))
 processor_name = cls._get_processor_name() if solution.processor_name == 'auto' else solution.processor_name
 if processor_name is not None:
 root_node.set('processor_name', processor_name)
 return root_node
 @classmethod
 def _create_trajectory_node(cls, trajectory_type: TrajectoryType, pp_id: int, trajectory: Trajectory) -> et.Element:
 """ Creates the Trajectory XML Node for the given trajectory. """
 trajectory_node = et.Element(trajectory_type.value)
 trajectory_node.set('planningProblem', str(pp_id))
 for state in trajectory.state_list:
 state_node = cls._create_state_node(trajectory_type.state_type, state)
 trajectory_node.append(state_node)
 return trajectory_node
 @classmethod
 def _create_sub_element(cls, name: str, value: Union[float, int]) -> et.Element:
 """ Creates an XML element for the given value. """
 element = et.Element(name)
 element.text = str(np.float64(value) if isinstance(value, float) else value)
 return element
 @classmethod
 def _create_state_node(cls, state_type: StateType, state: GeneralState) -> et.Element:
 """ Creates XML nodes for the States of the Trajectory. """
 state_node = et.Element(state_type.value)
 for mapping in list(zip(state_type.xml_fields, state_type.fields)):
 xml_name = mapping[0]
 state_val = getattr(state, mapping[1])
 if isinstance(xml_name, tuple):
 for idx, name in enumerate(xml_name):
 state_node.append(cls._create_sub_element(name, state_val[idx]))
 else:
 state_node.append(cls._create_sub_element(xml_name, state_val))
 return state_node
 def dump(self, pretty: bool = True) -> str:
 """
 Dumps the Solution XML as string.
 :param pretty: If set to true, prettifies the xml string.
 :return: string - Solution XML as string.
 """
 rough_string = et.tostring(self._solution_root, encoding='utf-8')
 if not pretty:
 return rough_string
 parsed = minidom.parseString(rough_string)
 return parsed.toprettyxml(indent=" ")
 def write_to_file(self, output_path: str = './', filename: str = None,
 overwrite: bool = False, pretty: bool = True):
 """
 Writes the Solution XML to a file.
 :param output_path: Output dir where the Solution XML file should be written to. \
 Writes to the same folder where it is called from if not specified.
 :param filename: Name of the Solution XML file. If not specified, sets the name as 'solution_BENCHMARKID.xml' \
 where the BENCHMARKID is the benchmark_id of the solution.
 :param overwrite: If set to True, overwrites the file if it already exists.
 :param pretty: If set to True, prettifies the Solution XML string before writing to file.
 """
 filename = filename if filename is not None else 'solution_%s.xml' % self.solution.benchmark_id
 fullpath = os.path.join(output_path, filename) if filename is not None else os.path.join(output_path, filename)
 if not os.path.exists(os.path.dirname(fullpath)):
 raise NotADirectoryError("Directory %s does not exist." % os.path.dirname(fullpath))
 if os.path.exists(fullpath) and not overwrite:
 raise FileExistsError("File %s already exists. If you want to overwrite it set overwrite=True." % fullpath)
 with open(fullpath, 'w') as f:
 f.write(self.dump(pretty))
</src\commonocean\common\solution.py>

<src\commonocean\planning\goal.py>
import copy
import math
from typing import Union, List, Dict, Set
import numpy as np
import warnings
from commonroad.geometry.shape import Shape
from commonocean.scenario.state import GeneralState
from commonroad.common.util import Interval, AngleInterval
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
class GoalRegion:
 def __init__(self, state_list: List[GeneralState],
 waters_of_goal_position: Union[None, Dict[int, List[int]]] = None):
 """
 Region, that has to be reached by the vessel. Contains a list of goal states of which one has to be fulfilled
 to solve the scenario. If 'position' in a goal state is given as a list of waters, they are converted into a
 polygon. To reconstruct the waters later, the water ids are stored in a dict in waters_of_goal_position.
 In no 'position' is given as water, waters_of_goal_position is set to None.
 :param state_list: list of goal states (one of those has to be fulfilled)
 :param waters_of_goal_position: dict[index of state in state_list, list of water ids].
 None, if no water is given.
 """
 self.state_list = state_list
 self.waters_of_goal_position = waters_of_goal_position
 @property
 def state_list(self) -> List[GeneralState]:
 """List that contains all goal states"""
 return self._state_list
 @state_list.setter
 def state_list(self, state_list: List[GeneralState]):
 for state in state_list:
 self._validate_goal_state(state)
 self._state_list = state_list
 @property
 def waters_of_goal_position(self) -> Union[None, Dict[int, List[int]]]:
 """Dict that contains the index of the state in the state_list to which the waters belong. \
 None, if goal position is not a water"""
 return self._waters_of_goal_position
 @waters_of_goal_position.setter
 def waters_of_goal_position(self, waters: Union[None, Dict[int, List[int]]]):
 if not hasattr(self, '_waters_of_goal_position'):
 if waters is not None:
 assert isinstance(waters, dict)
 assert all(isinstance(x, int) for x in waters.keys())
 assert all(isinstance(x, list) for x in waters.values())
 assert all(isinstance(x, int) for waters_list in waters.values() for x in waters_list)
 self._waters_of_goal_position = waters
 else:
 warnings.warn('<GoalRegion/waters_of_goal_position> waters_of_goal_position are immutable')
 def is_reached(self, state: GeneralState) -> bool:
 """
 Checks if a given state is inside the goal region.
 :param state: state with exact values
 :return: True, if state fulfills all requirements of the goal region. False if at least one requirement of the \
 goal region is not fulfilled.
 """
 is_reached_list = list()
 for goal_state in self.state_list:
 goal_state_tmp = copy.deepcopy(goal_state)
 goal_state_fields = set(goal_state.used_attributes)
 state_fields = set(state.used_attributes)
 state_new, state_fields, goal_state_tmp, goal_state_fields = \
 self._harmonize_state_types(state, goal_state_tmp, state_fields, goal_state_fields)
 if not goal_state_fields.issubset(state_fields):
 raise ValueError('The goal states {} are not a subset of the provided states {}!'
 .format(goal_state_fields, state_fields))
 is_reached = True
 if hasattr(goal_state, 'time_step'):
 is_reached = is_reached and self._check_value_in_interval(state_new.time_step, goal_state.time_step)
 if hasattr(goal_state, 'position'):
 is_reached = is_reached and goal_state.position.contains_point(state_new.position)
 if hasattr(goal_state, 'orientation'):
 is_reached = is_reached and self._check_value_in_interval(state_new.orientation, goal_state.orientation)
 if hasattr(goal_state, 'velocity'):
 is_reached = is_reached and self._check_value_in_interval(state_new.velocity, goal_state.velocity)
 is_reached_list.append(is_reached)
 return np.any(is_reached_list)
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 translate and rotates the goal region with given translation and angle around the origin (0, 0)
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 for i, state in enumerate(self.state_list):
 self.state_list[i] = state.translate_rotate(translation, angle)
 @classmethod
 def _check_value_in_interval(cls, value: Union[int, float], desired_interval: Union[AngleInterval, Interval]) -> \
 bool:
 """
 Checks if an exact value is included in the desired interval. If desired_interval is not an interval,
 an exception is thrown.
 :param value: int or float value to test
 :param desired_interval: Desired interval in which value is tested
 :return: True, if value matches the desired_value, False if not.
 """
 if isinstance(desired_interval, (Interval, AngleInterval)):
 is_reached = desired_interval.contains(value)
 else:
 raise ValueError("<GoalRegion/_check_value_in_interval>: argument 'desired_interval' of wrong type. "
 "Expected type: {}. Got type: {}.".format((type(Interval), type(AngleInterval)),
 type(desired_interval)))
 return is_reached
 @classmethod
 def _validate_goal_state(cls, state: GeneralState):
 """
 Checks if state fulfills the requirements for a goal state and raises Error if not.
 :param state: state to check
 """
 if not hasattr(state, 'time_step'):
 raise ValueError('<GoalRegion/_goal_state_is_valid> field time_step is mandatory. '
 'No time_step attribute found.')
 valid_fields = ['time_step', 'position', 'velocity', 'orientation']
 for attr in state.used_attributes:
 if attr not in valid_fields:
 raise ValueError('<GoalRegion/_goal_state_is_valid> field error: allowed fields are '
 '[time_step, position, velocity, orientation]; "%s" detected' % attr)
 elif attr == 'position':
 if not isinstance(getattr(state, attr), Shape):
 raise ValueError(
 '<GoalRegion/_goal_state_is_valid> position needs to be an instance of '
 '%s; got instance of %s instead' % (Shape, getattr(state, attr).__class__))
 elif attr == 'orientation':
 if not isinstance(getattr(state, attr), AngleInterval):
 raise ValueError('<GoalRegion/_goal_state_is_valid> orientation needs to be an instance of %s; got '
 'instance of %s instead' % (AngleInterval, getattr(state, attr).__class__))
 else:
 if not isinstance(getattr(state, attr), Interval):
 raise ValueError('<GoalRegion/_goal_state_is_valid> attributes must be instances of '
 '%s only (except from position and orientation); got "%s" for '
 'attribute "%s"' % (Interval, getattr(state, attr).__class__, attr))
 def _harmonize_state_types(self, state: GeneralState, goal_state: GeneralState, state_fields: Set[str],
 goal_state_fields: Set[str]):
 """
 Transforms states from value_x, value_y to orientation, value representation if required.
 :param state: state to check for goal
 :param goal_state: goal state
 :return:
 """
 state_new = copy.deepcopy(state)
 if {'velocity', 'velocity_y'}.issubset(state_fields) \
 and {'orientation'}.issubset(goal_state_fields) \
 and not {'velocity', 'velocity_y'}.issubset(goal_state_fields):
 if not 'orientation' in state_fields:
 state_new.orientation = math.atan2(state_new.velocity_y, state_new.velocity)
 state_fields.add('orientation')
 state_new.velocity = np.linalg.norm(np.array([state_new.velocity, state_new.velocity_y]))
 state_fields.remove('velocity_y')
 return state_new, state_fields, goal_state, goal_state_fields
</src\commonocean\planning\goal.py>

<src\commonocean\planning\planning_problem.py>
from typing import Union, List, Tuple, Dict
import numpy as np
import warnings
from commonroad.common.validity import is_natural_number
from commonroad.scenario.trajectory import Trajectory
from commonroad.scenario.state import CustomState
from commonocean.planning.goal import GoalRegion
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
class PlanningProblem:
 def __init__(self, planning_problem_id: int, initial_state : CustomState, goal_region: GoalRegion, waypoints: Union[List[GoalRegion], None] = None,
 max_lateral_deviation: Union[float, None] = None):
 """
 Class which describes a PlanningProblem entity according to the CommonOcean specification. Each planning problem is described by
 a initial state and a goal region.
 :param planning_problem_id: int that represents the id of the PP.
 :param initial_state: object of class CustomState that indicates the initial state of the PP.
 :param goal_region: object of class GoalRegion that represents the state that has to be fulfilled to solve the scenario.
 :param waypoints: list of objects of class GoalRegion that represents the waypoints of the PP.
 :param max_lateral_deviaition: float that indicates the maximal lateral deviation possible to solve the PP.
 """
 self.planning_problem_id = planning_problem_id
 self.initial_state = initial_state
 self.goal = goal_region
 self.waypoints = waypoints
 self.max_lateral_deviation = max_lateral_deviation
 @property
 def planning_problem_id(self) -> int:
 """Id of the planning problem"""
 return self._planning_problem_id
 @planning_problem_id.setter
 def planning_problem_id(self, problem_id: int):
 if not hasattr(self, '_planning_problem_id'):
 assert is_natural_number(problem_id), '<PlanningProblem/planning_problem_id>: Argument "problem_id" of ' \
 'wrong type. Expected type: %s. Got type: %s.' \
 % (int, type(problem_id))
 self._planning_problem_id = problem_id
 else:
 warnings.warn('<PlanningProblem/planning_problem_id> planning_problem_id is immutable')
 @property
 def initial_state(self) -> CustomState:
 """Initial state of the ego vehicle"""
 return self._initial_state
 @initial_state.setter
 def initial_state(self, state: CustomState):
 mandatory_fields = ['position', 'velocity', 'orientation', 'time_step']
 for field in mandatory_fields:
 if not hasattr(state, field):
 raise ValueError('<PlanningProblem/initial_state> fields [{}] are mandatory. '
 'No {} attribute found.'.format(', '.join(mandatory_fields), field))
 self._initial_state = state
 @property
 def goal(self) -> GoalRegion:
 """Region that has to be reached"""
 return self._goal_region
 @goal.setter
 def goal(self, goal_region: GoalRegion):
 assert(isinstance(goal_region, GoalRegion)), 'argument "goal_region" of wrong type. Expected type: %s. ' \
 'Got type: %s.' % (GoalRegion, type(goal_region))
 self._goal_region = goal_region
 def goal_reached(self, trajectory: Trajectory) -> Tuple[bool, int]:
 """
 Checks if the goal region defined in the planning problem is reached by any state of a given trajectory
 :param trajectory: trajectory to test
 :return: Tuple: (True, index of first state in trajectory.state_list that reaches goal) if one state reaches
 the goal. (False, -1) if no state reaches the goal.
 """
 for i, state in reversed(list(enumerate(trajectory.state_list))):
 if self.goal.is_reached(state):
 return True, i
 return False, -1
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 translate and rotates the planning problem with given translation and angle around the origin (0, 0)
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 self.initial_state = self.initial_state.translate_rotate(translation, angle)
 self.goal.translate_rotate(translation, angle)
 @property
 def waypoints(self) -> List[GoalRegion]:
 """waypoints of a planning problem"""
 return self._waypoints
 @waypoints.setter
 def waypoints(self, waypoints: List[GoalRegion]):
 if waypoints is not None:
 assert (isinstance(waypoints,
 list)), 'argument "waypoints" of wrong type. Expected type: %s. ' \
 'Got type: %s.' % (list, type(waypoints))
 for w in waypoints:
 assert (isinstance(w,
 GoalRegion)), 'element in list argument "waypoints" of wrong type. Expected type: %s. ' \
 'Got type: %s.' % (GoalRegion, type(w))
 self._waypoints = waypoints
 @property
 def max_lateral_deviation(self) -> float:
 """waypoints of a planning problem"""
 return self._max_lateral_deviation
 @max_lateral_deviation.setter
 def max_lateral_deviation(self, max_lateral_deviation : float):
 if max_lateral_deviation is not None:
 assert (isinstance(max_lateral_deviation,
 float)), 'argument "max_lateral_deviation" of wrong type. Expected type: %s. ' \
 'Got type: %s.' % (float, type(max_lateral_deviation))
 self._max_lateral_deviation = max_lateral_deviation
 def generate_reference_points_from_waypoint(self):
 """
 returns the centers of the waypoint goals as list
 """
 reference_points = []
 for w in self.waypoints:
 reference_points.append(w.state_list[0].position.center)
 return reference_points
class PlanningProblemSet:
 def __init__(self, planning_problem_list: Union[None, List[PlanningProblem]]=None):
 """
 Class which describes a PlanningProblemSet entity according to the CommonOcean specification. Each planning problem inside this set
 is described by a initial state and a goal region.
 :param planning_problem_list: list of planning problems that compose the set.
 """
 if planning_problem_list is None:
 planning_problem_list = []
 self._valid_planning_problem_list(planning_problem_list)
 self._planning_problem_dict = {planning_problem.planning_problem_id: planning_problem for planning_problem in
 planning_problem_list}
 @property
 def planning_problem_dict(self) -> Dict[int, PlanningProblem]:
 """Dict that contains all PlanningProblems that are added. Keys: Ids of planning problems"""
 return self._planning_problem_dict
 @planning_problem_dict.setter
 def planning_problem_dict(self, _dict):
 warnings.warn('<PlanningProblemSet/planning_problem_dict> planning_problem_dict is immutable')
 @staticmethod
 def _valid_planning_problem_list(planning_problem_list: List[PlanningProblem]):
 """
 Check if input list contains only PlanningProblem instances
 :param planning_problem_list: List[PlanningProblem]
 """
 assert isinstance(planning_problem_list, list), 'argument "planning_problem_list" of wrong type. ' \
 'Expected type: %s. Got type: %s.' \
 % (list, type(planning_problem_list))
 assert all(isinstance(p, PlanningProblem) for p in planning_problem_list), 'Elements of ' \
 '"planning_problem_list" of wrong ' \
 'type.'
 def add_planning_problem(self, planning_problem: PlanningProblem):
 """
 Adds the given planning problem to self.planning_problem_list
 :param planning_problem: Planning problem to add
 """
 assert isinstance(planning_problem, PlanningProblem), 'argument "planning_problem" of wrong type. ' \
 'Expected type: %s. Got type: %s.' \
 % (planning_problem, PlanningProblem)
 if planning_problem.planning_problem_id in self.planning_problem_dict.keys():
 raise ValueError(
 "Id {} is already used in PlanningProblemSet".format(planning_problem.planning_problem_id))
 self.planning_problem_dict[planning_problem.planning_problem_id] = planning_problem
 def find_planning_problem_by_id(self, planning_problem_id: int) -> PlanningProblem:
 """
 Searches in planning_problem_dict for a planning problem with the given id. Returns the planning problem or
 raises error, if id cannot be found.
 :param planning_problem_id: id to find
 :return: Planning problem with id planning_problem_id, Raises key error, if id not in the dict.
 """
 return self.planning_problem_dict[planning_problem_id]
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 translate and rotates the planning problem set with given translation and angle around the origin (0, 0)
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 for planning_problem in self._planning_problem_dict.values():
 planning_problem.translate_rotate(translation, angle)
</src\commonocean\planning\planning_problem.py>

<src\commonocean\prediction\prediction.py>
__author__ = "Bruno Maione"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2023a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "development"
import math
from typing import Union, List, Dict, Set
import numpy as np
from commonroad.common.util import Interval
from commonroad.common.validity import is_valid_orientation, is_real_number_vector
from commonroad.geometry.shape import Shape, \
 occupancy_shape_from_state
from commonocean.scenario.trajectory import Trajectory
from commonroad.prediction.prediction import Occupancy as Occupancy_CR
from commonroad.prediction.prediction import Prediction as Prediction_CR
class Occupancy(Occupancy_CR):
 """ Class describing an occupied area in the position domain. The
 occupied area can be defined for a certain time
 step or a time interval."""
 def __init__(self, time_step: Union[int, Interval], shape: Shape):
 """
 :param time_step: a time interval or time step for which the
 occupancy is defined
 :param shape: occupied region in the position domain
 """
 super().__init__(time_step, shape)
class Prediction(Prediction_CR):
 """
 Base class for a prediction module.
 """
 def __init__(self, initial_time_step: int, occupancy_set: List[Occupancy]):
 """
 :param initial_time_step: initial time step of the prediction
 :param occupancy_set: list of occupancies defined for different time steps or time intervals.
 """
 super().__init__(initial_time_step, occupancy_set)
class SetBasedPrediction(Prediction):
 """ Class to represent the future behavior of obstacles by bounded occupancy sets."""
 def __init__(self, initial_time_step: int, occupancy_set: List[Occupancy]):
 """
 :param initial_time_step: initial time step of the set-based prediction
 :param occupancy_set: list of occupancies defined for different time steps or time intervals.
 """
 Prediction.__init__(self, initial_time_step, occupancy_set)
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """ Translates and rotates the occupancy set.
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 assert is_real_number_vector(translation, 2), '<SetBasedPrediction/translate_rotate>: argument "translation" ' \
 'is not a vector of real numbers of length 2.'
 assert is_valid_orientation(angle), '<SetBasedPrediction/translate_rotate>: argument "orientation" ' \
 'is not valid.'
 for occ in self._occupancy_set:
 occ.translate_rotate(translation, angle)
class TrajectoryPrediction(Prediction):
 """ Class to represent the predicted movement of an obstacle using a trajectory. A trajectory is modeled as a
 state sequence over time. The occupancy of an obstacle along a trajectory is uniquely defined given its shape."""
 def __init__(self, trajectory: Trajectory, shape: Shape,
 center_waters_assignment: Union[None, Dict[int, Set[int]]] = None,
 shape_waters_assignment: Union[None, Dict[int, Set[int]]] = None):
 """
 :param trajectory: predicted trajectory of the obstacle
 :param shape: shape of the obstacle
 """
 self.shape: Shape = shape
 self.trajectory: Trajectory = trajectory
 self.shape_waters_assignment: Dict[int, Set[int]] = shape_waters_assignment
 self.center_waters_assignment: Dict[int, Set[int]] = center_waters_assignment
 Prediction.__init__(self, self._trajectory.initial_time_step, self._create_occupancy_set())
 @property
 def shape(self) -> Shape:
 """ Shape of the predicted object."""
 return self._shape
 @shape.setter
 def shape(self, shape: Shape):
 assert isinstance(shape, Shape), '<TrajectoryPrediction/shape>: argument "shape" of wrong type. Expected ' \
 'type: %s. Got type: %s.' % (Shape, type(shape))
 self._shape = shape
 @property
 def trajectory(self) -> Trajectory:
 """ Predicted trajectory of the object."""
 return self._trajectory
 @trajectory.setter
 def trajectory(self, trajectory: Trajectory):
 assert isinstance(trajectory, Trajectory), '<TrajectoryPrediction/trajectory>: argument "trajectory" of wrong' \
 ' type. Expected type: %s. Got type: %s.' \
 % (Trajectory, type(trajectory))
 self._trajectory = trajectory
 @property
 def shape_waters_assignment(self) -> Union[None, Dict[int, Set[int]]]:
 """ Predicted waters assignment of obstacle shape."""
 return self._shape_waters_assignment
 @shape_waters_assignment.setter
 def shape_waters_assignment(self, shape_waters_assignment: Union[None, Dict[int, Set[int]]]):
 if shape_waters_assignment is not None:
 assert isinstance(shape_waters_assignment, dict), '<TrajectoryPrediction/shape_waters_assignment>: ' \
 'argument "shape_waters_assignment" of wrong type. ' \
 'Expected type: %s. Got' \
 ' type: %s.' % (Dict, type(shape_waters_assignment))
 self._shape_waters_assignment = shape_waters_assignment
 @property
 def center_waters_assignment(self) -> Union[None, Dict[int, Set[int]]]:
 """ Predicted waters assignment of obstacle center."""
 return self._center_waters_assignment
 @center_waters_assignment.setter
 def center_waters_assignment(self, center_waters_assignment: Union[None, Dict[int, Set[int]]]):
 if center_waters_assignment is not None:
 assert isinstance(center_waters_assignment, dict), '<TrajectoryPrediction/center_waters_assignment>: ' \
 'argument "center_waters_assignment" of wrong type. ' \
 'Expected type: ' \
 '%s. Got type: %s.' % (Dict, type(center_waters_assignment))
 self._center_waters_assignment = center_waters_assignment
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """ Translates and rotates all states of the trajectory and re-computes the translated and rotated occupancy
 set.
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 assert is_real_number_vector(translation, 2), '<TrajectoryPrediction/translate_rotate>: argument ' \
 '"translation" is not a vector of real numbers of length 2.'
 assert is_valid_orientation(angle), '<TrajectoryPrediction/translate_rotate>: argument "orientation" is ' \
 'not valid.'
 self._trajectory.translate_rotate(translation, angle)
 self._occupancy_set = self._create_occupancy_set()
 def _create_occupancy_set(self):
 """ Computes the occupancy set over time given the predicted trajectory and shape of the object."""
 occupancy_set = list()
 for k, state in enumerate(self._trajectory.state_list):
 if not hasattr(state, "orientation"):
 state.orientation = math.atan2(state.velocity_y, state.velocity)
 occupied_region = occupancy_shape_from_state(self._shape, state)
 occupancy_set.append(Occupancy(state.time_step, occupied_region))
 return occupancy_set
</src\commonocean\prediction\prediction.py>

<src\commonocean\scenario\obstacle.py>
import enum
import warnings
from typing import Union, Set
from abc import ABC, abstractmethod
import numpy as np
from commonroad.geometry.shape import Shape, Rectangle, Circle, Polygon
from commonocean.prediction.prediction import Prediction, Occupancy, SetBasedPrediction, TrajectoryPrediction
from commonocean.scenario.state import GeneralState
from commonroad.common.validity import is_valid_orientation, is_real_number_vector, is_real_number
__author__ = "Hanna Krasowski"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
@enum.unique
class ObstacleRole(enum.Enum):
 """ Enum containing all possible obstacle roles defined in CommonOcean."""
 STATIC = "static"
 DYNAMIC = "dynamic"
@enum.unique
class ObstacleType(enum.Enum):
 """ Enum containing all possible obstacle types defined in CommonOcean."""
 UNKNOWN = "unknown"
 BUOY = "buoy"
 LAND = "land"
 MOTORVESSEL = "motorvessel"
 SAILINGVESSEL = "sailingvessel"
 FISHINGVESSEL = "fishingvessel"
 MILITARYVESSEL = "militaryvessel"
 CARGOSHIP = "cargoship"
 VESSELNOTUNDERCOMMAND = "vesselNotUnderCommand"
 RESTRICTEDMANEUVERABILITYVESSEL = "restrictedManeuverabilityVessel"
 ANCHOREDVESSEL = "anchoredvessel"
 WINDFARM = "windfarm"
 OILRIG = "oilrig"
 WATERSBOUNDARY = "watersboundary"
class Obstacle(ABC):
 """ Superclass for dynamic and static obstacles holding common properties defined in CommonOcean."""
 def __init__(self, obstacle_id: int, obstacle_role: ObstacleRole,
 obstacle_type: ObstacleType, obstacle_shape: Shape, initial_state: GeneralState, depth: float = None):
 """
 :param obstacle_id: unique ID of the obstacle
 :param obstacle_role: obstacle role as defined in CommonOcean
 :param obstacle_type: obstacle type as defined in CommonOcean (e.g. ANCHOREDVESSEL)
 :param obstacle_shape: occupied area of the obstacle
 :param initial_state: initial state of the obstacle
 """
 self._initial_occupancy_shape: Shape = None
 self.obstacle_id: int = obstacle_id
 self.obstacle_role: ObstacleRole = obstacle_role
 self.obstacle_type: ObstacleType = obstacle_type
 self.obstacle_shape: Shape = obstacle_shape
 self.initial_state: GeneralState = initial_state
 if depth != None:
 self._depth = depth
 else:
 list_depth_inf = [ObstacleType.LAND, ObstacleType.BUOY, ObstacleType.UNKNOWN, ObstacleType.WINDFARM, ObstacleType.OILRIG]
 if isinstance(obstacle_shape, Rectangle):
 size = max(obstacle_shape.length, obstacle_shape.width)
 elif isinstance(obstacle_shape, Circle):
 size = 2*obstacle_shape.radius
 elif isinstance(obstacle_shape, Polygon):
 size = 0.0
 for vert1 in obstacle_shape.vertices:
 for vert2 in obstacle_shape.vertices:
 dist = np.linalg.norm(vert1-vert2)
 if dist > size:
 size = dist
 else:
 size = 0.0
 if obstacle_type not in list_depth_inf and size < 25:
 depth = 5.0
 elif obstacle_type not in list_depth_inf and size >= 25:
 depth = 15.0
 elif obstacle_type in list_depth_inf:
 depth = np.inf
 self._depth = depth
 def __hash__(self):
 return hash((self._obstacle_id, self._obstacle_role, self._obstacle_type, self._obstacle_shape,
 self._initial_state))
 @property
 def obstacle_id(self) -> int:
 """ Unique ID of the obstacle."""
 return self._obstacle_id
 @property
 def obstacle_id(self) -> int:
 """ Unique ID of the obstacle."""
 return self._obstacle_id
 @obstacle_id.setter
 def obstacle_id(self, obstacle_id: int):
 assert isinstance(obstacle_id, int), '<Obstacle/obstacle_id>: argument obstacle_id of wrong type.' \
 'Expected type: %s. Got type: %s.' % (int, type(obstacle_id))
 if not hasattr(self, '_obstacle_id'):
 self._obstacle_id = obstacle_id
 else:
 warnings.warn('<Obstacle/obstacle_id>: Obstacle ID is immutable.')
 @property
 def obstacle_role(self) -> ObstacleRole:
 """ Obstacle role as defined in CommonOcean."""
 return self._obstacle_role
 @obstacle_role.setter
 def obstacle_role(self, obstacle_role: ObstacleRole):
 assert isinstance(obstacle_role, ObstacleRole), '<Obstacle/obstacle_role>: argument obstacle_role of wrong ' \
 'type. Expected type: %s. Got type: %s.' \
 % (ObstacleRole, type(obstacle_role))
 if not hasattr(self, '_obstacle_role'):
 self._obstacle_role = obstacle_role
 else:
 warnings.warn('<Obstacle/obstacle_role>: Obstacle role is immutable.')
 @property
 def obstacle_type(self) -> ObstacleType:
 """ Obstacle type as defined in CommonOcean."""
 return self._obstacle_type
 @obstacle_type.setter
 def obstacle_type(self, obstacle_type: ObstacleType):
 assert isinstance(obstacle_type, ObstacleType), '<Obstacle/obstacle_type>: argument obstacle_type of wrong ' \
 'type. Expected type: %s. Got type: %s.' \
 % (ObstacleType, type(obstacle_type))
 if not hasattr(self, '_obstacle_type'):
 self._obstacle_type = obstacle_type
 else:
 warnings.warn('<Obstacle/obstacle_type>: Obstacle type is immutable.')
 @property
 def obstacle_shape(self) -> Shape:
 """ Obstacle shape as defined in CommonOcean."""
 return self._obstacle_shape
 @obstacle_shape.setter
 def obstacle_shape(self, shape: Shape):
 assert isinstance(shape,
 (type(None), Shape)), '<Obstacle/obstacle_shape>: argument shape of wrong type. Expected ' \
 'type %s. Got type %s.' % (Shape, type(shape))
 if not hasattr(self, '_obstacle_shape'):
 self._obstacle_shape = shape
 else:
 warnings.warn('<Obstacle/obstacle_shape>: Obstacle shape is immutable.')
 @property
 def initial_state(self) -> GeneralState:
 """ Initial state of the obstacle, e.g., obtained through sensor measurements."""
 return self._initial_state
 @initial_state.setter
 def initial_state(self, initial_state: GeneralState):
 assert isinstance(initial_state, GeneralState), '<Obstacle/initial_state>: argument initial_state of wrong type. ' \
 'Expected types: %s. Got type: %s.' % (GeneralState, type(initial_state))
 self._initial_state = initial_state
 self._initial_occupancy_shape = self._obstacle_shape.rotate_translate_local(
 initial_state.position, initial_state.orientation)
 @property
 def depth(self):
 return self._depth
 @depth.setter
 def depth(self, depth: float):
 assert isinstance(depth, float), \
 '<Obstacle/depth>: argument depth of wrong ' \
 'type. Expected type: %s. Got type: %s.' \
 % (float, type(depth))
 assert depth >= 0, '<Obstacle/depth>: argument depth is a negative number. ' \
 'Expected type is a positive number. Got: %s.' \
 % (float, type(depth))
 self._depth = depth
 @property
 def initial_center_waters_ids(self) -> Union[None, Set[int]]:
 """ Initial waters of obstacle center, e.g., obtained through localization."""
 return self._initial_center_waters_ids
 @initial_center_waters_ids.setter
 def initial_center_waters_ids(self, initial_center_waters_ids: Union[None, Set[int]]):
 assert isinstance(initial_center_waters_ids, (set, type(None))), \
 '<Obstacle/initial_center_waters_ids>: argument initial_waters_ids of wrong type. ' \
 'Expected types: %s, %s. Got type: %s.' % (set, type(None), type(initial_center_waters_ids))
 if initial_center_waters_ids is not None:
 for waters_id in initial_center_waters_ids:
 assert isinstance(waters_id, int), \
 '<Obstacle/initial_center_waters_ids>: argument initial_waters of wrong type. ' \
 'Expected types: %s. Got type: %s.' % (int, type(waters_id))
 self._initial_center_waters_ids = initial_center_waters_ids
 @property
 def initial_shape_waters_ids(self) -> Union[None, Set[int]]:
 """ Initial waters of obstacle shape, e.g., obtained through localization."""
 return self._initial_shape_waters_ids
 @initial_shape_waters_ids.setter
 def initial_shape_waters_ids(self, initial_shape_waters_ids: Union[None, Set[int]]):
 assert isinstance(initial_shape_waters_ids, (set, type(None))), \
 '<Obstacle/initial_shape_waters_ids>: argument initial_waters_ids of wrong type. ' \
 'Expected types: %s, %s. Got type: %s.' % (set, type(None), type(initial_shape_waters_ids))
 if initial_shape_waters_ids is not None:
 for waters_id in initial_shape_waters_ids:
 assert isinstance(waters_id, int), \
 '<Obstacle/initial_shape_waters_ids>: argument initial_waters of wrong type. ' \
 'Expected types: %s. Got type: %s.' % (int, type(waters_id))
 self._initial_shape_waters_ids = initial_shape_waters_ids
 @abstractmethod
 def occupancy_at_time(self, time_step: int) -> Union[None, Occupancy]:
 pass
 @abstractmethod
 def translate_rotate(self, translation: np.ndarray, angle: float):
 pass
class StaticObstacle(Obstacle):
 """ Class representing static obstacles as defined in CommonOcean."""
 def __init__(self, obstacle_id: int, obstacle_type: ObstacleType,
 obstacle_shape: Shape, initial_state: GeneralState, depth: float = None):
 """
 :param obstacle_id: unique ID of the obstacle
 :param obstacle_type: type of obstacle (e.g. ANCHOREDVESSEL)
 :param obstacle_shape: shape of the static obstacle
 :param initial_state: initial state of the static obstacle
 """
 Obstacle.__init__(self, obstacle_id=obstacle_id, obstacle_role=ObstacleRole.STATIC,
 obstacle_type=obstacle_type, obstacle_shape=obstacle_shape, initial_state=initial_state, depth=depth)
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """ First translates the static obstacle, then rotates the static obstacle around the origin.
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 assert is_real_number_vector(translation, 2), '<StaticObstacle/translate_rotate>: argument translation is ' \
 'not a vector of real numbers of length 2.'
 assert is_real_number(angle), '<StaticObstacle/translate_rotate>: argument angle must be a scalar. ' \
 'angle = %s' % angle
 assert is_valid_orientation(angle), '<StaticObstacle/translate_rotate>: argument angle must be within the ' \
 'interval [-2pi, 2pi]. angle = %s' % angle
 self.initial_state = self._initial_state.translate_rotate(translation, angle)
 def occupancy_at_time(self, time_step: int) -> Occupancy:
 """
 Returns the predicted occupancy of the obstacle at a specific time step.
 :param time_step: discrete time step
 :return: occupancy of the static obstacle at time step
 """
 return Occupancy(time_step=time_step, shape=self._initial_occupancy_shape)
 def state_at_time(self, time_step: int) -> GeneralState:
 """
 Returns the state the obstacle at a specific time step.
 :param time_step: discrete time step
 :return: state of the static obstacle at time step
 """
 return self.initial_state
 def __str__(self):
 obs_str = 'Static Obstacle:\n'
 obs_str += '\nid: {}'.format(self.obstacle_id)
 obs_str += '\ninitial state: {}'.format(self.initial_state)
 return obs_str
class DynamicObstacle(Obstacle):
 """ Class representing dynamic obstacles as defined in CommonOcean. Each dynamic obstacle has stored its predicted
 movement in future time steps.
 """
 def __init__(self, obstacle_id: int, obstacle_type: ObstacleType,
 obstacle_shape: Shape, initial_state: GeneralState,
 prediction: Union[None, Prediction, TrajectoryPrediction, SetBasedPrediction] = None, depth: float = None):
 """
 :param obstacle_id: unique ID of the obstacle
 :param obstacle_type: type of obstacle (e.g. PARKED_VEHICLE)
 :param obstacle_shape: shape of the static obstacle
 :param initial_state: initial state of the static obstacle
 :param prediction: predicted movement of the dynamic obstacle
 """
 Obstacle.__init__(self, obstacle_id=obstacle_id, obstacle_role=ObstacleRole.DYNAMIC,
 obstacle_type=obstacle_type, obstacle_shape=obstacle_shape, initial_state=initial_state, depth = depth)
 self.prediction: Prediction = prediction
 @property
 def prediction(self) -> Union[Prediction, TrajectoryPrediction, SetBasedPrediction, None]:
 """ Prediction describing the movement of the dynamic obstacle over time."""
 return self._prediction
 @prediction.setter
 def prediction(self, prediction: Union[Prediction, TrajectoryPrediction, SetBasedPrediction, None]):
 assert isinstance(prediction, (Prediction, type(None))), '<DynamicObstacle/prediction>: argument prediction ' \
 'of wrong type. Expected types: %s, %s. Got type: ' \
 '%s.' % (Prediction, type(None), type(prediction))
 self._prediction = prediction
 def occupancy_at_time(self, time_step: int) -> Union[None, Occupancy]:
 """
 Returns the predicted occupancy of the obstacle at a specific time step.
 :param time_step: discrete time step
 :return: predicted occupancy of the obstacle at time step
 """
 occupancy = None
 if time_step == self.initial_state.time_step:
 occupancy = Occupancy(time_step, self._initial_occupancy_shape)
 elif time_step > self.initial_state.time_step and self._prediction is not None:
 occupancy = self._prediction.occupancy_at_time_step(time_step)
 return occupancy
 def state_at_time(self, time_step: int) -> Union[None, GeneralState]:
 """
 Returns the predicted state of the obstacle at a specific time step.
 :param time_step: discrete time step
 :return: predicted state of the obstacle at time step
 """
 if time_step == self.initial_state.time_step:
 return self.initial_state
 elif type(self._prediction) is SetBasedPrediction:
 warnings.warn("<DynamicObstacle/state_at_time>: Set-based prediction is used. CustomState cannot be returned!")
 return None
 elif time_step > self.initial_state.time_step and self._prediction is not None:
 return self.prediction.trajectory.state_at_time_step(time_step)
 else:
 return None
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """ First translates the dynamic obstacle, then rotates the dynamic obstacle around the origin.
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 assert is_real_number_vector(translation, 2), '<DynamicObstacle/translate_rotate>: argument translation is ' \
 'not a vector of real numbers of length 2.'
 assert is_real_number(angle), '<DynamicObstacle/translate_rotate>: argument angle must be a scalar. ' \
 'angle = %s' % angle
 assert is_valid_orientation(angle), '<DynamicObstacle/translate_rotate>: argument angle must be within the ' \
 'interval [-2pi, 2pi]. angle = %s' % angle
 if self._prediction is not None:
 self.prediction.translate_rotate(translation, angle)
 self.initial_state = self._initial_state.translate_rotate(translation, angle)
 def extreme_limits(self):
 """ Calculate the extreme limits that the obstacle reaches during the movement.
 """
 flag = True
 for occupancy in self.prediction.occupancy_set:
 if not flag:
 x = occupancy.shape.center[0]
 y = occupancy.shape.center[1]
 if x > max_x:
 max_x = x
 if x < min_x:
 min_x = x
 if y > max_y:
 max_y = y
 if y < min_y:
 min_y = y
 else:
 max_x = occupancy.shape.center[0]
 max_y = occupancy.shape.center[1]
 min_x = max_x
 min_y = max_y
 flag = False
 return [[max_x, min_x], [max_y, min_y]]
 def __str__(self):
 obs_str = 'Dynamic Obstacle:\n'
 obs_str += '\nid: {}'.format(self.obstacle_id)
 obs_str += '\ninitial state: {}'.format(self.initial_state)
 return obs_str
</src\commonocean\scenario\obstacle.py>

<src\commonocean\scenario\scenario.py>
import itertools
import re
import iso3166
from collections import defaultdict
from commonroad.common.util import Interval
from commonocean.prediction.prediction import Occupancy, TrajectoryPrediction, SetBasedPrediction
from commonocean import SCENARIO_VERSION, SUPPORTED_COMMONOCEAN_VERSIONS
from commonocean.scenario.obstacle import StaticObstacle, DynamicObstacle, ObstacleRole, ObstacleType
from commonocean.scenario.state import GeneralState
from commonocean.scenario.waters import *
# Tunneling from CR-IO #
from commonroad.scenario.scenario import GeoTransformation as GeoTransformation_CR
########################
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
@enum.unique
class Tag(enum.Enum):
 """ Enum containing all possible tags of a CommonOcean scenario."""
 OPENSEA = "open_sea"
 TRAFFICSIGN = "traffic_sign"
 NARROWWATERS = "narrow_waters"
 TRAFFICSEPERATIONZONE = "traffic_separation_zone"
 HARBOUR = "harbour"
 COMFORT = "comfort"
 CRITICAL = "critical"
 EVASIVE = "evasive"
 SPEED_LIMIT = "speed_limit"
@enum.unique
class TimeOfDay(enum.Enum):
 """ Enum containing all possible time of days."""
 DAY = "day"
 NIGHT = "night"
 UNKNOWN = "unknown"
@enum.unique
class Weather(enum.Enum):
 """ Enum containing all possible weathers."""
 SUNNY = "sunny"
 LIGHT_RAIN = "light_rain"
 HEAVY_RAIN = "heavy_rain"
 FOG = "fog"
 SNOW = "snow"
 HAIL = "hail"
 UNKNOWN = "unknown"
@enum.unique
class SeaState(enum.Enum):
 """ Enum containing all possible states."""
 CALM = "calm"
 ROUGH = "rough"
 UNKNOWN = "unknown"
class Time:
 """
 Class which describes the fictive time when a scenario starts.
 """
 def __init__(self, year: int, month: int, day: int, hours: int, minutes: int):
 """
 Constructor of a time object
 :param year: year of scenario e.g. 2022
 :param month: month of scenario (1-12)
 :param day: day of scenario (1-31)
 :param hours: hours at start of scenario (0-24)
 :param minutes: minutes at start of scenario (0-60)
 """
 self._year = year
 self._month = month
 self._day = day
 self._hours = hours
 self._minutes = minutes
 def __eq__(self, other):
 if not isinstance(other, Time):
 return False
 return self._hours == other.hours and self._minutes == other.minutes and self._year == other._year \
 and self._day == other._day and self._month == other._month
 def __hash__(self):
 return hash((self._hours, self._minutes))
 @property
 def year(self) -> int:
 return self._year
 @property
 def month(self) -> int:
 return self._month
 @property
 def day(self) -> int:
 return self._day
 @property
 def year(self) -> int:
 return self._year
 @property
 def month(self) -> int:
 return self._month
 @property
 def day(self) -> int:
 return self._day
 @property
 def hours(self) -> int:
 return self._hours
 @property
 def minutes(self) -> int:
 return self._minutes
class GeoTransformation(GeoTransformation_CR):
 """
 Class which describes the transformation from geodetic to projected Cartesian coordinates according to the
 CommonOcean specification
 """
 def __init__(self, geo_reference: str = None, x_translation: float = None, y_translation: float = None,
 z_rotation: float = None, scaling: float = None):
 """
 Constructor of a location object
 :param geo_reference: proj-string describing transformation from geodetic to projected Cartesian coordinates
 :param x_translation: translation value for x-coordinates
 :param y_translation: translation value for y-coordinates
 :param z_rotation: rotation value around origin
 :param scaling: multiplication value of x- and y-coordinates
 """
 super().__init__(geo_reference, x_translation, y_translation, z_rotation, scaling)
class Environment:
 """
 Class which describes the environment where a scenario takes place as specified in the CommonOcean specification.
 """
 def __init__(self, time: Time = None, time_of_day: TimeOfDay = None, weather: Weather = None,
 seastate: SeaState = None):
 """
 Constructor of an environment object
 :param time: time in day, hours and minutes
 :param time_of_day: current time of day, i.e., day or night
 :param weather: weather information, e.g., sunny
 :param seastate: seastate information, e.g., calm
 """
 self._time = time
 self._time_of_day = time_of_day
 self._weather = weather
 self._seastate = seastate
 def __eq__(self, other):
 if not isinstance(other, Environment):
 return False
 return self._time == other.time and self._time_of_day == other.time_of_day and \
 self._weather == other.weather and self._seastate == other.seastate
 def __hash__(self):
 return hash((self._time, self._time_of_day, self._weather, self._seastate))
 @property
 def time(self) -> Time:
 return self._time
 @property
 def time_of_day(self) -> TimeOfDay:
 return self._time_of_day
 @property
 def weather(self) -> Weather:
 return self._weather
 @property
 def seastate(self) -> SeaState:
 return self._seastate
class Location:
 """
 Class which describes a location according to the CommonOcean specification.
 """
 def __init__(self, geo_name_id: int = -999, gps_latitude: float = 999, gps_longitude: float = 999,
 geo_transformation: GeoTransformation = None, environment: Environment = None):
 """
 Constructor of a location object
 :param geo_name_id: GeoName ID
 :param gps_latitude: GPS latitude coordinate
 :param gps_longitude: GPS longitude coordinate
 :param geo_transformation: description of geometric transformation during scenario generation
 :param environment: environmental information, e.g. weather
 """
 self._geo_name_id = geo_name_id
 self._gps_latitude = gps_latitude
 self._gps_longitude = gps_longitude
 self._geo_transformation = geo_transformation
 self._environment = environment
 def __eq__(self, other):
 if not isinstance(other, Location):
 return False
 return self._geo_name_id == other.geo_name_id and self._gps_latitude == other.gps_latitude and \
 self._gps_longitude == other.gps_longitude and self._geo_transformation == other.geo_transformation and \
 self._environment == other.environment
 def __hash__(self):
 return hash((self._geo_name_id, self._gps_latitude, self._gps_longitude, self._geo_transformation,
 self._environment))
 @property
 def geo_name_id(self) -> int:
 return self._geo_name_id
 @property
 def gps_latitude(self) -> float:
 return self._gps_latitude
 @property
 def gps_longitude(self) -> float:
 return self._gps_longitude
 @property
 def geo_transformation(self) -> GeoTransformation:
 return self._geo_transformation
 @property
 def environment(self) -> Environment:
 return self._environment
class ScenarioID:
 def __init__(self, cooperative: bool = False, country_id: str = "ZAM", map_name: str = "Test", map_id: int = 1,
 configuration_id: Union[None, int] = None, prediction_type: Union[None, str] = None,
 prediction_id: Union[None, int] = None, scenario_version: str = SCENARIO_VERSION):
 """
 Implements the scenario ID as specified in the scenario documentation.
 Example for benchmark ID C-USA_US101-33_2_T-1
 :param cooperative: True if scenario contains cooperative planning problem sets with multiple planning problems
 :param country_id: three-letter ID according
 :param map_name: name of the map (e.g. US101)
 :param map_id: index of the map (e.g. 33)
 :param configuration_id: enumerates initial configuration of vehicles on the map (e.g. 2)
 :param prediction_type: type of the prediction for surrounding vehicles (e.g. T)
 :param prediction_id: enumerates different predictions for the same initial configuration (e.g. 1)
 :param scenario_version: scenario version identifier (e.g. 2020a)
 """
 assert scenario_version in SUPPORTED_COMMONOCEAN_VERSIONS, 'Scenario_version {} not supported.' \
 .format(scenario_version)
 self.scenario_version = scenario_version
 self.cooperative = cooperative
 self._country_id = None
 self.country_id = country_id
 self.map_name = map_name
 self.map_id = map_id
 self.configuration_id = configuration_id
 self.prediction_type = prediction_type
 self.prediction_id = prediction_id
 def __str__(self):
 scenario_id = ""
 if self.cooperative is True:
 scenario_id += "C-"
 if self.country_id is not None:
 scenario_id += self.country_id + "_"
 if self.map_name is not None:
 scenario_id += self.map_name + "-"
 if self.map_id is not None:
 scenario_id += str(self.map_id)
 if self.configuration_id is not None:
 scenario_id += "_" + str(self.configuration_id)
 if self.prediction_type is not None:
 scenario_id += "_" + self.prediction_type + "-"
 if self.prediction_id is not None:
 if type(self.prediction_id) == list:
 scenario_id += "-".join([str(i) for i in self.prediction_id])
 else:
 scenario_id += str(self.prediction_id)
 return scenario_id
 @property
 def country_id(self):
 return self._country_id
 @country_id.setter
 def country_id(self, country_id: str):
 if country_id is None:
 self._country_id = 'ZAM'
 elif country_id in iso3166.countries_by_alpha3 or country_id == 'ZAM':
 self._country_id = country_id
 else:
 raise ValueError('Country ID {} is not in the ISO-3166 three-letter format. '.format(country_id))
 @property
 def country_name(self):
 if self.country_id == "ZAM":
 return "Zamunda"
 else:
 return iso3166.countries_by_alpha3[self.country_id].name
 @classmethod
 def from_benchmark_id(cls, benchmark_id: str, scenario_version: str):
 """
 Create ScenarioID from benchmark_id and scenario_version in the XML header.
 :param benchmark_id: scenario ID provided as a string
 :param scenario_version: scenario format version (e.g. 2020a)
 :return:
 """
 if not (benchmark_id.count('_') in (1, 2, 3) and benchmark_id.count('-') in (1, 2, 3, 4)):
 warnings.warn('Not a valid scenario id: ' + benchmark_id)
 return ScenarioID(None, None, benchmark_id, 0, None, None, None)
 if benchmark_id[0:2] == 'C-':
 cooperative = True
 benchmark_id = benchmark_id[2:]
 else:
 cooperative = False
 sub_ids = re.split('_|-', benchmark_id)
 country_id, map_name, map_id = sub_ids[:3]
 map_id = int(map_id)
 configuration_id = prediction_type = prediction_id = None
 if len(sub_ids) > 3:
 configuration_id = int(sub_ids[3])
 if len(sub_ids) > 4:
 assert sub_ids[4] in ('S', 'T', 'I'), "prediction type must be one of (S, T, I) but is {}".format(
 sub_ids[4])
 prediction_type = sub_ids[4]
 if len(sub_ids) == 6:
 prediction_id = int(sub_ids[5])
 else:
 prediction_id = [int(s) for s in sub_ids[5:]]
 return ScenarioID(cooperative, country_id, map_name, map_id, configuration_id, prediction_type, prediction_id,
 scenario_version)
 def __eq__(self, other: 'ScenarioID'):
 return str(self) == str(other) and self.scenario_version == other.scenario_version
class Scenario:
 """ Class which describes a Scenario entity according to the CommonOcean specification. Each scenario is described by
 a ocean network consisting of waters (see :class:`commonocean.scenario.water.WatersNetwork`) and a set of
 obstacles which can be either static or dynamic (see :class:`commonocean.scenario.obstacle.Obstacle`)."""
 def __init__(self, dt: float, scenario_id: Union[str, ScenarioID],
 author: str = None, tags: Set[Tag] = None, affiliation: str = None, source: str = None,
 location: Location = None, benchmark_id: str = None):
 """
 Constructor of a Scenario object
 :param dt: global time step size of the time-discrete scenario
 :param benchmark_id: unique CommonOcean benchmark ID of the scenario
 :param author: authors of the CommonOcean scenario
 :param tags: tags describing and classifying the scenario
 :param affiliation: institution of the authors
 :param source: source of the scenario, e.g. generated by a map converter and a traffic simulator
 :param location: location object of the scenario
 :param benchmark_id: for backwards compatibility
 """
 self.dt: float = dt
 self.scenario_id = scenario_id
 if isinstance(scenario_id, str):
 self.scenario_id = ScenarioID.from_benchmark_id(scenario_id, SCENARIO_VERSION)
 elif scenario_id is None and benchmark_id is not None:
 warnings.warn('Use the the class commonocean.scenario.ScenarioID to define the scenario id.',
 DeprecationWarning)
 self.scenario_id = ScenarioID.from_benchmark_id(benchmark_id,
 SCENARIO_VERSION)
 self._waters_network: WatersNetwork = WatersNetwork(np.array([0,0]),0,0,0)
 self._static_obstacles: Dict[int, StaticObstacle] = defaultdict()
 self._dynamic_obstacles: Dict[int, DynamicObstacle] = defaultdict()
 self._id_set: Set[int] = set()
 # count ids generated but not necessarily added yet
 self._id_counter = None
 # meta data
 self.author = author
 self.tags = tags
 self.affiliation = affiliation
 self.source = source
 self.location = location
 @property
 def dt(self) -> float:
 """ Global time step size of the time-discrete scenario."""
 return self._dt
 @dt.setter
 def dt(self, dt: float):
 assert is_real_number(dt), '<Scenario/dt> argument "dt" of wrong type. ' \
 'Expected a real number. Got type: %s.' % type(dt)
 self._dt = dt
 @property
 def benchmark_id(self) -> str:
 """ Unique benchmark ID of a scenario as specified in the CommonOcean XML-file."""
 warnings.warn('benchmark_id is deprecated, use scenario_id instead', DeprecationWarning)
 return str(self.scenario_id)
 @benchmark_id.setter
 def benchmark_id(self, benchmark_id):
 raise ValueError('benchmark_id is deprecated, use scenario_id instead')
 @property
 def waters_network(self) -> WatersNetwork:
 raise ValueError("You are trying to access the WatersNetwork of your scenario. This is not recommended, to avoid future bugs in your work! To alter your Network, use the appropriate method scenario.add_objects(). If it is really unavoidable to access the WatersNetwork object of your Scenario, use scenario._waters_network.")
 @property
 def dynamic_obstacles(self) -> List[DynamicObstacle]:
 """ Returns a list of all dynamic obstacles in the scenario."""
 return list(self._dynamic_obstacles.values())
 @property
 def static_obstacles(self) -> List[StaticObstacle]:
 """ Returns a list of all static obstacles in the scenario."""
 return list(self._static_obstacles.values())
 @property
 def obstacles(self) -> List[Union[Obstacle, StaticObstacle, DynamicObstacle]]:
 """ Returns a list of all static and dynamic obstacles in the scenario."""
 return list(itertools.chain(self._static_obstacles.values(),
 self._dynamic_obstacles.values()))
 def add_objects(self, scenario_object: Union[List[Union[Obstacle, Waters, WatersNetwork, TrafficSign]], Obstacle, Waters, WatersNetwork,
 TrafficSign], waters_ids: Union[None, Set[int]] = None, traffic_sign_parameters: Dict[str, Any] = None):
 """ Function to add objects, e.g., waters, dynamic and static obstacles, to the scenario.
 :param scenario_object: object(s) to be added to the scenario
 :param waters_ids: water IDs a traffic sign should be referenced from
 :param traffic_sign_parameters: dict of parameters of the obstacle related with the traffic sign (keys must be 'obstacle_type', 'obstacle_id' and 'radius')
 :raise ValueError: a value error is raised if the type of scenario_object is invalid.
 """
 if isinstance(scenario_object, list):
 for obj in scenario_object:
 self.add_objects(obj)
 elif isinstance(scenario_object, StaticObstacle):
 self._mark_object_id_as_used(scenario_object.obstacle_id)
 self._static_obstacles[scenario_object.obstacle_id] = scenario_object
 elif isinstance(scenario_object, DynamicObstacle):
 self._mark_object_id_as_used(scenario_object.obstacle_id)
 self._dynamic_obstacles[scenario_object.obstacle_id] = scenario_object
 elif isinstance(scenario_object, WatersNetwork):
 for water in scenario_object.waters:
 self._mark_object_id_as_used(water.waters_id)
 for traffic_sign in scenario_object.traffic_signs:
 self._mark_object_id_as_used(traffic_sign.traffic_sign_id)
 for shallow in scenario_object.shallows:
 self._mark_object_id_as_used(shallow.waters_id)
 self._waters_network: WatersNetwork = scenario_object
 warnings.warn('WatersNetwork replaced. (When a WatersNetwork is used in the add_objects method, the old one present in the scenario is replaced by the new one)')
 elif isinstance(scenario_object, Waters):
 self._mark_object_id_as_used(scenario_object.waters_id)
 self._waters_network.add_waters(scenario_object)
 elif isinstance(scenario_object, TrafficSign):
 warnings.warn('By adding a traffic sign, you automatically creates an obstacle in the same position that represent the physical boundary of the sign.')
 self._mark_object_id_as_used(scenario_object.traffic_sign_id)
 self._waters_network.add_traffic_sign(scenario_object, waters_ids)
 if traffic_sign_parameters is None:
 traffic_sign_parameters = {'obstacle_type': ObstacleType.BUOY, 'obstacle_id': self.generate_object_id(), 'radius': 5}
 else:
 pass
 obstacle_type = traffic_sign_parameters.get('obstacle_type', ObstacleType.BUOY)
 obstacle_id = traffic_sign_parameters.get('obstacle_id', None)
 obstacle_radius = traffic_sign_parameters.get('radius', 5)
 if obstacle_id is None:
 obstacle_id = self.generate_object_id()
 else:
 pass
 position = scenario_object.position
 above_obstacle_list = self.obstacles_by_position_intervals(position_intervals=[Interval(start=position[0] - obstacle_radius, end=position[0] + obstacle_radius), Interval(start= position[1] - obstacle_radius, end=position[1] + obstacle_radius)], obstacle_role=[ObstacleRole.STATIC])
 if above_obstacle_list:
 obstacle_id = above_obstacle_list[0].obstacle_id
 warnings.warn('As there was already an obstacle under the position of your traffic_sign, a new obstacle was not inserted!')
 else:
 circ_1 = Circle(obstacle_radius)
 init_state_1 = GeneralState(time_step=0, orientation=0, position=position, velocity=0)
 static_obs_1 = StaticObstacle(obstacle_id, obstacle_type, obstacle_shape=circ_1, initial_state=init_state_1)
 self._mark_object_id_as_used(obstacle_id)
 self._static_obstacles[obstacle_id] = static_obs_1
 scenario_object.related_obstacle = obstacle_id
 else:
 raise ValueError('<Scenario/add_objects> argument "scenario_object" of wrong type. '
 'Expected types: %s, %s, %s, and %s. Got type: %s.'
 % (list, Obstacle, Waters, WatersNetwork, type(scenario_object)))
 def remove_obstacle(self, obstacle: Union[Obstacle, List[Obstacle]]):
 """ Removes a static, dynamic or a list of obstacles from the scenario. If the obstacle ID is not assigned,
 a warning message is given.
 :param obstacle: obstacle to be removed
 """
 assert isinstance(obstacle, (list, Obstacle)), '<Scenario/remove_obstacle> argument "obstacle" of wrong type. ' \
 'Expected type: %s. Got type: %s.' % (Obstacle, type(obstacle))
 if isinstance(obstacle, list):
 for obs in obstacle:
 self.remove_obstacle(obs)
 return
 if obstacle.obstacle_id in self._static_obstacles:
 del self._static_obstacles[obstacle.obstacle_id]
 self._id_set.remove(obstacle.obstacle_id)
 elif obstacle.obstacle_id in self._dynamic_obstacles:
 del self._dynamic_obstacles[obstacle.obstacle_id]
 self._id_set.remove(obstacle.obstacle_id)
 else:
 warnings.warn('<Scenario/remove_obstacle> Cannot remove obstacle with ID %s, '
 'since it is not contained in the scenario.' % obstacle.obstacle_id)
 def erase_waters_network(self):
 """
 Removes all elements from waters network.
 """
 for waters in self._waters_network.waters:
 self.remove_waters(waters)
 for traffic_sign in self._waters_network.traffic_signs:
 self.remove_traffic_sign(traffic_sign)
 self._waters_network = WatersNetwork(np.array([0,0]),0,0,0)
 def replace_waters_network(self, waters_network: WatersNetwork):
 """
 Removes waters network with all its elements from the scenario and replaces it with new waters network.
 :param waters_network: new waters network
 """
 self.erase_waters_network()
 self.add_objects(waters_network)
 def remove_hanging_waters_members(self, remove_waters: Union[List[Waters], Waters]):
 """
 After removing waters from remove_waters, this function removes all traffic lights and signs that are
 not used by other waters.
 :param remove_waters: Waters that should be removed from scenario.
 """
 all_waters = self._waters_network.waters
 remove_waters_ids = [la.waters_id for la in remove_waters]
 remaining_waters = [la for la in all_waters if la.waters_id not in remove_waters_ids]
 traffic_signs_to_delete = set().union(*[la.traffic_signs for la in remove_waters])
 traffic_signs_to_save = set().union(*[la.traffic_signs for la in remaining_waters])
 remove_traffic_signs = []
 for t in self._waters_network.traffic_signs:
 if t.traffic_sign_id in set(traffic_signs_to_delete - traffic_signs_to_save):
 remove_traffic_signs.append(self._waters_network.find_traffic_sign_by_id(t.traffic_sign_id))
 self.remove_traffic_sign(remove_traffic_signs)
 def remove_waters(self, waters: Union[List[Waters], Waters], referenced_elements: bool = True):
 """
 Removes a waters or a list of waters from a scenario.
 :param waters: Waters which should be removed from scenario.
 :param referenced_elements: Boolean indicating whether references of waters should also be removed.
 """
 assert isinstance(waters, (list, Waters)), '<Scenario/remove_waters> argument "waters" of wrong type. ' \
 'Expected type: %s. Got type: %s.' % (Waters, type(waters))
 assert isinstance(referenced_elements,
 bool), '<Scenario/remove_waters> argument "referenced_elements" of wrong type. ' \
 'Expected type: %s, Got type: %s.' % (bool, type(referenced_elements))
 if not isinstance(waters, list):
 waters = [waters]
 if referenced_elements:
 self.remove_hanging_waters_members(waters)
 for la in waters:
 self._waters_network.remove_waters(la.waters_id)
 self._id_set.remove(la.waters_id)
 def remove_traffic_sign(self, traffic_sign: Union[List[TrafficSign], TrafficSign]):
 """
 Removes a traffic sign or a list of traffic signs from the scenario.
 :param traffic_sign: Traffic sign which should be removed from scenario.
 """
 assert isinstance(traffic_sign,
 (list, TrafficSign)), '<Scenario/remove_traffic_sign> argument "traffic_sign" of wrong ' \
 'type. ' \
 'Expected type: %s. Got type: %s.' % (TrafficSign, type(traffic_sign))
 if isinstance(traffic_sign, list):
 for sign in traffic_sign:
 self._waters_network.remove_traffic_sign(sign.traffic_sign_id)
 self._id_set.remove(sign.traffic_sign_id)
 self.remove_obstacle(self.obstacle_by_id(sign.related_obstacle))
 return
 self._waters_network.remove_traffic_sign(traffic_sign.traffic_sign_id)
 self._id_set.remove(traffic_sign.traffic_sign_id)
 self.remove_obstacle(self.obstacle_by_id(traffic_sign.related_obstacle))
 def generate_object_id(self) -> int:
 """ Generates a unique ID which is not assigned to any object in the scenario.
 :return: unique object ID
 """
 if self._id_counter is None:
 self._id_counter = 0
 if len(self._id_set) > 0:
 max_id_used = max(self._id_set)
 self._id_counter = max(self._id_counter, max_id_used)
 self._id_counter += 1
 return int(self._id_counter)
 @property
 def shallows(self) -> List[Shallow]:
 """ Returns a list of all shallows in the WatersNetwork of the scenario."""
 return self._waters_network.shallows
 @property
 def waterways(self) -> List[Waterway]:
 """ Returns a list of all waterways in the WatersNetwork of the scenario."""
 return self._waters_network.waterways
 @property
 def waters(self) -> List[Waters]:
 """ Returns a list of all waters (waterways and shallows) in the WatersNetwork of the scenario."""
 return self._waters_network.waters
 def occupancies_at_time_step(self, time_step: int, obstacle_role: Union[None, ObstacleRole] = None) \
 -> List[Occupancy]:
 """ Returns the occupancies of all static and dynamic obstacles at a specific time step.
 :param time_step: occupancies of obstacles at this time step
 :param obstacle_role: obstacle role as defined in CommonOcean, e.g., static or dynamic
 :return: list of occupancies of the obstacles
 """
 assert is_natural_number(time_step), '<Scenario/occupancies_at_time> argument "time_step" of wrong type. ' \
 'Expected type: %s. Got type: %s.' % (int, type(time_step))
 assert isinstance(obstacle_role, (ObstacleRole, type(None))), \
 '<Scenario/obstacles_by_role_and_type> argument "obstacle_role" of wrong type. Expected types: ' \
 ' %s or %s. Got type: %s.' % (ObstacleRole, None, type(obstacle_role))
 occupancies = list()
 for obstacle in self.obstacles:
 if ((obstacle_role is None or obstacle.obstacle_role == obstacle_role) and
 obstacle.occupancy_at_time(time_step)):
 occupancies.append(obstacle.occupancy_at_time(time_step))
 return occupancies
 def obstacle_by_id(self, obstacle_id: int) -> Union[Obstacle, DynamicObstacle, StaticObstacle, None]:
 """
 Finds an obstacle for a given obstacle_id
 :param obstacle_id: ID of the queried obstacle
 :return: the obstacle object if the ID exists, otherwise None
 """
 assert is_integer_number(obstacle_id), '<Scenario/obstacle_by_id> argument "obstacle_id" of wrong type. ' \
 'Expected type: %s. Got type: %s.' % (int, type(obstacle_id))
 obstacle = None
 if obstacle_id in self._static_obstacles:
 obstacle = self._static_obstacles[obstacle_id]
 elif obstacle_id in self._dynamic_obstacles:
 obstacle = self._dynamic_obstacles[obstacle_id]
 else:
 warnings.warn('<Scenario/obstacle_by_id> Obstacle with ID %s is not contained in the scenario.'
 % obstacle_id)
 return obstacle
 def obstacles_by_role_and_type(self, obstacle_role: Union[None, ObstacleRole] = None,
 obstacle_type: Union[None, ObstacleType] = None) \
 -> List[Obstacle]:
 """
 Filters the obstacles by their role and type.
 :param obstacle_role: obstacle role as defined in CommonOcean, e.g., static or dynamic
 :param obstacle_type: obstacle type as defined in CommonOcean, e.g., car, train, or bus
 :return: list of all obstacles satisfying the given obstacle_role and obstacle_type
 """
 assert isinstance(obstacle_role, (ObstacleRole, type(None))), \
 '<Scenario/obstacles_by_role_and_type> argument "obstacle_role" of wrong type. Expected types: ' \
 ' %s or %s. Got type: %s.' % (ObstacleRole, None, type(obstacle_role))
 assert isinstance(obstacle_type, (ObstacleType, type(None))), \
 '<Scenario/obstacles_by_role_and_type> argument "obstacle_type" of wrong type. Expected types: ' \
 ' %s or %s. Got type: %s.' % (ObstacleType, None, type(obstacle_type))
 obstacle_list = list()
 for obstacle in self.obstacles:
 if ((obstacle_role is None or obstacle.obstacle_role == obstacle_role)
 and (obstacle_type is None or obstacle.obstacle_type == obstacle_type)):
 obstacle_list.append(obstacle)
 return obstacle_list
 def obstacles_by_position_intervals(
 self, position_intervals: List[Interval],
 obstacle_role: Tuple[ObstacleRole] = (ObstacleRole.DYNAMIC, ObstacleRole.STATIC),
 time_step: int = None) -> List[Obstacle]:
 """
 Returns obstacles which center is located within in the given x-/y-position intervals.
 :param position_intervals: list of intervals for x- and y-coordinates [interval_x, interval_y]
 :param obstacle_role: tuple containing the desired obstacle roles
 :return: list of obstacles in the position intervals
 """
 def contained_in_interval(position: np.ndarray):
 if position_intervals[0].contains(position[0]) and position_intervals[1].contains(position[1]):
 return True
 return False
 if time_step is None:
 time_step = 0
 obstacle_list = list()
 if ObstacleRole.STATIC in obstacle_role:
 for obstacle in self.static_obstacles:
 if contained_in_interval(obstacle.initial_state.position):
 obstacle_list.append(obstacle)
 if ObstacleRole.DYNAMIC in obstacle_role:
 for obstacle in self.dynamic_obstacles:
 occ = obstacle.occupancy_at_time(time_step)
 if occ is not None:
 if not hasattr(occ.shape, 'center'):
 obstacle_list.append(obstacle)
 elif contained_in_interval(occ.shape.center):
 obstacle_list.append(obstacle)
 return obstacle_list
 def obstacle_states_at_time_step(self, time_step: int) -> Dict[int, GeneralState]:
 """
 Returns all obstacle states which exist at a provided time step.
 :param time_step: time step of interest
 :return: dictionary which maps id to obstacle state at time step
 """
 assert is_natural_number(time_step), '<Scenario/obstacle_at_time_step> argument "time_step" of wrong type. ' \
 'Expected type: %s. Got type: %s.' % (int, type(time_step))
 obstacle_states = {}
 for obstacle in self.dynamic_obstacles:
 if obstacle.state_at_time(time_step) is not None:
 obstacle_states[obstacle.obstacle_id] = obstacle.state_at_time(time_step)
 for obstacle in self.static_obstacles:
 obstacle_states[obstacle.obstacle_id] = obstacle.initial_state
 return obstacle_states
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """ Translates and rotates all objects, e.g., obstacles and water network, in the scenario.
 :param translation: translation vector [x_off, y_off] in x- and y-direction
 :param angle: rotation angle in radian (counter-clockwise)
 """
 assert is_real_number_vector(translation, 2), '<Scenario/translate_rotate>: argument "translation" is ' \
 'not a vector of real numbers of length 2. translation = {}.' \
 .format(translation)
 assert is_valid_orientation(angle), '<Scenario/translate_rotate>: argument "orientation" is not valid. ' \
 'angle = {}.'.format(angle)
 self._waters_network.translate_rotate(translation, angle)
 for obstacle in self.obstacles:
 obstacle.translate_rotate(translation, angle)
 def _is_object_id_used(self, object_id: int) -> bool:
 """ Checks if an ID is already assigned to an object in the scenario.
 :param object_id: object ID to be checked
 :return: True, if the object ID is already assigned, False otherwise
 """
 return object_id in self._id_set
 def _mark_object_id_as_used(self, object_id: int):
 """ Checks if an ID is assigned to an object in the scenario. If the ID is already assigned an error is
 raised, otherwise, the ID is added to the set of assigned IDs.
 :param object_id: object ID to be checked
 :raise ValueError: if the object ID is already assigned to another object in the scenario.
 """
 if self._id_counter is None:
 self._id_counter = object_id
 if self._is_object_id_used(object_id):
 raise ValueError("ID %s is already used." % object_id)
 self._id_set.add(object_id)
 def __str__(self):
 traffic_str = "\n"
 traffic_str += "Scenario:\n"
 traffic_str += "- Scenario ID: {}\n".format(str(self.scenario_id))
 traffic_str += "- Time step size: {}\n".format(self._dt)
 traffic_str += "- Number of Obstacles: {}\n".format(len(self.obstacles))
 traffic_str += "- WatersNetwork:\n"
 traffic_str += str(self._waters_network)
 return traffic_str
</src\commonocean\scenario\scenario.py>

<src\commonocean\scenario\state.py>
__author__ = "Bruno Maione"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2023a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "development"
from commonroad.common.util import Interval, AngleInterval
from commonroad.geometry.shape import Shape
from commonroad.scenario.state import State
from dataclasses import dataclass
from typing import Any, Union
import numpy as np
FloatExactOrInterval = Union[float, Interval]
AngleExactOrInterval = Union[float, AngleInterval]
ExactOrShape = Union[np.ndarray, Shape]
class GeneralState(State):
 """
 This is a class representing the custom state. State variables can be added at runtime. The attributes position
 and orientation/velocity_y are necessary for successful file reading.
 """
 def __init__(self, **attributes):
 """
 Additional constructor for CustomState class.
 :param attributes: Variable number of attributes each consisting of name and value.
 """
 if len(attributes) > 0: # if one wants to use the attribute adding methods manually
 super().__init__(attributes["time_step"])
 for name, value in attributes.items():
 if name == "time_step":
 continue
 self.add_attribute(name)
 self.set_value(name, value)
 def add_attribute(self, new_attr: str):
 """
 Adds a new attribute to custom state.
 :param new_attr: Attribute name
 """
 setattr(self, new_attr, None)
 def set_value(self, attr: str, value: Any):
 """
 Sets value to attribute.
 :param attr: Attribute name
 :param value: Value
 """
 assert attr in self.attributes, "{} is not an attribute of this custom state!".format(attr)
 setattr(self, attr, value)
@dataclass(eq=False)
class PMState(State):
 """
 This is a class representing Point Mass State (PM State).
 :param position: Position :math:`s_x`- and :math:`s_y` in a global coordinate system
 :param velocity: Velocity :math:`v_x` in longitudinal direction
 :param velocity_y: Velocity :math:`v_x` in lateral direction
 """
 position: ExactOrShape = None
 velocity: FloatExactOrInterval = None
 velocity_y: FloatExactOrInterval = None
@dataclass(eq=False)
class VPState(State):
 """
 This is a class representing Velocity-Constrained Point Mass State (VP State).
 :param position: Position :math:`s_x`- and :math:`s_y` in a global coordinate system
 :param velocity: Velocity :math:`v_x` in longitudinal direction
 :param velocity_y: Velocity :math:`v_x` in lateral direction
 """
 position: ExactOrShape = None
 velocity: FloatExactOrInterval = None
 velocity_y: FloatExactOrInterval = None
@dataclass(eq=False)
class YPState(State):
 """
 This is a class representing Yaw-Constrained Point Mass State (VP State).
 :param position: Position :math:`s_x`- and :math:`s_y` in a global coordinate system
 :param orientation: Yaw angle :math:`\\Psi`
 :param velocity: Velocity :math:`n` aligned with the orientation of the vessel (also called surge)
 """
 position: ExactOrShape = None
 orientation: AngleExactOrInterval = None
 velocity: FloatExactOrInterval = None
@dataclass(eq=False)
class TFState(State):
 """
 This is a class representing Three Degrees of Freedom Model (3F State).
 :param position: Position :math:`s_x`- and :math:`s_y` in a global coordinate system
 :param orientation: Yaw angle :math:`\\Psi`
 :param velocity: Velocity :math:`n` aligned with the orientation of the vessel (also called surge)
 :param velocity_y: Velocity :math:`v` lateral to the orientation of the vessel (also called sway)
 :paran yaw_rate: Yaw rate :math:`\\omega`
 """
 position: ExactOrShape = None
 orientation: AngleExactOrInterval = None
 velocity: FloatExactOrInterval = None
 velocity_y: FloatExactOrInterval = None
 yaw_rate: FloatExactOrInterval = None
@dataclass(eq=False)
class VesselState(State):
 """
 This is a class representing an arbitrary vesel state with all possible state elements (slots),
 which comprise the necessary tate element to describe the tates of all CommonOcean vessel models.
 :param position: :math:`s_x`- and :math:`s_y`-position in a global
 coordinate system. Exact positions
 are given as numpy array [x, y], uncertain positions are given as :class:`commonroad.geometry.shape.Shape`
 :param orientation: yaw angle :math:`\Psi`. Exact values are given as real number, uncertain values are given as
 :class:`commonroad.common.util.AngleInterval`
 :param velocity: velocity :math:`v_x` in longitudinal direction in the vessel-fixed coordinate system. Exact
 values are given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param rudder_angle: rudder angle :math:`\beta`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param rudder_angle_speed: rudder angle speed :math:`\dot{\beta}` Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param yaw_rate: yaw rate :math:`\dot{\Psi}`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_angle: roll angle :math:`\Phi_S`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_rate: roll rate :math:`\dot{\Phi}_S`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param pitch_angle: pitch angle :math:`\Theta_S`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param pitch_rate: pitch rate :math:`\dot{\Theta}_S`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_y: velocity :math:`v_y` in lateral direction in the vessel-fixed coordinate system. Exact
 values are given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param position_z: position :math:`s_z` (height) from ground. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_z: velocity :math:`v_z` in vertical direction perpendicular to road plane. Exact values are
 given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_angle_front: roll angle front :math:`\Phi_{UF}`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_rate_front: roll rate front :math:`\dot{\Phi}_{UF}`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_y_front: velocity :math:`v_{y,UF}` in y-direction front. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param position_z_front: position :math:`s_{z,UF}` in z-direction front. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_z_front: velocity :math:`v_{z,UF}` in z-direction front. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_angle_rear: roll angle rear :math:`\Phi_{UR}`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param roll_rate_rear: roll rate rear :math:`\dot{\Phi}_{UR}`. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_y_rear: velocity :math:`v_{y,UR}` in y-direction rear. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param position_z_rear: position :math:`s_{z,UR}` in z-direction rear. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param velocity_z_rear: velocity :math:`v_{z,UR}` in z-direction rear. Exact values are given as real number,
 uncertain values are given as :class:`commonroad.common.util.Interval`
 :param acceleration: acceleration :math:`a_x`. We optionally include acceleration as a state variable for
 obstacles to provide additional information, e.g., for motion prediction, even though acceleration is often
 used as an input for vessel models. Exact values are given as real number, uncertain values are given as
 :class:`commonroad.common.util.Interval`
 :param acceleration_y: velocity :math:`a_y`.
 We optionally include acceleration as a state variable for obstacles to provide additional information,
 e.g., for motion prediction, even though acceleration is often used as an input for vessel models. Exact
 values are given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param jerk: acceleration :math:`j`. We optionally include jerk as a state variable for
 obstacles to provide additional information, e.g., for motion prediction, even though jerk is often
 used as an input for vessel models. Exact values are given as real number, uncertain values are given as
 :class:`commonroad.common.util.Interval`
 :param force_orientation: force :math:`F_x`. We optionally include the body-fixed force aligned with orientation
 as a state variable to provide additional information to vessel dynamics inputs, e.g., for motion prediction.
 Exact values are given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param force_lateral: force :math:`F_y`. We optionally include the body-fixed force lateral to orientation
 as a state variable to provide additional information to vessel dynamics inputs, e.g., for motion prediction.
 Exact values are given as real number, uncertain values are given as :class:`commonroad.common.util.Interval`
 :param yaw_moment: force :math:`M_{\Phi}`. We optionally include the yaw_momment as a state variable to provide additional
 information to vessel dynamics inputs, e.g., for motion prediction. Exact values are given as real number, uncertain
 values are given as :class:`commonroad.common.util.Interval`
 """
 position: ExactOrShape = None
 orientation: AngleExactOrInterval = None
 velocity: FloatExactOrInterval = None
 rudder_angle: AngleExactOrInterval = None
 rudder_angle_speed: FloatExactOrInterval = None
 yaw_rate: FloatExactOrInterval = None
 roll_angle: AngleExactOrInterval = None
 roll_rate: FloatExactOrInterval = None
 pitch_angle: AngleExactOrInterval = None
 pitch_rate: FloatExactOrInterval = None
 velocity_y: FloatExactOrInterval = None
 position_z: FloatExactOrInterval = None
 velocity_z: FloatExactOrInterval = None
 roll_angle_front: AngleExactOrInterval = None
 roll_rate_front: FloatExactOrInterval = None
 velocity_y_front: FloatExactOrInterval = None
 position_z_front: FloatExactOrInterval = None
 velocity_z_front: FloatExactOrInterval = None
 roll_angle_rear: AngleExactOrInterval = None
 roll_rate_rear: FloatExactOrInterval = None
 velocity_y_rear: FloatExactOrInterval = None
 position_z_rear: FloatExactOrInterval = None
 velocity_z_rear: FloatExactOrInterval = None
 acceleration: FloatExactOrInterval = None
 acceleration_y: FloatExactOrInterval = None
 jerk: FloatExactOrInterval = None
 force_orientation: FloatExactOrInterval = None
 force_lateral: FloatExactOrInterval = None
 yaw_moment: FloatExactOrInterval = None
</src\commonocean\scenario\state.py>

<src\commonocean\scenario\traffic_sign.py>
import enum
from typing import List, Union
import numpy as np
from commonroad.common.validity import *
import commonroad.geometry.transform
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
@enum.unique
class TrafficSignElementID(enum.Enum):
 LATERAL_MARK_RED_A = '101'
 LATERAL_MARK_GREEN_A = '102'
 SPECIAL_MARK = '103'
 CARDINAL_MARK_NORTH = '104'
 CARDINAL_MARK_EAST = '105'
 CARDINAL_MARK_SOUTH = '106'
 CARDINAL_MARK_WEST = '107'
 """
 e.g. östlich umfahren, Untiefe, ankern verboten
 """
class TrafficSignElement:
 """ Class which represents a collection of traffic signs at one position"""
 def __init__(self, traffic_sign_element_id: Union[TrafficSignElementID],
 additional_values: List[str]):
 """
 :param traffic_sign_element_id: ID of traffic sign element (must be element of a traffic sign element enum)
 :param additional_values: list of additional values of a traffic sign element, e.g. velocity, time, city name
 """
 self._traffic_sign_element_id = traffic_sign_element_id
 self._additional_values = additional_values
 @property
 def traffic_sign_element_id(self) -> enum:
 return self._traffic_sign_element_id
 @property
 def additional_values(self) -> List[str]:
 return self._additional_values
 def __eq__(self, other: 'TrafficSignElement'):
 if self.traffic_sign_element_id == other.traffic_sign_element_id \
 and self.additional_values == other.additional_values:
 return True
 else:
 return False
 def __ne__(self, other):
 return not self.__eq__(other)
 def __hash__(self):
 return hash(str(self._traffic_sign_element_id) + str(self.additional_values))
 def __str__(self):
 return f"Sign Element with id {self._traffic_sign_element_id} and values {self._additional_values} "
 def __repr__(self):
 return f"Sign Element with id {self._traffic_sign_element_id} and values {self._additional_values} "
class TrafficSign:
 """Class to represent a traffic sign"""
 def __init__(self, traffic_sign_id: int, traffic_sign_elements: List[TrafficSignElement],
 position: np.ndarray, virtual: bool = False):
 """
 :param traffic_sign_id: ID of traffic sign
 :param traffic_sign_elements: list of traffic sign elements
 :param position: position of traffic sign
 :param virtual: boolean indicating if this traffic sign is also placed there in the real environment or it
 is added for other reasons (e.g., completeness of scenario)
 """
 self._traffic_sign_id = traffic_sign_id
 self._position = position
 self._traffic_sign_elements = traffic_sign_elements
 self._virtual = virtual
 self._related_obstacle = None
 def __eq__(self, other):
 if not isinstance(other, TrafficSign):
 warnings.warn(f"Inequality between TrafficSign {repr(self)} and different type {type(other)}")
 return False
 list_elements_eq = True
 traffic_sign_elements = {traffic_sign_element.traffic_sign_element_id: traffic_sign_element
 for traffic_sign_element in self._traffic_sign_elements}
 traffic_sign_elements_other = {traffic_sign_element.traffic_sign_element_id: traffic_sign_element
 for traffic_sign_element in other._traffic_sign_elements}
 traffic_sign_eq = len(traffic_sign_elements) == len(traffic_sign_elements_other)
 for k in traffic_sign_elements.keys():
 if k not in traffic_sign_elements_other:
 traffic_sign_eq = False
 continue
 if traffic_sign_elements.get(k) != traffic_sign_elements_other.get(k):
 list_elements_eq = False
 position_string = None if self._position is None else \
 np.array2string(np.around(self._position.astype(float), 10), precision=10)
 position_other_string = None if other._position is None else \
 np.array2string(np.around(other.position.astype(float), 10), precision=10)
 if traffic_sign_eq and self._traffic_sign_id == other.traffic_sign_id \
 and position_string == position_other_string and self._virtual == other.virtual:
 return list_elements_eq
 warnings.warn(f"Inequality of TrafficSign {repr(self)} and the other one {repr(other)}")
 return False
 def __hash__(self):
 position_string = None if self._position is None else \
 np.array2string(np.around(self._position.astype(float), 10), precision=10)
 return hash((self._traffic_sign_id, position_string, frozenset(self._traffic_sign_elements), self._virtual))
 def __repr__(self):
 return f"TrafficSign(traffic_sign_id={self._traffic_sign_id}, " \
 f"traffic_sign_elements={repr(self._traffic_sign_elements)}, " \
 f"position={None if self._position is None else self._position.tolist()}, virtual={self._virtual})"
 def __str__(self):
 return f"Sign At {self._position} with {self._traffic_sign_elements} "
 @property
 def traffic_sign_id(self) -> int:
 return self._traffic_sign_id
 @property
 def position(self) -> Union[None, np.ndarray]:
 return self._position
 @property
 def traffic_sign_elements(self) -> List[TrafficSignElement]:
 return self._traffic_sign_elements
 @property
 def virtual(self) -> bool:
 return self._virtual
 @property
 def related_obstacle(self) -> Union[None, int]:
 return self._related_obstacle
 @related_obstacle.setter
 def related_obstacle(self, obstacle_id: int):
 self._related_obstacle = obstacle_id
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 This method translates and rotates a traffic sign
 :param translation: The translation given as [x_off,y_off] for the x and y translation
 :param angle: The rotation angle in radian (counter-clockwise defined)
 """
 assert is_real_number_vector(translation, 2), '<TrafficSign/translate_rotate>: argument translation is ' \
 'not a vector of real numbers of length 2.'
 assert is_real_number(angle), '<TrafficSign/translate_rotate>: argument angle must be a scalar. ' \
 'angle = %s' % angle
 assert is_valid_orientation(angle), '<TrafficSign/translate_rotate>: argument angle must be within the ' \
 'interval [-2pi, 2pi]. angle = %s' % angle
 self._position = commonroad.geometry.transform.translate_rotate(np.array([self._position]),
 translation, angle)[0]
</src\commonocean\scenario\traffic_sign.py>

<src\commonocean\scenario\trajectory.py>
__author__ = "Bruno Maione"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2023a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "development"
from commonroad.scenario.trajectory import Trajectory as Trajectory_CR
from commonocean.scenario.state import GeneralState
from typing import List
class Trajectory(Trajectory_CR):
 """ Class to model the movement of an object over time. The states of the
 trajectory can be either exact or uncertain (see :class:`commonocean.scenario.state.CustomState`); however,
 only exact time_step are allowed. """
 def __init__(self, initial_time_step: int, state_list: List[GeneralState]):
 """
 :param initial_time_step: initial time step of the trajectory
 :param state_list: ordered sequence of states over time representing
 the trajectory. It is assumed that
 the time discretization between two states matches the time
 discretization of the scenario.
 """
 super().__init__(initial_time_step, state_list)
</src\commonocean\scenario\trajectory.py>

<src\commonocean\scenario\waters.py>
import enum
from typing import *
from uuid import RESERVED_FUTURE
import numpy as np
import abc
from commonroad.geometry.shape import Circle, Rectangle, Shape, Polygon, ShapeGroup
from commonroad.geometry.transform import translation_rotation_matrix
from commonroad.common.validity import *
from commonocean.scenario.obstacle import Obstacle
from commonocean.scenario.traffic_sign import TrafficSign
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
class WatersType(enum.Enum):
 """
 Enum describing different types of waters
 """
 UNKNOWN = 'unknown'
 FAIRWAY = 'fairway'
 SHALLOW = 'shallow'
 TRAFFICSEPARATIONZONE = 'trafficseparationzone'
class WatersUser(enum.Enum):
 """
 Enum describing different types of water users
 """
 VESSEL = 'vessel'
 MOTORVESSEL = 'motorvessel'
 SAILINGVESSEL = 'sailingvessel'
 CARGOSHIP = 'cargoship'
 SWIMMER = 'swimmer'
class Waters(metaclass=abc.ABCMeta):
 """
 Abstract class for waters in CommonOcean
 """
 @abc.abstractproperty
 def waters_type(self):
 pass
 @abc.abstractproperty
 def waters_id(self):
 pass
 @abc.abstractmethod
 def translate_rotate(self, translation: np.ndarray, angle: float):
 pass
 @abc.abstractmethod
 def contains_points(self, point: np.ndarray):
 pass
 @abc.abstractmethod
 def get_obstacles(self):
 pass
class Waterway(Waters):
 """
 Class which describes a Waters entity according to the CommonOcean specification.
 """
 def __init__(self, left_vertices: np.ndarray, center_vertices: np.ndarray, right_vertices: np.ndarray,
 waters_id: int, waters_type: WatersType, predecessor=None, successor=None,
 traffic_signs=None
 ):
 """
 Constructor of a Waters object
 :param left_vertices: The vertices of the left boundary of the Waters described as a
 polyline [[x0,x1,...,xn],[y0,y1,...,yn]]
 :param center_vertices: The vertices of the center line of the Waters described as a
 polyline [[x0,x1,...,xn],[y0,y1,...,yn]]
 :param right_vertices: The vertices of the right boundary of the Waters described as a
 polyline [[x0,x1,...,xn],[y0,y1,...,yn]]
 :param waters_id: The unique id (natural number) of the water
 :param waters_type: Class of Water
 :param predecessor: The list of predecessor waters (None if not existing)
 :param successor: The list of successor waters (None if not existing)
 :param traffic_signs: Traffic signs to be applied
 """
 self._left_vertices = None
 self._right_vertices = None
 self._center_vertices = None
 self._waters_id = None
 self.waters_id = waters_id
 self.left_vertices = left_vertices
 self.right_vertices = right_vertices
 self.center_vertices = center_vertices
 assert len(left_vertices[0]) == len(center_vertices[0]) == len(
 right_vertices[0]), '<Waters/init>: Provided polylines do not share the same length! {}/{}/{}'.format(
 len(left_vertices[0]), len(center_vertices[0]), len(right_vertices[0]))
 assert (waters_type == WatersType.FAIRWAY or waters_type == WatersType.TRAFFICSEPARATIONZONE or WatersType.UNKNOWN), \
 '<Waters/init>: Waterway must be of type traffic separation zone, fairway or unknown. Got type {}'.format(waters_type)
 self._waters_type = waters_type
 self._predecessor = None
 if predecessor is None:
 self._predecessor = []
 else:
 self.predecessor = predecessor
 self._successor = None
 if successor is None:
 self._successor = []
 else:
 self.successor = successor
 self._polygon = None
 self._traffic_signs = None
 if traffic_signs is None:
 self._traffic_signs = set()
 else:
 self.traffic_signs = traffic_signs
 self._depth = np.inf
 def __eq__(self, other):
 if not isinstance(other, Waters):
 warnings.warn(f"Inequality between Waters {repr(self)} and different type {type(other)}")
 return False
 waters_eq = True
 polylines = [self._left_vertices, self._right_vertices, self._center_vertices]
 polylines_other = [other.left_vertices, other.right_vertices, other.center_vertices]
 for i in range(0, len(polylines)):
 polyline = polylines[i]
 polyline_other = polylines_other[i]
 polyline_string = np.array2string(np.around(polyline.astype(float), 10), precision=10)
 polyline_other_string = np.array2string(np.around(polyline_other.astype(float), 10), precision=10)
 waters_eq = waters_eq and polyline_string == polyline_other_string
 if waters_eq and self.waters_id == other.waters_id \
 and set(self._predecessor) == set(other.predecessor) and set(self._successor) == set(other.successor) \
 and self._waters_type == other.waters_type \
 and self._traffic_signs == other.traffic_signs:
 return polylines
 warnings.warn(f"Inequality of Waters {repr(self)} and the other one {repr(other)}")
 return False
 def __hash__(self):
 polylines = [self._left_vertices, self._right_vertices, self._center_vertices]
 polyline_strings = []
 for polyline in polylines:
 polyline_string = np.array2string(np.around(polyline.astype(float), 10), precision=10)
 polyline_strings.append(polyline_string)
 elements = [self._predecessor, self._successor, self._traffic_signs]
 frozen_elements = [frozenset(e) for e in elements]
 frozen_elements.append(self._waters_type)
 return hash((self._waters_id, tuple(polyline_strings), tuple(frozen_elements)))
 def __str__(self):
 return 'Waterway with id:' + str(self.waters_id)
 def __repr__(self):
 return f"Waterway(left_vertices={self._left_vertices.tolist()}, " \
 f"center_vertices={self._center_vertices.tolist()}, " \
 f"right_vertices={self._right_vertices.tolist()}, waters_id={self._waters_id}, " \
 f"predecessor={self._predecessor}, successor={self._successor}, " \
 f"waters_type={self._waters_type}, " \
 f" traffic_signs={self._traffic_signs}"
 @property
 def waters_type(self) -> WatersType:
 return self._waters_type
 @property
 def waters_id(self) -> int:
 return self._waters_id
 @waters_id.setter
 def waters_id(self, f_id: int):
 if self._waters_id is None:
 assert is_natural_number(f_id), '<Waters/waters_id>: Provided waters_id is not valid! id={}'.format(f_id)
 self._waters_id = f_id
 else:
 warnings.warn('<Waters/waters_id>: waters_id of waters is immutable')
 @property
 def left_vertices(self) -> np.ndarray:
 return self._left_vertices
 @left_vertices.setter
 def left_vertices(self, polyline: np.ndarray):
 if self._left_vertices is None:
 assert is_valid_polyline(
 polyline), '<Waters/left_vertices>: The provided polyline is not valid! polyline = {}'.format(polyline)
 self._left_vertices = polyline
 else:
 warnings.warn('<Waters/left_vertices>: left_vertices of waters are immutable!')
 @property
 def right_vertices(self) -> np.ndarray:
 return self._right_vertices
 @right_vertices.setter
 def right_vertices(self, polyline: np.ndarray):
 if self._right_vertices is None:
 assert is_valid_polyline(
 polyline), '<Waters/right_vertices>: The provided polyline is not valid! polyline = {}'.format(
 polyline)
 self._right_vertices = polyline
 else:
 warnings.warn('<Waters/right_vertices>: right_vertices of waters are immutable!')
 @property
 def center_vertices(self) -> np.ndarray:
 return self._center_vertices
 @center_vertices.setter
 def center_vertices(self, polyline: np.ndarray):
 if self._center_vertices is None:
 assert is_valid_polyline(
 polyline), '<Waters/center_vertices>: The provided polyline is not valid! polyline = {}'.format(
 polyline)
 self._center_vertices = polyline
 else:
 warnings.warn('<Waters/center_vertices>: center_vertices of water are immutable!')
 @property
 def predecessor(self) -> list:
 return self._predecessor
 @predecessor.setter
 def predecessor(self, predecessor: list):
 if self._predecessor is None:
 assert (is_list_of_natural_numbers(predecessor) and len(predecessor) >= 0), '<Waters/predecessor>: ' \
 'Provided list ' \
 'of predecessors is not valid!' \
 'predecessors = {}'.format(
 predecessor)
 self._predecessor = predecessor
 else:
 warnings.warn(
 '<Waters/predecessor>: predecessor of waters is immutable!')
 @property
 def successor(self) -> list:
 return self._successor
 @successor.setter
 def successor(self, successor: list):
 if self._successor is None:
 assert (is_list_of_natural_numbers(successor) and len(successor) >= 0), '<Waters/predecessor>: Provided ' \
 'list of successors is not valid!' \
 'successors = {}'.format(successor)
 self._successor = successor
 else:
 warnings.warn(
 '<Waters/successor>: successor of water is immutable!')
 @waters_type.setter
 def waters_type(self, waters_type: Set[WatersType]):
 if self._waters_type is None or len(self._waters_type) == 0:
 assert isinstance(waters_type, set) and all(isinstance(elem, WatersType) for elem in waters_type), \
 '<Waters/waters_type>: ''Provided type is not valid! type = {}'.format(type(waters_type))
 self._waters_type = waters_type
 else:
 warnings.warn(
 '<Water/waters_type>: type of water is immutable!')
 @property
 def traffic_signs(self) -> Set[int]:
 return self._traffic_signs
 @traffic_signs.setter
 def traffic_signs(self, traffic_sign_ids: Set[int]):
 if self._traffic_signs is None:
 assert isinstance(traffic_sign_ids, set), \
 '<Waters/traffic_signs>: provided list of ids is not a ' \
 'set! type = {}'.format(type(traffic_sign_ids))
 self._traffic_signs = traffic_sign_ids
 else:
 warnings.warn(
 '<Waters/traffic_signs>: traffic_signs of water is immutable!')
 @property
 def depth(self):
 return self._depth
 @depth.setter
 def depth(self, depth: float):
 warnings.warn('<Waters/depth>: depth of waterway is immutable!')
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 This method translates and rotates a water
 :param translation: The translation given as [x_off,y_off] for the x and y translation
 :param angle: The rotation angle in radian (counter-clockwise defined)
 """
 assert is_real_number_vector(translation,
 2), '<Waters/translate_rotate>: provided translation ' \
 'is not valid! translation = {}'.format(translation)
 assert is_valid_orientation(
 angle), '<Waters/translate_rotate>: provided angle is not valid! angle = {}'.format(angle)
 t_m = translation_rotation_matrix(translation,angle)
 tmp = t_m.dot(np.vstack((self.center_vertices.transpose(),
 np.ones((1, self.center_vertices.shape[0])))))
 tmp = tmp[0:2, :]
 self._center_vertices = tmp.transpose()
 tmp = t_m.dot(np.vstack((self.left_vertices.transpose(),
 np.ones((1, self.left_vertices.shape[0])))))
 tmp = tmp[0:2, :]
 self._left_vertices = tmp.transpose()
 tmp = t_m.dot(np.vstack((self.right_vertices.transpose(),
 np.ones((1, self.right_vertices.shape[0])))))
 tmp = tmp[0:2, :]
 self._right_vertices = tmp.transpose()
 if self._polygon is not None:
 self._polygon = None
 self._polygon = self.convert_to_polygon()
 def convert_to_polygon(self) -> Polygon:
 """
 Converts the given water to a polygon representation
 :return: The polygon of the water
 """
 if self._polygon is None:
 self._polygon = Polygon(np.concatenate((self.right_vertices,
 np.flip(self.left_vertices, 0))))
 return self._polygon
 def contains_points(self, point_list: np.ndarray) -> List[bool]:
 """
 Checks if a list of points is enclosed in the water
 :param point_list: The list of points in the form [[px1,py1],[px2,py2,],...]
 :return: List of bools with True indicating point is enclosed and False otherwise
 """
 assert isinstance(point_list,
 ValidTypes.ARRAY), '<Waters/contains_points>: provided list of points is not a list! type ' \
 '= {}'.format(type(point_list))
 assert is_valid_polyline(
 point_list), 'Waters/contains_points>: provided list of points is malformed! points = {}'.format(
 point_list)
 res = list()
 poly = self.convert_to_polygon()
 for p in point_list:
 res.append(poly.contains_point(p))
 return res
 def get_obstacles(self, obstacles: List[Obstacle], time_step: int = 0) -> List[Obstacle]:
 """
 Returns the subset of obstacles, which are located in the water, of a given candidate set
 :param obstacles: The set of obstacle candidates
 :param time_step: The time step for the occupancy to check
 :return:
 """
 assert isinstance(obstacles, list) and all(isinstance(o, Obstacle) for o in
 obstacles), '<Waters/get_obstacles>: Provided list of obstacles' \
 ' is malformed! obstacles = {}'.format(
 obstacles)
 res = list()
 for o in obstacles:
 o_shape = o.occupancy_at_time(time_step).shape
 vertices = list()
 if isinstance(o_shape, ShapeGroup):
 for sh in o_shape.shapes:
 if isinstance(sh, Circle):
 vertices.append(sh.center)
 else:
 vertices.append(sh.vertices)
 vertices = np.append(vertices, [o_shape.center], axis=0)
 else:
 if isinstance(o_shape, Circle):
 vertices = o_shape.center
 else:
 vertices = o_shape.vertices
 vertices = np.append(vertices, [o_shape.center], axis=0)
 if any(self.contains_points(np.array(vertices))):
 res.append(o)
 return res
 def add_traffic_sign_to_water(self, traffic_sign_id: int):
 """
 Adds a traffic sign ID to water
 :param traffic_sign_id: traffic sign ID to add
 """
 self.traffic_signs.add(traffic_sign_id)
class Shallow(Waters):
 """Class to describe a shallow with a defined shape and depth"""
 def __init__(self, shape: Shape, waters_id: int, depth: float = 10.0):
 """
 :param shape: shape of the shallow
 :param depth: depth of the shallow in meters (default: 10.0)
 """
 self._shape = shape
 self._depth = depth
 self._waters_id = waters_id
 self._waters_type = WatersType.SHALLOW
 def __str__(self):
 shallow_str = "\n"
 shallow_str += "Shallow:\n"
 shallow_str += "- Shape: {}\n".format(type(self._shape).__name__)
 shallow_str += "- Center-Position: {}\n".format(str(self.shape.center))
 shallow_str += "- Depth: {} Meters\n".format(str(self.depth))
 return shallow_str
 def __repr__(self):
 return f"Shallow(shape={type(self._shape).__name__}, " \
 f"waters_id={str(self.waters_id)}, " \
 f"center_position={str(self.shape.center)}, " \
 f"depth={str(self.depth)}"
 @property
 def waters_type(self) -> WatersType:
 return self._waters_type
 @property
 def waters_id(self) -> int:
 return self._waters_id
 @waters_id.setter
 def waters_id(self, f_id: int):
 if self._waters_id is None:
 assert is_natural_number(f_id), '<Waters/waters_id>: Provided waters_id is not valid! id={}'.format(f_id)
 self._waters_id = f_id
 else:
 warnings.warn('<Waters/waters_id>: waters_id of waters is immutable')
 @property
 def shape(self):
 return self._shape
 @shape.setter
 def shape(self, shape: Shape):
 assert isinstance(shape, Shape), \
 '<Shallow/shape>: argument shape of wrong ' \
 'type. Expected type: %s. Got type: %s.' \
 % (Shape, type(shape))
 self._shape = shape
 @property
 def depth(self):
 return self._depth
 @depth.setter
 def depth(self, depth: float):
 assert isinstance(depth, float), \
 '<Shallow/depth>: argument depth of wrong ' \
 'type. Expected type: %s. Got type: %s.' \
 % (float, type(depth))
 assert depth >= 0, '<Shallow/depth>: argument depth is a negative number. ' \
 'Expected type is a positive number. Got: %s.' \
 % (float, type(depth))
 self._depth = depth
 def translate_rotate(self, translation: np.ndarray, angle: float):
 new_shape = self.shape.translate_rotate(translation,angle)
 self.shape = new_shape
 def contains_points(self, point_list: np.ndarray)-> List[bool]:
 """
 Checks if a list of points is enclosed in the shallow
 :param point_list: The list of points in the form [[px1,py1],[px2,py2,],...]
 :return: List of bools with True indicating point is enclosed and False otherwise
 """
 assert isinstance(point_list,
 ValidTypes.ARRAY), '<Shallow/contains_points>: provided list of points is not a list! type ' \
 '= {}'.format(type(point_list))
 res = list()
 for p in point_list:
 res.append(self.shape.contains_point(p))
 return res
 def get_obstacles(self, obstacles: List[Obstacle], time_step: int = 0) -> List[Obstacle]:
 """
 Returns the subset of obstacles, which are located in the water, of a given candidate set
 :param obstacles: The set of obstacle candidates
 :param time_step: The time step for the occupancy to check
 :return:
 """
 assert isinstance(obstacles, list) and all(isinstance(o, Obstacle) for o in
 obstacles), '<Shallow/get_obstacles>: Provided list of obstacles' \
 ' is malformed! obstacles = {}'.format(
 obstacles)
 res = list()
 for o in obstacles:
 o_shape = o.occupancy_at_time(time_step).shape
 vertices = list()
 if isinstance(o_shape, ShapeGroup):
 for sh in o_shape.shapes:
 if isinstance(sh, Circle):
 vertices.append(sh.center)
 else:
 vertices.append(sh.vertices)
 vertices = np.append(vertices, [o_shape.center], axis=0)
 else:
 if isinstance(o_shape, Circle):
 vertices = o_shape.center
 else:
 vertices = o_shape.vertices
 vertices = np.append(vertices, [o_shape.center], axis=0)
 if any(self.contains_points(np.array(vertices))):
 res.append(o)
 return res
class WatersNetwork:
 """
 Class which represents a network of connected waters (waterways and shallows)
 """
 def __init__(self, center_nav_area: np.ndarray, length_nav_area: float, width_nav_area: float, orientation_nav_area: float):
 self._waterways: Dict[int, Waterway] = {}
 self._shallows: Dict[int, Shallow] = {}
 self._traffic_signs: Dict[int, TrafficSign] = {}
 self._unassigned_traffic_signs: Dict[int, TrafficSign] = {}
 assert len(
 center_nav_area) == 2, '<Watersnetwork/center navigationable area> Error: dimensions do not fit. Got { } but 2 is expected'.format(
 len(center_nav_area))
 assert length_nav_area >= 0, '<Watersnetwork/length navigationable area> Error: negative length not allowed'
 assert width_nav_area >= 0, '<Watersnetwork/width navigationable area> Error: negative width not allowed'
 assert is_valid_orientation(
 orientation_nav_area), '<WatersNetwork/orientation navigationable area>: provided orientation is not valid! orientation = {}'.format(angle)
 self._navigationable_area = Rectangle(length_nav_area,width_nav_area,center_nav_area,orientation_nav_area)
 def __eq__(self, other):
 if not isinstance(other, WatersNetwork):
 warnings.warn(f"Inequality between WatersNetwork {repr(self)} and different type {type(other)}")
 return False
 list_elements_eq = True
 waters_network_eq = True
 elements = [self._waterways, self._traffic_signs, self._shallows]
 elements_other = [other._waterways, other._traffic_signs, other._shallows]
 for i in range(0, len(elements)):
 e = elements[i]
 e_other = elements_other[i]
 waters_network_eq = waters_network_eq and len(e) == len(e_other)
 for k in e.keys():
 if k not in e_other:
 waters_network_eq = False
 continue
 if e.get(k) != e_other.get(k):
 list_elements_eq = False
 if not waters_network_eq:
 warnings.warn(f"Inequality of WatersNetwork {repr(self)} and the other one {repr(other)}")
 return waters_network_eq and list_elements_eq
 def __hash__(self):
 return hash((frozenset(self._waterways.items()),
 frozenset(self._shallows.items()),
 frozenset(self._traffic_signs.items())))
 def __str__(self):
 return f"WatersNetwork consists of waterways {set(self._waterways.keys())}, " \
 f" shallows {set(self._shallows.keys())}, " \
 f" and traffic signs {set(self._traffic_signs.keys())}"
 def __repr__(self):
 return f"WatersNetwork(waterways={repr(self._waterways)}, shallows={repr(self._shallows)}, traffic_signs={repr(self._traffic_signs)}"
 @property
 def navigationable_area(self) -> Rectangle:
 return self._navigationable_area
 @navigationable_area.setter
 def navigationable_area(self, navigationable_area: Rectangle):
 warnings.warn('<WatersNetwork/navigationable area>: navigationable area of network are immutable')
 @property
 def waters(self) -> List[Waters]:
 return list(self._waterways.values()) + list(self._shallows.values())
 @property
 def waterways(self) -> List[Waters]:
 return list(self._waterways.values())
 @property
 def shallows(self) -> List[Waters]:
 return list(self._shallows.values())
 @waters.setter
 def waters(self, waters: list):
 warnings.warn('<WatersNetwork/waters>: waters of network are immutable')
 @waterways.setter
 def waterways(self, waters: list):
 warnings.warn('<WatersNetwork/waterways>: waterways of network are immutable')
 @shallows.setter
 def shallows(self, waters: list):
 warnings.warn('<WatersNetwork/shallows>: shallows of network are immutable')
 @property
 def traffic_signs(self) -> List[TrafficSign]:
 return list(self._traffic_signs.values())
 def find_waters_by_id(self, waters_id: int) -> Waters:
 """
 Finds a water (shallow or waterway) for a given waters_id
 :param waters_id: The id of the waterway to find
 :return: The waters object if the id exists and None otherwise
 """
 assert is_natural_number(
 waters_id), '<WatersNetwork/find_waters_by_id>: provided id is not valid! id = {}'.format(waters_id)
 res = self.find_waterway_by_id(waters_id)
 if res is None:
 return self.find_shallow_by_id(waters_id)
 else:
 return res
 def find_waterway_by_id(self, waters_id: int) -> Waters:
 """
 Finds a waterway for a given waters_id
 :param waters_id: The id of the waterway to find
 :return: The waterway object if the id exists and None otherwise
 """
 assert is_natural_number(
 waters_id), '<WatersNetwork/find_waterway_by_id>: provided id is not valid! id = {}'.format(waters_id)
 return self._waterways[waters_id] if waters_id in self._waterways else None
 def find_shallow_by_id(self, waters_id: int) -> Waters:
 """
 Finds a shallow for a given waters_id
 :param waters_id: The id of the shallow to find
 :return: The shallow object if the id exists and None otherwise
 """
 assert is_natural_number(
 waters_id), '<WatersNetwork/find_shallow_by_id>: provided id is not valid! id = {}'.format(waters_id)
 return self._shallows[waters_id] if waters_id in self._shallows else None
 def find_traffic_sign_by_id(self, traffic_sign_id: int) -> TrafficSign:
 """
 Finds a traffic sign for a given traffic_sign_id
 :param traffic_sign_id: The id of the traffic sign to find
 :return: The traffic sign object if the id exists and None otherwise
 """
 assert is_natural_number(
 traffic_sign_id), '<WatersNetwork/find_traffic_sign_by_id>: provided id is not valid! ' \
 'id = {}'.format(traffic_sign_id)
 return self._traffic_signs[traffic_sign_id] if traffic_sign_id in self._traffic_signs else None
 def add_waters(self, water: Waters):
 """
 Adds a waters (shallow and waterway) to the WatersNetwork
 :param water: The waters to add
 :return: True if the waters has successfully been added to the network, false otherwise
 """
 assert isinstance(water, Waters), '<WatersNetwork/add_waters>: provided water is not of ' \
 'type water! type = {}'.format(type(water))
 if isinstance(water, Shallow):
 if water.waters_id in self._shallows.keys():
 warnings.warn('Shallow already exists in network! No changes are made.')
 return False
 else:
 self._shallows[water.waters_id] = water
 return True
 elif isinstance(water, Waterway):
 if water.waters_id in self._waterways.keys():
 warnings.warn('Waters already exists in network! No changes are made.')
 return False
 else:
 self._waterways[water.waters_id] = water
 return True
 def add_traffic_sign(self, traffic_sign: TrafficSign, waters_ids: Union[None, Set[int]] = None):
 """
 Adds a traffic sign to the WatersNetwork
 :param traffic_sign: The traffic sign to add
 :param waters_ids: Waters the traffic sign should be referenced from
 :return: True if the traffic sign has successfully been added to the network, false otherwise
 """
 assert isinstance(traffic_sign, TrafficSign), '<WatersNetwork/add_traffic_sign>: provided traffic sign is ' \
 'not of type traffic_sign! type = {}'.format(type(traffic_sign))
 if traffic_sign.traffic_sign_id in self._traffic_signs.keys():
 warnings.warn('Traffic sign with ID {} already exists in network! '
 'No changes are made.'.format(traffic_sign.traffic_sign_id))
 return False
 else:
 self._traffic_signs[traffic_sign.traffic_sign_id] = traffic_sign
 if waters_ids is None or len(waters_ids) < 1:
 warnings.warn('Traffic sign was not referenced to water, use post_assign_traffic_sign to assign it later.')
 self._unassigned_traffic_signs[traffic_sign.traffic_sign_id] = traffic_sign
 else:
 for water_id in waters_ids:
 if water_id is not None:
 water = self.find_waterway_by_id(water_id)
 if water is not None:
 water.add_traffic_sign_to_water(traffic_sign.traffic_sign_id)
 else:
 warnings.warn('Traffic sign cannot be referenced to water because the water does not exist.')
 else:
 pass
 return True
 def post_assign_traffic_sign(self, traffic_sign_id: int, waters_ids: Set[int]):
 """
 Assign an unassigned traffic sign to the WatersNetwork
 :param traffic_sign_id: The traffic sign id to be assigned
 :param waters_ids: Waters the traffic sign should be referenced from
 :return: True if the traffic sign has successfully been added to the network, false otherwise
 """
 if traffic_sign_id not in self._traffic_signs.keys():
 warnings.warn('Traffic sign with ID {} does not exist in network! '
 'No changes are made.'.format(traffic_sign_id))
 return False
 elif traffic_sign_id not in self._unassigned_traffic_signs.keys():
 warnings.warn('Traffic sign with ID {} is already assigned to a Water in network! '
 'No changes are made.'.format(traffic_sign_id))
 return False
 else:
 assigned = False
 for water_id in waters_ids:
 water = self.find_waterway_by_id(water_id)
 if water is not None:
 water.add_traffic_sign_to_water(traffic_sign_id)
 assigned = True
 else:
 warnings.warn('Traffic sign cannot be referenced to water because the water does not exist.')
 if assigned:
 del self._unassigned_traffic_signs[traffic_sign_id]
 return True
 def add_waters_from_network(self, waters_network: 'WatersNetwork'):
 """
 Adds waters from a given network object to the current network
 :param waters_network: The water network
 :return: True if all waters have been added to the network, false otherwise
 """
 flag = True
 for f in waters_network.waters:
 flag = flag and self.add_waters(f)
 return flag
 def remove_waters(self, waters_id: int):
 """
 Removes waters from a waters network and deletes all references.
 @param waters_id: ID of waters which should be removed.
 """
 if waters_id in self._waterways.keys():
 del self._waterways[waters_id]
 if waters_id in self._shallows.keys():
 del self._shallows[waters_id]
 def remove_traffic_sign(self, traffic_sign_id: int):
 """
 Removes a traffic sign from a waters network and deletes all references.
 @param traffic_sign_id: ID of traffic sign which should be removed.
 """
 if traffic_sign_id in self._traffic_signs.keys():
 del self._traffic_signs[traffic_sign_id]
 def translate_rotate(self, translation: np.ndarray, angle: float):
 """
 Translates and rotates the complete waters network
 :param translation: The translation given as [x_off,y_off] for the x and y translation
 :param angle: The rotation angle in radian (counter-clockwise defined)
 """
 assert is_real_number_vector(translation,
 2), '<WatersNetwork/translate_rotate>: provided translation is not valid! ' \
 'translation = {}'.format(translation)
 assert is_valid_orientation(
 angle), '<WatersNetwork/translate_rotate>: provided angle is not valid! angle = {}'.format(angle)
 nav_area_new = self._navigationable_area.translate_rotate(translation,angle)
 self._navigationable_area = nav_area_new
 for waterway in self._waterways.values():
 waterway.translate_rotate(translation, angle)
 for shallow in self._shallows.values():
 shallow.translate_rotate(translation, angle)
 for traffic_sign in self._traffic_signs.values():
 traffic_sign.translate_rotate(translation, angle)
 def find_waterway_by_position(self, point_list: List[np.ndarray]) -> List[List[int]]:
 """
 Finds the waterway id of a given position
 :param point_list: The list of positions to check
 :return: A list of water ids. If the position could not be matched to a water, an empty list is returned
 """
 assert isinstance(point_list,
 ValidTypes.LISTS), '<waterways/contains_points>: provided list of points is not a list! ' \
 'type = {}'.format(type(point_list))
 res = list()
 polygons = [(f.waters_id, f.convert_to_polygon()) for f in self.waterways]
 for point in point_list:
 mapped = list()
 for waters_id, poly in polygons:
 if poly.contains_point(point):
 mapped.append(waters_id)
 res.append(mapped)
 return res
 def find_waterway_by_shape(self, shape: Shape) -> List[int]:
 """
 Finds the waterway id of a given shape
 :param shape: The shape to check
 :return: A list of water ids. If the position could not be matched to a water, an empty list is returned
 """
 assert isinstance(shape, (Circle, Polygon, Rectangle)), '<Waters/find_water_by_shape>: ' \
 'provided shape is not a shape! ' \
 'type = {}'.format(type(shape))
 res = []
 polygons = [(l.waters_id, l.convert_to_polygon()) for l in self.waterways]
 for waters_id, poly in polygons:
 if poly.shapely_object.intersects(shape.shapely_object):
 res.append(waters_id)
 return res
 def filter_obstacles_in_network(self, obstacles: List[Obstacle]) -> List[Obstacle]:
 """
 Returns the list of obstacles which are located in the water network
 :param obstacles: The list of obstacles to check
 :return: The list of obstacles which are located in the water network
 """
 res = list()
 map = self.map_obstacles_to_waters(obstacles)
 for k in map.keys():
 obs = map[k]
 for o in obs:
 if o not in res:
 res.append(o)
 return res
 def map_obstacles_to_waters(self, obstacles: List[Obstacle]) -> Dict[int, List[Obstacle]]:
 """
 Maps a given list of obstacles to the waters of the water network
 :param obstacles: The list of CR obstacles
 :return: A dictionary with the water id as key and the list of obstacles on the water as a List[Obstacles]
 """
 mapping = {}
 for f in self.waters:
 mapped_objs = f.get_obstacles(obstacles)
 if len(mapped_objs) > 0:
 mapping[f.waters_id] = mapped_objs
 return mapping
 def waterways_in_proximity(self, point: list, radius: float) -> List[Waters]:
 """
 Finds all waterways which intersect a given circle, defined by the center point and radius
 :param point: The center of the circle
 :param radius: The radius of the circle
 :return: The list of waters which intersect the given circle
 """
 assert is_real_number_vector(point,
 length=2), '<WatersNetwork/waters_in_proximity>: provided point is ' \
 'not valid! point = {}'.format(point)
 assert is_positive(
 radius), '<WatersNetwork/waters_in_proximity>: provided radius is not valid! radius = {}'.format(radius)
 ids = self._waterways.keys()
 lanes = dict()
 rad_sqr = radius ** 2
 distance_list = list()
 for i in ids:
 if i not in lanes:
 water = self.find_waterway_by_id(i)
 distance = (water.center_vertices - point) ** 2.
 distance = distance[:, 0] + distance[:, 1]
 if any(np.greater_equal(rad_sqr, distance)):
 lanes[i] = self.find_waterway_by_id(i)
 distance_list.append(np.min(distance))
 index_minDist = np.argmin(distance - rad_sqr)
 indices = np.argsort(distance_list)
 water = list(lanes.values())
 return [water[i] for i in indices]
 def shallow_depth_for_positions(self, positions: List[np.ndarray]) -> List:
 """
 This function returns the shallow depth for positions
 :param positions: List of positions where each position is a 2D ndarray
 :return: List with the respective depths of the positions of the input list
 """
 depths = []
 for position in positions:
 is_infinite = True
 for shallow in self.shallows:
 if shallow.contains_points(np.array([position]))[0]:
 depths.append(shallow.depth)
 is_infinite = False
 break
 if is_infinite:
 depths.append(np.inf)
 return depths
</src\commonocean\scenario\waters.py>

<src\commonocean\visualization\draw_dispatch_cr.py>
import sys
from typing import Dict, Callable, Tuple, Any, List
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import commonocean
from commonroad.geometry.shape import *
from commonocean.planning.planning_problem import GoalRegion, PlanningProblemSet, PlanningProblem
from commonocean.scenario.waters import WatersNetwork, Waters, Shallow
from commonocean.scenario.obstacle import *
from commonocean.scenario.scenario import Scenario
from commonocean.scenario.traffic_sign import TrafficSign
from commonocean.scenario.trajectory import Trajectory
from commonroad.scenario.state import CustomState
import commonocean.visualization.scenario
import commonocean.visualization.planning
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
def _create_drawers_dict() -> Dict[type, Callable]:
 """
 Creates default dict of drawer functions, which are later called for draw objects depending on their class
 :return: dict containing the drawer functions
 """
 draw_func = {}
 if 'commonocean.visualization.scenario' in sys.modules.keys():
 draw_func.update(commonocean.visualization.scenario.draw_func_dict)
 if 'commonocean.visualization.planning' in sys.modules.keys():
 draw_func.update(commonocean.visualization.planning.draw_func_dict)
 return draw_func
def _create_default_draw_params() -> dict:
 """
 Creates default settings for drawing objects
 :return: nested dict, containing the settings
 """
 draw_params = {'time_begin': 0, 'time_end': 200, 'antialiased': True}
 if 'commonocean.visualization.scenario' in sys.modules.keys():
 draw_params.update(
 commonocean.visualization.scenario.create_default_draw_params())
 if 'commonocean.visualization.planning' in sys.modules.keys():
 draw_params.update(
 commonocean.visualization.planning.create_default_draw_params())
 return draw_params
default_draw_params = _create_default_draw_params()
def _retrieve_value_by_path(style_sheet_caller: dict, value_path: Tuple[str, ...]):
 """
 Retrieves value corresponding to value path from the nested dict style_sheet.
 :param style_sheet_caller: parameters for plotting given by a nested dict
 :param value_path: string tuple that contains the path to the value
 :return: the value from style_sheet defined by value_path
 """
 c_dict = style_sheet_caller
 for value_element in value_path[:-1]:
 try:
 c_dict = c_dict[value_element]
 except KeyError:
 raise KeyError()
 try:
 return_value = c_dict[value_path[-1]]
 except KeyError:
 raise KeyError()
 return return_value
def _retrieve_value(style_sheet: dict, call_stack: tuple, value_path: Tuple[str, ...]):
 """
 Retrieves value corresponding to value_path from the nested dict style_sheet. If value_path not contained in
 style_sheet, try to retrieve from default draw_params.
 Starts by searching for value_path beginning at first element in call stack, stepping down all frames
 :param style_sheet: parameters for plotting given by a nested dict
 :param call_stack: tuple of string containing the call stack
 :param value_path: string tuple that contains the path to the value
 :return: the value from style_sheet defined by value_path and call_stack
 """
 for idx_r in range(0, len(call_stack)):
 style_sheet_caller = style_sheet
 try:
 for idx in range(0, len(call_stack) - idx_r):
 style_sheet_caller = style_sheet_caller[call_stack[idx]]
 try:
 value = _retrieve_value_by_path(style_sheet_caller, value_path)
 return value
 except KeyError:
 pass
 except KeyError:
 continue
 try:
 value = _retrieve_value_by_path(style_sheet, value_path)
 return value
 except KeyError:
 pass
 for idx_r in range(0, len(call_stack)):
 style_sheet_caller = default_draw_params
 try:
 for idx in range(0, len(call_stack) - idx_r):
 style_sheet_caller = style_sheet_caller[call_stack[idx]]
 try:
 value = _retrieve_value_by_path(style_sheet_caller, value_path)
 return value
 except KeyError:
 pass
 except KeyError:
 continue
 try:
 value = _retrieve_value_by_path(default_draw_params, value_path)
 return value
 except KeyError:
 pass
 try:
 value
 except NameError:
 raise KeyError
 return value
def _retrieve_alternate_value(style_sheet: dict, call_stack: Tuple[str, ...], value_path_1: Tuple[str, ...],
 value_path_2: Tuple[str, ...]) -> Any:
 """
 Like retrieve_value(...), but retrieves value from value_path_2 if value_path_1 does not exist in style_sheet
 :param style_sheet: parameters for plotting given by a nested dict (see draw_params in draw_object)
 :param call_stack: tuple of string containing the call stack
 :param value_path_1: string tuple that contains the path to the value
 :param value_path_2: alternate value_path
 :return: the value from style_sheet defined by value_path_1 (or value_path_2)
 """
 for idx_r in range(0, len(call_stack)):
 style_sheet_caller = style_sheet
 try:
 for idx in range(0, len(call_stack) - idx_r):
 style_sheet_caller = style_sheet_caller[call_stack[idx]]
 try:
 value = _retrieve_value_by_path(style_sheet_caller, value_path_1)
 return value
 except KeyError:
 pass
 except KeyError:
 continue
 for idx_r in range(0, len(call_stack)):
 style_sheet_caller = style_sheet
 try:
 for idx in range(0, len(call_stack) - idx_r):
 style_sheet_caller = style_sheet_caller[call_stack[idx]]
 try:
 value = _retrieve_value_by_path(style_sheet_caller, value_path_2)
 return value
 except KeyError:
 pass
 except KeyError:
 continue
 try:
 value = _retrieve_value_by_path(style_sheet, value_path_1)
 return value
 except KeyError:
 pass
 try:
 value = _retrieve_value_by_path(style_sheet, value_path_2)
 return value
 except KeyError:
 pass
 try:
 value = _retrieve_value_by_path(default_draw_params, call_stack + value_path_1)
 return value
 except KeyError:
 pass
 try:
 value = _retrieve_value_by_path(default_draw_params, call_stack + value_path_2)
 return value
 except KeyError:
 pass
 try:
 value = _retrieve_value_by_path(default_draw_params, value_path_1)
 return value
 except KeyError:
 pass
 try:
 value = _retrieve_value_by_path(default_draw_params, value_path_2)
 return value
 except KeyError:
 pass
 try:
 value
 except NameError:
 raise KeyError
 return value
def _add_legend(legend: Dict[Tuple[str, ...], str], draw_params):
 """
 Adds legend with color of objects specified by legend.keys() and texts specified by legend.values().
 :param legend: color of objects specified by path in legend.keys() and texts specified by legend.values()
 :param draw_params: draw parameters used for plotting (color is extracted using path in legend.keys())
 :return:
 """
 handles = []
 for obj_name, text in legend.items():
 try:
 color = _retrieve_value(draw_params, (), obj_name)
 except:
 color = None
 if color is not None:
 handles.append(mpatches.Patch(color=color, label=text))
 l = plt.legend(handles=handles)
 l.set_zorder(1000)
plottable_types = Union[list, Scenario, Trajectory, WatersNetwork, Waters, Obstacle, Shape,
 GoalRegion, PlanningProblem, PlanningProblemSet, GeneralState, Occupancy, TrafficSign]
def draw_object(obj: Union[plottable_types, List[plottable_types]],
 plot_limits: Union[List[Union[float, int]], None] = None,
 ax: Union[None, mpl.axes.Axes] = None,
 draw_params: Union[None, dict] = None,
 draw_func: Union[None, Dict[type, Callable]] = None,
 handles: Dict[int, List[mpl.patches.Patch]] = None,
 call_stack: Union[None, Tuple[str, ...]] = None,
 legend: Union[Dict[Tuple[str, ...], str], None] = None) -> Union[None, List[mpl.patches.Patch]]:
 """
 Main function for drawing objects from the scenario and planning modules.
 :param obj: the object or list of objects (with all the same type) to be plotted
 :param plot_limits: list of [x_min, x_max, y_min, y_max that defines the plotted area of the scenario
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 see documentation for full overview over the structure. If parameters are not set,
 the default setting are used. An example for specifying the color of circle obstacles:
 {'scenario': {'static_obstacle':{'shape':{'circle':{'facecolor':#3399ff, edgecolor': '#0066cc'}}}}}
 :param draw_func: specify the drawing function (usually not necessary to change default)
 :param handles: dict that assign to every object_id of all plotted obstacles the corresponding patch handles
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object, (usually 'None'!)
 :param legend: names of objects that should appear in the legend
 :return: Returns matplotlib patch object for draw_funcs that actually draw a patch (used internally for creating handles dict)
 """
 assert isinstance(draw_params, dict) or draw_params is None, '<visualization/draw_dispatch_cr/draw_object>:' \
 'draw_params must be either a (nested) dictionary contating the plotting parameters' \
 'or None (for default parameters)'
 assert isinstance(plot_limits,
 (list, np.ndarray)) or plot_limits is None, '<visualization/draw_dispatch_cr/draw_object>:' \
 'plot_limits must be a list of [x_min, x_max, y_min, y_max]' \
 'or None'
 assert isinstance(call_stack, tuple) or call_stack is None
 if handles is None:
 handles = dict()
 if ax is None:
 ax = plt.gca()
 if plot_limits is not None:
 assert np.less(plot_limits[0], plot_limits[1]) and np.less(plot_limits[2], plot_limits[3]), \
 '<draw_dispatch_cr/draw_object>: position limits need to be given by [x_min, x_max, y_min, y_max]'
 ax.set_xlim(plot_limits[0], plot_limits[1])
 ax.set_ylim(plot_limits[2], plot_limits[3])
 if draw_func is None:
 draw_func = _create_drawers_dict()
 if draw_params is None:
 draw_params = _create_default_draw_params()
 if call_stack is None:
 call_stack = tuple()
 if legend is not None:
 _add_legend(legend, draw_params)
 if type(obj) is list:
 if len(obj) == 0:
 return []
 elif isinstance(obj[0], (DynamicObstacle, Trajectory, Rectangle, Waters, Circle, Shallow)):
 patch_list = draw_func[type(obj[0])](obj, plot_limits, ax, draw_params, draw_func, handles, call_stack)
 return patch_list
 else:
 patch_list = list()
 for o in obj:
 patch_list_tmp = draw_object(o, None, ax, draw_params, draw_func, handles, call_stack)
 if patch_list_tmp is not None:
 patch_list.extend(patch_list_tmp)
 return patch_list
 if type(obj) in draw_func.keys():
 patch_list = draw_func[type(obj)](obj, plot_limits, ax, draw_params, draw_func, handles, call_stack)
 return patch_list
 else:
 for obj_type, func in draw_func.items():
 if isinstance(obj, obj_type):
 patch_list = func(obj, plot_limits, ax, draw_params, draw_func, handles, call_stack)
 return patch_list
 warnings.warn("Cannot dispatch to plot " + str(type(obj)))
</src\commonocean\visualization\draw_dispatch_cr.py>

<src\commonocean\visualization\planning.py>
import math
import commonocean.visualization.draw_dispatch_cr
import commonocean.planning.planning_problem
import commonocean.visualization.draw_dispatch_cr
from commonocean.planning.planning_problem import PlanningProblemSet, PlanningProblem, GoalRegion
from commonroad.scenario.state import CustomState
import matplotlib as mpl
from typing import Union, List, Dict, Callable, Tuple
import commonocean as commonocean
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
def create_default_draw_params():
 draw_params_noparent = {'initial_state': {
 'facecolor': '#000080',
 'zorder': 25,
 'label': '', # text for labeling this state, i.r. 'initial position'
 'draw_initial_state': True, # visualize initial state by arrow proportional to velocity
 'scale_factor': 0.3, # length of arrow in m per m/s
 'kwargs': {
 'linewidth': 1.5,
 'length_includes_head': True,
 'edgecolor': 'black',
 'facecolor': 'black',
 }
 },
 'goal_region': {'draw_shape': True,
 'shape': {
 'polygon': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'rectangle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'circle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 }},
 'water': {'left_bound_color': '#555555',
 'right_bound_color': '#555555',
 'center_bound_color': '#dddddd',
 'draw_left_bound': True,
 'draw_right_bound': True,
 'draw_center_bound': True,
 'draw_border_vertices': False,
 'draw_start_and_direction': True,
 'show_label': False,
 'draw_linewidth': 0.5,
 'fill_lanelet': True,
 'facecolor': '#c7c7c7'
 }
 }
 }
 draw_params = {'draw_ids': 'all', # either 'all' or list of problem ids
 'initial_state': {'facecolor': '#000080',
 'zorder': 25,
 'label': ''}, # text for labeling this state, i.r. 'initial position'
 'goal_region': {'draw_shape': True,
 'shape': {
 'polygon': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'rectangle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'circle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 }},
 'water': {'left_bound_color': '#555555',
 'right_bound_color': '#555555',
 'center_bound_color': '#dddddd',
 'draw_left_bound': True,
 'draw_right_bound': True,
 'draw_center_bound': True,
 'draw_border_vertices': False,
 'draw_start_and_direction': True,
 'show_label': False,
 'draw_linewidth': 0.5,
 'fill_lanelet': True,
 'facecolor': '#c7c7c7'}
 },
 'planning_problem': {
 'initial_state': {'facecolor': '#000080',
 'zorder': 25,
 'label': ''}, # text for labeling this state, i.r. 'initial position'
 'goal_region': {'draw_shape': True,
 'shape': {
 'polygon': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'rectangle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 },
 'circle': {
 'opacity': 1.0,
 'linewidth': 0.5,
 'facecolor': '#f1b514',
 'edgecolor': '#302404',
 'zorder': 15,
 }},
 'water': {'left_bound_color': '#555555',
 'right_bound_color': '#555555',
 'center_bound_color': '#dddddd',
 'draw_left_bound': True,
 'draw_right_bound': True,
 'draw_center_bound': True,
 'draw_border_vertices': False,
 'draw_start_and_direction': True,
 'show_label': False,
 'draw_linewidth': 0.5,
 'fill_lanelet': True,
 'facecolor': '#c7c7c7'}
 }
 }
 }
 draw_params_noparent.update({'planning_problem_set': draw_params})
 draw_params_noparent['planning_problem'] = draw_params_noparent['planning_problem_set']['planning_problem']
 return draw_params_noparent
def draw_planning_problem_set(obj: PlanningProblemSet, plot_limits: List[Union[int, float]], ax: mpl.axes.Axes,
 draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 call_stack = tuple(list(call_stack) + ['planning_problem_set'])
 try:
 draw_ids = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['draw_ids']))
 except KeyError:
 print("Cannot find stylesheet for planning_problem. Called through:")
 print(call_stack)
 for id, problem in obj.planning_problem_dict.items():
 if draw_ids is 'all' or id in draw_ids:
 draw_planning_problem(problem, plot_limits, ax, draw_params, draw_func, handles, call_stack)
def draw_planning_problem(obj: PlanningProblem, plot_limits: List[Union[int, float]], ax: mpl.axes.Axes,
 draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 call_stack = tuple(list(call_stack) + ['planning_problem'])
 if not 'initial_state' in draw_params:
 draw_params['initial_state'] = {}
 draw_params['initial_state']['label'] = 'initial position'
 draw_initital_state(obj.initial_state, plot_limits, ax, draw_params, draw_func, handles, call_stack)
 draw_goal_region(obj.goal, plot_limits, ax, draw_params, draw_func, handles, call_stack)
def draw_initital_state(obj: CustomState, plot_limits: List[Union[int, float]], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable], handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 try:
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'facecolor'))
 zorder = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'zorder'))
 label = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'label'))
 draw_initial_state = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'draw_initial_state'))
 scale_factor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'scale_factor'))
 arrow_args = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', "kwargs"))
 except KeyError:
 print("Cannot find stylesheet for state. Called through:")
 print(call_stack)
 facecolor = '#f1b514'
 zorder = 20
 label = 'intial position'
 draw_initial_state = True
 scale_factor = 0.0
 arrow_args = {
 'linewidth': 1.5,
 'length_includes_head': True,
 'edgecolor': 'black',
 'facecolor': 'black',
 }
 x = math.cos(obj.orientation)
 y = math.sin(obj.orientation)
 ax.plot(obj.position[0], obj.position[1], 'o', color=facecolor, zorder=zorder, markersize=3)
 if draw_initial_state:
 ax.arrow(x=obj.position[0], y=obj.position[1],
 dx=x * scale_factor,
 dy=y * scale_factor,
 zorder=100,
 **arrow_args)
 ax.annotate(label, xy=(obj.position[0] + 1, obj.position[1]),
 textcoords='data', zorder=zorder + 10)
def draw_goal_region(obj: GoalRegion, plot_limits: List[Union[int, float]], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable], handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if call_stack is ():
 call_stack = tuple(['planning_problem_set'])
 call_stack = tuple(list(call_stack) + ['goal_region'])
 for goal_state in obj.state_list:
 draw_goal_state(goal_state, plot_limits, ax, draw_params, draw_func, handles, call_stack)
def draw_goal_state(obj: CustomState, plot_limits: List[Union[int, float]], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable], handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if hasattr(obj, 'position'):
 if type(obj.position) == list:
 for pos in obj.position:
 commonocean.visualization.draw_dispatch_cr.draw_object(pos, plot_limits, ax, draw_params,
 draw_func, handles, call_stack)
 else:
 commonocean.visualization.draw_dispatch_cr.draw_object(obj.position, plot_limits, ax, draw_params,
 draw_func, handles, call_stack)
draw_func_dict = {commonocean.planning.planning_problem.GoalRegion: draw_goal_region,
 commonocean.planning.planning_problem.PlanningProblem: draw_planning_problem,
 commonocean.planning.planning_problem.PlanningProblemSet: draw_planning_problem_set,
 CustomState: draw_initital_state}
</src\commonocean\visualization\planning.py>

<src\commonocean\visualization\scenario.py>
import math
from typing import Dict, Callable, Tuple, Union, Any, Set, List
import commonroad.prediction.prediction
import commonroad.geometry.shape
import commonroad.scenario.trajectory
import matplotlib as mpl
import matplotlib.cm as cm
import matplotlib.patches as patches
import matplotlib.collections as collections
from matplotlib.path import Path
import commonocean as commonocean
import commonroad.prediction.prediction
import commonocean.scenario.obstacle
import commonocean.scenario.waters
from commonocean.visualization import draw_dispatch_cr
from commonroad.common.util import Interval
from commonocean.scenario.traffic_sign import TrafficSign
from commonroad.prediction.prediction import Occupancy
from commonocean.scenario.waters import WatersNetwork, Waterway
from commonocean.scenario.obstacle import DynamicObstacle, StaticObstacle, ObstacleRole
from commonocean.scenario.scenario import Scenario
from commonocean.scenario.trajectory import Trajectory
from commonroad.scenario.state import CustomState
from commonocean.scenario.waters import Shallow
from commonocean.visualization.util import draw_polygon_as_patch, draw_polygon_collection_as_patch, LineDataUnits
from commonocean.visualization.traffic_sign import draw_traffic_light_signs
import commonroad
from commonroad.geometry.shape import *
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
def create_default_draw_params() -> dict:
 basic_shape_parameters_static = {'opacity': 1.0,
 'facecolor': '#F6DC7E',
 'edgecolor': '#F6DC7E',
 'linewidth': 0.5,
 'zorder': 20}
 basic_shape_parameters_dynamic = {'opacity': 1.0,
 'facecolor': '#000000',
 'edgecolor': '#000000',
 'linewidth': 0.5,
 'zorder': 20}
 basic_shape_parameters_shallow = {'opacity': 0.5,
 'facecolor': '#004eb8',
 'edgecolor': '#000000',
 'linewidth': 0.5,
 'zorder': 20}
 draw_params = {'scenario': {
 'dynamic_obstacle': {
 'draw_shape': True,
 'draw_icon': False,
 'draw_bounding_box': True,
 'show_label': False,
 'zorder': 20,
 'draw_signals': True,
 'signal_radius': 0.5,
 'indicator_color': '#ebc200',
 'braking_color': 'red',
 'blue_lights_color': 'blue',
 'horn_color': 'red',
 'initial_state': {
 'draw_initial_state': True,
 'scale_factor': 0.3,
 'kwargs': {
 'linewidth': 1.5,
 'length_includes_head': True,
 'edgecolor': 'black',
 'facecolor': 'black',
 },
 },
 'occupancy': {
 'draw_occupancies': 0,
 'shape': {
 'polygon': {
 'opacity': 0.2,
 'facecolor': '#1d7eea',
 'edgecolor': '#0066cc',
 'linewidth': 0.5,
 'zorder': 18,
 },
 'rectangle': {
 'opacity': 0.2,
 'facecolor': '#000000',
 'edgecolor': '#000000',
 'linewidth': 0.5,
 'zorder': 18,
 },
 'circle': {
 'opacity': 0.2,
 'facecolor': '#1d7eea',
 'edgecolor': '#0066cc',
 'linewidth': 0.5,
 'zorder': 18,
 }
 },
 },
 'shape': {
 'polygon': basic_shape_parameters_dynamic,
 'rectangle': basic_shape_parameters_dynamic,
 'circle': basic_shape_parameters_dynamic
 },
 'trajectory': {'draw_trajectory': True,
 'facecolor': '#000000',
 'draw_continuous': False,
 'unique_colors': False,
 'line_width': 0.17,
 'z_order': 24}
 },
 'static_obstacle': {
 'shape': {
 'polygon': basic_shape_parameters_static,
 'rectangle': basic_shape_parameters_static,
 'circle': basic_shape_parameters_static,
 }
 },
 'shallow': {
 'shape': {
 'polygon': basic_shape_parameters_shallow,
 'rectangle': basic_shape_parameters_shallow,
 'circle': basic_shape_parameters_shallow,
 }
 },
 'waters_network': {
 'kwargs_traffic_light_signs': {},
 'traffic_sign': {'draw_traffic_signs': True,
 'show_traffic_signs': 'all',
 'speed_limit_unit': 'auto',
 'show_label': False,
 'scale_factor': 0.15,
 'zorder': 30},
 'water': {'left_bound_color': '#555555',
 'right_bound_color': '#555555',
 'center_bound_color': '#dddddd',
 'unique_colors': False,
 'draw_stop_line': True,
 'stop_line_color': '#ffffff',
 'draw_left_bound': True,
 'draw_right_bound': True,
 'draw_center_bound': True,
 'draw_border_vertices': False,
 'draw_start_and_direction': False,
 'show_label': False,
 'draw_linewidth': 0.5,
 'fill_lanelet': True,
 'facecolor': '#ffffff'}
 },
 }
 }
 draw_params.update(draw_params['scenario'])
 draw_params['shape'] = basic_shape_parameters_static
 draw_params['shape'].update(draw_params['scenario']['static_obstacle']['shape'])
 draw_params['occupancy'] = draw_params['scenario']['dynamic_obstacle']['occupancy']
 draw_params['static_obstacle'] = draw_params['scenario']['static_obstacle']
 draw_params['dynamic_obstacle'] = draw_params['scenario']['dynamic_obstacle']
 draw_params['trajectory'] = draw_params['scenario']['dynamic_obstacle']['trajectory']
 draw_params['waters_network'] = draw_params['scenario']['waters_network']
 draw_params['water'] = draw_params['scenario']['waters_network']['water']
 draw_params['traffic_sign'] = draw_params['scenario']['waters_network']['traffic_sign']
 draw_params['scenario']['water'] = draw_params['scenario']['waters_network']['water']
 return draw_params
def draw_scenario(obj: Scenario, plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes,
 draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param plot_limits: draw only objects inside limits [x_ min, x_max, y_min, y_max]
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 call_stack = tuple(list(call_stack) + ['scenario'])
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj._waters_network, plot_limits, ax, draw_params, draw_func, handles, call_stack)
 if plot_limits is not None:
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(), ('time_begin',))
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj.obstacles_by_position_intervals([Interval(plot_limits[0], plot_limits[1]),
 Interval(plot_limits[2], plot_limits[3])],
 tuple([ObstacleRole.DYNAMIC]), time_begin),
 None, ax, draw_params, draw_func, handles, call_stack)
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj.obstacles_by_position_intervals([Interval(plot_limits[0], plot_limits[1]),
 Interval(plot_limits[2], plot_limits[3])],
 tuple([ObstacleRole.STATIC])),
 None, ax, draw_params, draw_func, handles, call_stack)
 else:
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj.dynamic_obstacles, None, ax, draw_params, draw_func,
 handles, call_stack)
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj.static_obstacles, None, ax, draw_params, draw_func,
 handles, call_stack)
 commonocean.visualization.draw_dispatch_cr.draw_object(
 obj.shallows, None, ax, draw_params, draw_func, handles, call_stack)
def draw_static_obstacles(obj: Union[List[StaticObstacle], StaticObstacle],
 plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(), ('time_begin',))
 if type(obj) is StaticObstacle:
 obj = [obj]
 call_stack = tuple(list(call_stack) + ['static_obstacle'])
 shape_list = list()
 for obstacle in obj:
 if type(obstacle) is not StaticObstacle:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 continue
 shape_list.append(obstacle.occupancy_at_time(time_begin).shape)
 collection = shape_batch_dispatcher(shape_list, None, ax, draw_params, draw_func, handles, call_stack)
 handles.setdefault(StaticObstacle, []).extend(collection)
def draw_trajectories(obj: Union[List[Trajectory], Trajectory], plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) \
 -> List[mpl.collections.Collection]:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if type(obj) is Trajectory:
 obj = [obj]
 try:
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('trajectory', 'facecolor'))
 unique_colors = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('trajectory', 'unique_colors'))
 line_width = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('trajectory', 'line_width'))
 draw_continuous = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('trajectory', 'draw_continuous'))
 z_order = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('trajectory', 'z_order'))
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('time_begin',))
 time_end = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, tuple(['time_end']))
 except KeyError:
 print("Cannot find stylesheet for trajectory. Called through:")
 print(call_stack)
 if time_begin == time_end:
 return []
 colormap = None
 if unique_colors is True:
 norm = mpl.colors.Normalize(vmin=0, vmax=len(obj))
 colormap = cm.ScalarMappable(norm=norm, cmap=cm.brg)
 traj_list = list()
 for traj in obj:
 traj_points = list()
 for time_step in range(time_begin, time_end):
 tmp = traj.state_at_time_step(time_step)
 if tmp is not None:
 traj_points.append(tmp.position)
 else:
 if time_begin > traj.initial_time_step:
 break
 if traj_points:
 traj_list.append(traj_points)
 if len(traj_list) > 0:
 if draw_continuous is True:
 paths = []
 for traj in traj_list:
 paths.append(Path(traj, closed=False))
 if unique_colors is True:
 collection = []
 for i_p, path in enumerate(paths):
 facecolor = colormap.to_rgba(i_p)
 collection.append(collections.PathCollection([path], color=facecolor, lw=line_width, zorder=z_order,
 facecolor='none'))
 ax.add_collection(collection[-1])
 else:
 collection = [
 collections.PathCollection(paths, color=facecolor, lw=line_width, zorder=z_order, facecolor='none')]
 else:
 if unique_colors is True:
 collection = []
 for i_p, traj in enumerate(traj_list):
 facecolor = colormap.to_rgba(i_p)
 traj = np.array(traj)
 collection.append(collections.EllipseCollection(np.ones([traj.shape[0], 1]) * line_width,
 np.ones([traj.shape[0], 1]) * line_width,
 np.zeros([traj.shape[0], 1]),
 offsets=traj,
 units='xy',
 linewidths=0,
 zorder=z_order, transOffset=ax.transData,
 facecolor=facecolor))
 ax.add_collection(collection[-1])
 else:
 try:
 traj_list = np.array(np.concatenate(traj_list))
 except:
 dsdf = 0
 collection = [collections.EllipseCollection(np.ones([traj_list.shape[0], 1]) * line_width,
 np.ones([traj_list.shape[0], 1]) * line_width,
 np.zeros([traj_list.shape[0], 1]),
 offsets=traj_list,
 units='xy',
 linewidths=0,
 zorder=z_order, transOffset=ax.transData,
 facecolor=facecolor)]
 if draw_continuous is False:
 ax.add_collection(collection[0])
 else:
 collection = []
 return collection
def draw_fairway_network(obj: WatersNetwork, plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 call_stack = tuple(list(call_stack) + ['waters_network'])
 _draw_fairways_intersection(
 obj, obj._traffic_signs, None, ax, draw_params, draw_func, handles, call_stack)
def draw_fairway_list(obj: List[Waterway], plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> None:
 """
 Draws list of waters.
 """
 if isinstance(obj, Waterway):
 obj = [obj]
 _draw_fairways_intersection(WatersNetwork.create_from_waters_list(obj), None, plot_limits, ax,
 draw_params, draw_func, handles,
 call_stack)
def _draw_fairways_intersection(obj: WatersNetwork,
 traffic_signs: Union[Dict[int, TrafficSign], None],
 plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 fairways = obj.waterways
 try:
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack, ('time_begin',))
 if traffic_signs is not None:
 draw_traffic_signs = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('waters_network', 'traffic_sign', 'draw_traffic_signs'))
 show_traffic_sign_label = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('waters_network', 'traffic_sign', 'show_label'))
 else:
 draw_traffic_signs = show_traffic_sign_label = False
 draw_intersections = False
 draw_incoming_lanelets = draw_crossings = draw_successors = show_intersection_labels = False
 left_bound_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'left_bound_color'))
 right_bound_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'right_bound_color'))
 center_bound_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'center_bound_color'))
 unique_colors = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'unique_colors'))
 draw_stop_line = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_stop_line'))
 stop_line_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'stop_line_color'))
 show_label = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'show_label'))
 draw_border_vertices = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_border_vertices'))
 draw_left_bound = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_left_bound'))
 draw_right_bound = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_right_bound'))
 draw_center_bound = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_center_bound'))
 draw_start_and_direction = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_start_and_direction'))
 draw_linewidth = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'draw_linewidth'))
 fill_lanelet = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'fill_lanelet'))
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('water', 'facecolor'))
 antialiased = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(),
 tuple(['antialiased']))
 except KeyError:
 print("Cannot find stylesheet for water. Called through:")
 print(call_stack)
 incoming_lanelets = set()
 incomings_left = {}
 incomings_id = {}
 crossings = set()
 all_successors = set()
 successors_left = set()
 successors_straight = set()
 successors_right = set()
 codes_direction = [Path.MOVETO,
 Path.LINETO,
 Path.LINETO,
 Path.CLOSEPOLY]
 scale_direction = 1.5
 pts = np.array([[0.0, -0.5, 1.0],
 [1.0, 0.0, 1.0],
 [0.0, 0.5, 1.0],
 [0.0, -0.5, 1.0]])
 scale_m = np.array([[scale_direction, 0, 0],
 [0, scale_direction, 0],
 [0, 0, 1]])
 def direction(x, y, angle):
 """Returns path of arrow shape"""
 transform = np.array([[np.cos(angle), -np.sin(angle), x],
 [np.sin(angle), np.cos(angle), y],
 [0, 0, 1]])
 ptr_trans = transform.dot(scale_m.dot(pts.transpose()))
 ptr_trans = ptr_trans[0:2, :]
 ptr_trans = ptr_trans.transpose()
 path = Path(ptr_trans, codes_direction)
 return path
 colormap = None
 if unique_colors is True:
 norm = mpl.colors.Normalize(vmin=0, vmax=len(fairways))
 colormap = cm.ScalarMappable(norm=norm, cmap=cm.jet)
 incoming_vertices_fill = list()
 crossing_vertices_fill = list()
 succ_left_paths = list()
 succ_straight_paths = list()
 succ_right_paths = list()
 vertices_fill = list()
 coordinates_left_border_vertices = np.empty((0, 2))
 coordinates_right_border_vertices = np.empty((0, 2))
 direction_list = list()
 center_paths = list()
 left_paths = list()
 right_paths = list()
 for i_fairway, fairway in enumerate(fairways):
 if unique_colors:
 center_bound_color = colormap.to_rgba(i_fairway)
 if draw_start_and_direction:
 center = fairway.center_vertices[0]
 tan_vec = np.array(fairway.right_vertices[0]) - np.array(fairway.left_vertices[0])
 if unique_colors is False:
 direction_list.append(direction(center[0], center[1], np.arctan2(tan_vec[1], tan_vec[0]) + 0.5 * np.pi))
 else:
 direction_list = [direction(center[0], center[1], np.arctan2(tan_vec[1], tan_vec[0]) + 0.5 * np.pi)]
 ax.add_collection(collections.PathCollection(direction_list, color=center_bound_color,
 lw=0.5, zorder=10.1, antialiased=antialiased))
 if draw_border_vertices or draw_left_bound:
 if draw_border_vertices:
 coordinates_left_border_vertices = np.vstack((coordinates_left_border_vertices, fairway.left_vertices))
 left_paths.append(Path(fairway.left_vertices, closed=False))
 if draw_border_vertices or draw_right_bound:
 if draw_border_vertices:
 coordinates_right_border_vertices = np.vstack((coordinates_right_border_vertices,
 fairway.right_vertices))
 right_paths.append(Path(fairway.right_vertices, closed=False))
 is_successor = draw_intersections and draw_successors and fairway.waters_id in all_successors
 if is_successor:
 if fairway.waters_id in successors_left:
 succ_left_paths.append(Path(fairway.center_vertices, closed=False))
 elif fairway.waters_id in successors_straight:
 succ_straight_paths.append(Path(fairway.center_vertices, closed=False))
 else:
 succ_right_paths.append(Path(fairway.center_vertices, closed=False))
 is_incoming_lanelet = draw_intersections and draw_incoming_lanelets and \
 (fairway.waters_id in incoming_lanelets)
 is_crossing = draw_intersections and draw_crossings and \
 (fairway.waters_id in crossings)
 if fill_lanelet:
 if not is_incoming_lanelet and not is_crossing:
 vertices_fill.append(np.concatenate((fairway.right_vertices, np.flip(fairway.left_vertices, 0))))
 if is_incoming_lanelet:
 incoming_vertices_fill.append(
 np.concatenate((fairway.right_vertices, np.flip(fairway.left_vertices, 0))))
 elif is_crossing:
 crossing_vertices_fill.append(
 np.concatenate((fairway.right_vertices, np.flip(fairway.left_vertices, 0))))
 if show_label or show_intersection_labels or draw_traffic_signs:
 strings = []
 if show_label:
 strings.append(str(fairway.waters_id))
 if is_incoming_lanelet and show_intersection_labels:
 strings.append('inc_id: ' + str(incomings_id[fairway.waters_id]))
 strings.append('inc_left: ' + str(incomings_left[fairway.waters_id]))
 if draw_traffic_signs and show_traffic_sign_label is True:
 traffic_signs_tmp = [traffic_signs[id] for id in fairway.traffic_signs]
 if traffic_signs_tmp:
 str_tmp = 'traffic signs: '
 add_str = ''
 for sign in traffic_signs_tmp:
 for el in sign.traffic_sign_elements:
 str_tmp += add_str + el.traffic_sign_element_id.value
 add_str = ', '
 strings.append(str_tmp)
 label_string = ', '.join(strings)
 if len(label_string) > 0:
 normal_vector = np.array(fairway.right_vertices[0]) - np.array(fairway.right_vertices[-1])
 angle = np.rad2deg(np.arctan2(normal_vector[1], normal_vector[0])) - 90
 angle = angle if Interval(-90, 90).contains(angle) else angle - 180
 ax.text(fairway.right_vertices[0][0], fairway.right_vertices[0][1],
 label_string,
 bbox={'facecolor': center_bound_color, 'pad': 2},
 horizontalalignment='center', verticalalignment='center',
 rotation=angle,
 zorder=30.2)
 if draw_right_bound:
 ax.add_collection(collections.PathCollection(right_paths, edgecolor=right_bound_color, facecolor='none',
 lw=draw_linewidth, zorder=10, antialiased=antialiased))
 if draw_left_bound:
 ax.add_collection(collections.PathCollection(left_paths, edgecolor=left_bound_color, facecolor='none',
 lw=draw_linewidth, zorder=10, antialiased=antialiased))
 if unique_colors is False:
 if draw_center_bound:
 ax.add_collection(collections.PathCollection(center_paths, edgecolor=center_bound_color, facecolor='none',
 lw=draw_linewidth, zorder=10, antialiased=antialiased))
 if draw_start_and_direction:
 ax.add_collection(collections.PathCollection(direction_list, color=center_bound_color,
 lw=0.5, zorder=10.1, antialiased=antialiased))
 if successors_left:
 ax.add_collection(collections.PathCollection(succ_left_paths, edgecolor=successors_left_color, facecolor='none',
 lw=draw_linewidth * 3.0, zorder=11, antialiased=antialiased))
 if successors_straight:
 ax.add_collection(
 collections.PathCollection(succ_straight_paths, edgecolor=successors_straight_color, facecolor='none',
 lw=draw_linewidth * 3.0, zorder=11, antialiased=antialiased))
 if successors_right:
 ax.add_collection(
 collections.PathCollection(succ_right_paths, edgecolor=successors_right_color, facecolor='none',
 lw=draw_linewidth * 3.0, zorder=11, antialiased=antialiased))
 collection_tmp = collections.PolyCollection(vertices_fill, transOffset=ax.transData, zorder=9.0,
 facecolor=facecolor, edgecolor='none', antialiased=antialiased)
 ax.add_collection(collection_tmp)
 if incoming_vertices_fill:
 collection_tmp = collections.PolyCollection(incoming_vertices_fill, transOffset=ax.transData,
 facecolor=incoming_lanelets_color, edgecolor='none', zorder=9.1,
 antialiased=antialiased)
 ax.add_collection(collection_tmp)
 if crossing_vertices_fill:
 collection_tmp = collections.PolyCollection(crossing_vertices_fill, transOffset=ax.transData,
 facecolor=crossings_color, edgecolor='none', zorder=9.2,
 antialiased=antialiased)
 ax.add_collection(collection_tmp)
 if draw_border_vertices:
 collection_tmp = collections.EllipseCollection(np.ones([coordinates_left_border_vertices.shape[0], 1]) * 1,
 np.ones([coordinates_left_border_vertices.shape[0], 1]) * 1,
 np.zeros([coordinates_left_border_vertices.shape[0], 1]),
 offsets=coordinates_left_border_vertices,
 color=left_bound_color, transOffset=ax.transData)
 ax.add_collection(collection_tmp)
 collection_tmp = collections.EllipseCollection(np.ones([coordinates_right_border_vertices.shape[0], 1]) * 1,
 np.ones([coordinates_right_border_vertices.shape[0], 1]) * 1,
 np.zeros([coordinates_right_border_vertices.shape[0], 1]),
 offsets=coordinates_right_border_vertices,
 color=right_bound_color, transOffset=ax.transData)
 ax.add_collection(collection_tmp)
 traffic_lights_signs = []
 if draw_traffic_signs:
 traffic_lights_signs.extend(list(traffic_signs.values()))
 if traffic_lights_signs:
 draw_traffic_light_signs(traffic_lights_signs, None, ax, draw_params, draw_func, handles, call_stack)
def draw_dynamic_obstacles(obj: Union[List[DynamicObstacle], DynamicObstacle],
 plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable],
 handles: Dict[Any, List[Union[mpl.patches.Patch, mpl.collections.Collection]]],
 call_stack: Tuple[str, ...]) -> None:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 def collecting(o: DynamicObstacle):
 occupancy_list = list()
 trajectory = None
 shape = None
 indicators = []
 braking = []
 horns = []
 bluelights = []
 if type(o) is not DynamicObstacle:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 return (occupancy_list, trajectory, shape)
 if (draw_occupancies == 1 or
 (draw_occupancies == 0 and type(o.prediction) == commonroad.prediction.prediction.SetBasedPrediction)):
 if draw_shape:
 time_begin_occ = time_begin + 1
 else:
 time_begin_occ = time_begin
 for time_step in range(time_begin_occ, time_end):
 tmp = o.occupancy_at_time(time_step)
 if tmp is not None:
 occupancy_list.append(tmp)
 if draw_trajectory and type(o.prediction) == commonroad.prediction.prediction.TrajectoryPrediction:
 trajectory = o.prediction.trajectory
 if draw_shape:
 occ = o.occupancy_at_time(time_begin)
 if occ is None:
 shape = None
 else:
 shape = occ.shape
 if draw_icon and type(o.prediction) == commonroad.prediction.prediction.TrajectoryPrediction:
 if time_begin == 0:
 inital_state = o.initial_state
 else:
 inital_state = o.prediction.trajectory.state_at_time_step(time_begin)
 if inital_state is not None:
 draw_car(inital_state.position[0], inital_state.position[1], inital_state.orientation, 2.5,
 ax, zorder=30)
 initial_state = None
 if show_label:
 if time_begin == 0:
 initial_state = o.initial_state
 initial_position = initial_state.position
 handles.setdefault(DynamicObstacle, []).append(
 ax.text(initial_position[0] + 0.5, initial_position[1], str(o.obstacle_id),
 clip_on=True, zorder=1000))
 elif type(o.prediction) == commonroad.prediction.prediction.TrajectoryPrediction:
 initial_state = o.prediction.trajectory.state_at_time_step(time_begin)
 if initial_state is not None:
 initial_position = o.prediction.trajectory.state_at_time_step(time_begin).position
 handles.setdefault(DynamicObstacle, []).append(
 ax.text(initial_position[0] + 0.5, initial_position[1], str(o.obstacle_id),
 clip_on=True, zorder=1000))
 if draw_initial_state:
 if initial_state is None:
 if time_begin == 0:
 initial_state = o.initial_state
 elif type(o.prediction) == commonroad.prediction.prediction.TrajectoryPrediction:
 initial_state = o.prediction.trajectory.state_at_time_step(time_begin)
 return [occupancy_list, trajectory, shape, np.array(indicators).reshape(-1, 2),
 np.array(braking).reshape(-1, 2),
 np.array(horns).reshape(-1, 2), np.array(bluelights).reshape(-1, 2), initial_state]
 if type(obj) is DynamicObstacle:
 obj = [obj]
 try:
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('time_begin',))
 time_end = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('time_end',))
 draw_icon = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'draw_icon'))
 show_label = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'show_label'))
 draw_shape = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'draw_shape'))
 draw_initial_state = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'initial_state', 'draw_initial_state'))
 scale_factor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'initial_state', 'scale_factor'))
 kwargs_init_state = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'initial_state', 'kwargs'))
 draw_occupancies = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'occupancy', 'draw_occupancies'))
 draw_signals = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'draw_signals'))
 zorder = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'zorder'))
 signal_radius = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'signal_radius'))
 indicator_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'indicator_color'))
 braking_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'braking_color'))
 horn_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'horn_color'))
 blue_lights_color = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'blue_lights_color'))
 draw_trajectory = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('dynamic_obstacle', 'trajectory', 'draw_trajectory'))
 except KeyError:
 warnings.warn("Cannot find stylesheet for dynamic_obstacle. Called through:")
 print(call_stack)
 call_stack = tuple(list(call_stack) + ['dynamic_obstacle'])
 occupancy_list, trajectories_list, shapes_list, indicators, braking, horns, bluelights, initial_states \
 = zip(*list(map(collecting, obj)))
 occupancy_list = list(filter(None, list(occupancy_list)))
 trajectories_list = list(filter(None, list(trajectories_list)))
 shapes_list = list(filter(None, list(shapes_list)))
 indicators = np.vstack(indicators)
 braking = np.vstack(braking)
 horns = np.vstack(horns)
 bluelights = np.vstack(bluelights)
 initial_states = list(filter(None, list(initial_states)))
 if len(shapes_list) > 0:
 handles.setdefault(DynamicObstacle, []).extend(
 shape_batch_dispatcher(shapes_list, None, ax, draw_params, draw_func, handles, call_stack))
 if len(trajectories_list) > 0:
 handles.setdefault(DynamicObstacle, []).extend(
 commonocean.visualization.draw_dispatch_cr.
 draw_object(trajectories_list, None, ax, draw_params, draw_func, handles, call_stack))
 if len(occupancy_list) > 0:
 handles.setdefault(DynamicObstacle, []).extend(
 commonocean.visualization.draw_dispatch_cr.
 draw_object(occupancy_list, None, ax, draw_params, draw_func, handles, call_stack))
 if draw_initial_state is True:
 for initial_state in initial_states:
 handles.setdefault(DynamicObstacle, []).extend(draw_state(initial_state, call_stack=call_stack,
 ax=ax, draw_params=draw_params,
 scale_factor=scale_factor,
 plot_limits=None,
 arrow_args=kwargs_init_state))
 if indicators.size > 0:
 diameters = signal_radius * np.ones(indicators.shape[0]) * 2
 handles.setdefault(DynamicObstacle, []).append(
 collections.EllipseCollection(diameters, diameters, angles=np.zeros_like(diameters), offsets=indicators,
 transOffset=ax.transData, units='xy', facecolor=indicator_color,
 edgecolor=indicator_color, zorder=zorder + 0.2, linewidth=0))
 ax.add_collection(handles[DynamicObstacle][-1])
 if braking.size > 0:
 diameters = signal_radius * np.ones(braking.shape[0]) * 3.0
 handles.setdefault(DynamicObstacle, []).append(
 collections.EllipseCollection(diameters, diameters, angles=np.zeros_like(diameters), offsets=braking,
 transOffset=ax.transData, units='xy', facecolor=braking_color,
 edgecolor=braking_color, zorder=zorder + 0.1, linewidth=0))
 ax.add_collection(handles[DynamicObstacle][-1])
 if horns.size > 0:
 diameters = signal_radius * np.ones(horns.shape[0]) * 3.0
 handles.setdefault(DynamicObstacle, []).append(
 collections.EllipseCollection(diameters, diameters, angles=np.zeros_like(diameters), offsets=horns,
 transOffset=ax.transData, units='xy', facecolor=horn_color,
 edgecolor=braking_color, zorder=zorder + 0.1, linewidth=0))
 ax.add_collection(handles[DynamicObstacle][-1])
 if bluelights.size > 0:
 diameters = signal_radius * np.ones(bluelights.shape[0]) * 2
 handles.setdefault(DynamicObstacle, []).append(
 collections.EllipseCollection(diameters, diameters, angles=np.zeros_like(diameters), offsets=bluelights,
 transOffset=ax.transData, units='xy', facecolor=blue_lights_color,
 edgecolor=braking_color, zorder=zorder + 0.1, linewidth=0))
 ax.add_collection(handles[DynamicObstacle][-1])
def draw_occupancies(obj: Union[List[Occupancy], Occupancy], plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> List[
 mpl.collections.Collection]:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 call_stack = tuple(list(call_stack) + ['occupancy'])
 if type(obj) is Occupancy:
 obj = [obj]
 shape_list = list()
 if not 'dynamic_obstacle' in call_stack:
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('time_begin',))
 time_end = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('time_end',))
 for occupancy in obj:
 if time_begin <= occupancy.time_step <= time_end:
 shape_list.append(occupancy.shape)
 else:
 for occupancy in obj:
 shape_list.append(occupancy.shape)
 patch_list = shape_batch_dispatcher(shape_list, None, ax, draw_params, draw_func, handles, call_stack)
 return patch_list
def shape_batch_dispatcher(obj: List[Shape], plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes,
 draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]],
 call_stack: Tuple[str, ...]) -> List[mpl.collections.Collection]:
 """
 Groups a list of shapes by their type and draws them each in a batch.
 :param obj: list of shapes to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 shapes_ordered_by_type = dict()
 for shape in obj:
 if shape is not None:
 shapes_ordered_by_type.setdefault(type(shape), []).append(shape)
 collection_list = list()
 for shape_list_tmp in shapes_ordered_by_type.values():
 collection_tmp = commonocean.visualization.draw_dispatch_cr.draw_object(shape_list_tmp, None, ax, draw_params,
 draw_func, handles, call_stack)
 collection_list.extend(collection_tmp)
 return collection_list
def draw_polygons(obj: Polygon, plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes,
 draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) \
 -> List[mpl.collections.Collection]:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if type(obj) is Polygon:
 obj = [obj]
 call_stack = tuple(list(call_stack) + ['shape', 'polygon'])
 try:
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['facecolor']))
 edgecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['edgecolor']))
 zorder = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['zorder']))
 opacity = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['opacity']))
 linewidth = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['linewidth']))
 antialiased = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(),
 tuple(['antialiased']))
 except KeyError:
 print("Cannot find stylesheet for polygon. Called through:")
 print(call_stack)
 vertices_list = list()
 for poly in obj:
 if type(poly) is not Polygon:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 continue
 vertices_list.append(np.array(poly.vertices))
 collection = draw_polygon_collection_as_patch(vertices_list, ax, zorder=zorder,
 facecolor=facecolor,
 edgecolor=edgecolor, lw=linewidth, alpha=opacity,
 antialiased=antialiased)
 return [collection]
def draw_circle(obj: Union[Circle, List[Circle]], plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> List[
 mpl.collections.Collection]:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if type(obj) is Circle:
 obj: List[Circle] = [obj]
 call_stack = tuple(list(call_stack) + ['shape', 'circle'])
 try:
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['facecolor']))
 edgecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['edgecolor']))
 zorder = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['zorder']))
 opacity = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['opacity']))
 linewidth = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['linewidth']))
 except KeyError:
 print("Cannot find stylesheet for circle. Called through:")
 print(call_stack)
 centers = list()
 radii = list()
 for circle in obj:
 if type(circle) is not Circle:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 continue
 centers.append(circle.center)
 radii.append(circle.radius)
 centers = np.array(centers)
 diameters = np.array(radii) * 2
 collection = collections.EllipseCollection(diameters, diameters, angles=np.zeros_like(radii), offsets=centers,
 transOffset=ax.transData, units='xy', facecolor=facecolor,
 edgecolor=edgecolor, zorder=zorder, linewidth=linewidth, alpha=opacity, )
 ax.add_collection(collection)
 return [collection]
def draw_rectangle(obj: Union[Rectangle, List[Rectangle]], plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]) -> List[
 mpl.collections.Collection]:
 """
 :param obj: object to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 if type(obj) is Rectangle:
 obj = [obj]
 call_stack = tuple(list(call_stack) + ['shape', 'rectangle'])
 try:
 facecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['facecolor']))
 edgecolor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['edgecolor']))
 zorder = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['zorder']))
 opacity = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['opacity']))
 linewidth = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 tuple(['linewidth']))
 antialiased = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(),
 tuple(['antialiased']))
 except KeyError:
 print("Cannot find stylesheet for rectangle. Called through:")
 print(call_stack)
 vertices = list()
 for rect in obj:
 if type(rect) is not Rectangle:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 continue
 vertices.append(np.array(rect.vertices))
 collection = collections.PolyCollection(vertices, closed=True, zorder=zorder, transOffset=ax.transData,
 facecolor=facecolor, edgecolor=edgecolor, alpha=opacity,
 antialiased=antialiased, linewidth=linewidth)
 ax.add_collection(collection)
 return [collection]
def draw_car(pos_x: Union[int, float], pos_y: Union[int, float], rotate: Union[int, float],
 scale: Union[int, float], ax: mpl.axes.Axes, zorder: int = 5, carcolor: str = '#ffffff',
 lw=0.5):
 rotate = rotate + np.pi
 def reshape_and_addup(verts):
 verts = verts.reshape((int(len(verts) / 2), 2))
 for i in range(1, len(verts)):
 verts[i] = verts[i] + verts[i - 1]
 return verts
 def transform(vertices, pos_x, pos_y, rotate, scale):
 vertices = np.asarray(np.bmat([vertices, np.ones((len(vertices), 1))]))
 tmat = np.array([[np.cos(rotate), -np.sin(rotate), pos_x],
 [np.sin(rotate), np.cos(rotate), pos_y], [0, 0, 1]])
 scalemat = np.array([[scale * 1 / 356.3211, 0, 0], [0, scale * 1 / 356.3211, 0],
 [0, 0, 1]])
 centermat = np.array([[1, 0, -250], [0, 1, -889], [0, 0, 1]])
 tmat = tmat.dot(scalemat.dot(centermat))
 vertices = tmat.dot(vertices.transpose())
 vertices = np.array([[1, 0, 0], [0, 1, 0]]).dot(vertices).transpose()
 return vertices
 verts1 = np.array([193.99383, 752.94359,
 -22.66602, 38,
 -9.33398, 52.66797,
 -2.60743, 44.82812,
 -0.0586, 0,
 0.0293, 0.91992,
 -0.0293, 0.91797,
 0.0586, 0,
 2.60743, 44.82813,
 9.33398, 52.66797,
 22.66602, 38.00003,
 59.33398, -7.334,
 62, -10.666,
 -6, -50.00003,
 -2.65234, -68.41407,
 2.65234, -68.41601,
 6, -50,
 -62, -10.66602])
 verts2 = np.array([715.99381, 768.27757,
 -101.332, 6.66602,
 10.666, 62.66797,
 3.3223, 50.41797,
 -3.3223, 50.41796,
 -10.666, 62.66601,
 101.332, 6.668,
 22, -42.66799,
 9.9824, -76.83594,
 # 0.018,0,
 # -0.01,-0.24804,
 # 0.01,-0.24805,
 # -0.018,0,
 -9.9824, -76.83789,
 0, 0])
 verts3 = np.array([421.06111, 751.61113,
 190.2667, 3.33333,
 13.3333, 5.33334,
 -108.6666, 12.66666,
 -134, 0,
 -119.3334, -18.66666,
 127.6456, -2.96473])
 verts4 = np.array([271.32781, 712.14446,
 -6, -0.8,
 -16, 12,
 -14.8, 19.2,
 -4, 6,
 20.4, 0.4,
 3.6, -4.4,
 4.8, -2.8])
 verts5 = np.array([191.32781, 753.94359,
 -99.999996, 11,
 -63, 18.5,
 -59, 38.5,
 -20, 77,
 20, 59.52734,
 57, 36.49998,
 65, 20.49999,
 99.999996, 11.0001])
 verts6 = np.array([421.06111, 1027.399,
 190.2667, -3.3333,
 13.3333, -5.3333,
 -108.6666, -12.6667,
 -134, 0,
 -119.3334, 18.6667,
 127.6456, 2.9647])
 verts7 = np.array([271.32781, 1066.8657,
 -6, 0.8,
 -16, -12,
 -14.8, -19.2,
 -4, -6,
 20.4, -0.4,
 3.6, 4.4,
 4.8, 2.8])
 verts8 = np.array([389.79851, 728.34788,
 -343.652396, 10.16016,
 -68.666, 22.42969,
 -29.2558, 74.57031,
 -7.3164, 60.35742,
 -0.074, 0,
 0.037, 0.76758,
 -0.037, 0.76758,
 0.074, 0,
 7.3164, 42.35937,
 29.2558, 74.57031,
 68.666, 22.4278,
 343.652396, 10.1621,
 259.5859, -4.6192,
 130.2539, -17.5527,
 24.0196, -18.4766,
 17.5527, -65.58788,
 3.6953, -37.42773,
 0, -13.24414,
 -3.6953, -55.42774,
 -17.5527, -65.58984,
 -24.0196, -18.47656,
 -130.2539, -17.55274])
 verts1 = reshape_and_addup(verts1)
 verts2 = reshape_and_addup(verts2)
 verts3 = reshape_and_addup(verts3)
 verts4 = reshape_and_addup(verts4)
 verts5 = reshape_and_addup(verts5)
 verts6 = reshape_and_addup(verts6)
 verts7 = reshape_and_addup(verts7)
 verts8 = reshape_and_addup(verts8)
 verts1 = transform(verts1, pos_x, pos_y, rotate, scale)
 verts2 = transform(verts2, pos_x, pos_y, rotate, scale)
 verts3 = transform(verts3, pos_x, pos_y, rotate, scale)
 verts4 = transform(verts4, pos_x, pos_y, rotate, scale)
 verts5 = transform(verts5, pos_x, pos_y, rotate, scale)
 verts6 = transform(verts6, pos_x, pos_y, rotate, scale)
 verts7 = transform(verts7, pos_x, pos_y, rotate, scale)
 verts8 = transform(verts8, pos_x, pos_y, rotate, scale)
 windowcolor = '#555555'
 draw_polygon_as_patch(verts1, ax, facecolor=windowcolor, zorder=zorder + 1,
 lw=lw)
 draw_polygon_as_patch(verts2, ax, facecolor=windowcolor, zorder=zorder + 1,
 lw=lw)
 draw_polygon_as_patch(verts3, ax, facecolor=windowcolor, zorder=zorder + 1,
 lw=lw)
 draw_polygon_as_patch(verts4, ax, facecolor='#ffffff', zorder=zorder + 1,
 lw=lw)
 ax.plot(verts5[:, 0], verts5[:, 1], zorder=zorder + 1, color='#000000',
 lw=lw)
 draw_polygon_as_patch(verts6, ax, facecolor=windowcolor, zorder=zorder + 1,
 lw=lw)
 draw_polygon_as_patch(verts7, ax, facecolor='#ffffff', zorder=zorder + 1,
 lw=lw)
 draw_polygon_as_patch(verts8, ax, facecolor=carcolor, edgecolor='#000000',
 zorder=zorder, lw=lw)
def draw_state(state: CustomState, plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict, draw_func: Dict[type, Callable] = None,
 handles: Dict[int, List[mpl.patches.Patch]] = None, call_stack: Tuple[str, ...] = None,
 scale_factor=None,
 arrow_args=None) -> List[mpl.collections.Collection]:
 """
 :param state: state to be plotted
 :param ax: axes object from matplotlib
 :param draw_params: parameters for plotting given by a nested dict that recreates the structure of an object,
 :param draw_func: specifies the drawing function
 :param call_stack: tuple of string containing the call stack, which allows for differentiation of plotting styles
 depending on the call stack of draw_object
 :return: None
 """
 try:
 if scale_factor is None:
 scale_factor = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'scale_factor'))
 if arrow_args is None:
 arrow_args = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, call_stack,
 ('initial_state', 'kwargs'))
 except KeyError:
 print("Cannot find stylesheet for initial_state. Called through:")
 print(call_stack)
 return []
 cos = math.cos(state.orientation)
 sin = math.sin(state.orientation)
 length = 1.5
 x = state.position[0] + cos * length
 y = state.position[1] + sin * length
 artist = ax.arrow(x=x, y=y,
 dx=state.velocity * cos * scale_factor,
 dy=state.velocity * sin * scale_factor,
 zorder=100,
 **arrow_args)
 return [artist]
def draw_shallow_list(obj: (Union[List[Shallow], Shallow]),
 plot_limits: Union[List[Union[int, float]], None], ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable],
 handles: Dict[int, List[mpl.patches.Patch]], call_stack: Tuple[str, ...]):
 time_begin = commonocean.visualization.draw_dispatch_cr._retrieve_value(
 draw_params, tuple(), ('time_begin',))
 if type(obj) is Shallow:
 obj = [obj]
 call_stack = tuple(list(call_stack) + ['shallow'])
 shape_list = list()
 for shallow in obj:
 if type(shallow) is not Shallow:
 warnings.warn('<visualization/scenario> Only lists with objects of the same type can be plotted',
 UserWarning, stacklevel=1)
 continue
 shape_list.append(shallow.shape)
 collection = shape_batch_dispatcher(shape_list, None, ax, draw_params, draw_func, handles, call_stack)
 handles.setdefault(Shallow, []).extend(collection)
draw_func_dict = {commonocean.scenario.scenario.Scenario: draw_scenario,
 commonocean.scenario.waters.Waterway: draw_fairway_list,
 commonocean.scenario.waters.Shallow: draw_shallow_list,
 commonocean.scenario.waters.WatersNetwork: draw_fairway_network,
 commonocean.scenario.traffic_sign.TrafficSign: draw_traffic_light_signs,
 commonocean.scenario.obstacle.DynamicObstacle: draw_dynamic_obstacles,
 commonocean.scenario.obstacle.StaticObstacle: draw_static_obstacles,
 commonroad.prediction.prediction.Occupancy: draw_occupancies,
 commonroad.geometry.shape.Polygon: draw_polygons,
 commonroad.geometry.shape.Circle: draw_circle,
 commonroad.geometry.shape.Rectangle: draw_rectangle,
 commonroad.scenario.trajectory.Trajectory: draw_trajectories}
</src\commonocean\visualization\scenario.py>

<src\commonocean\visualization\traffic_sign.py>
import copy
import enum
import os
from collections import defaultdict, OrderedDict
from typing import Dict, Callable, Tuple, Union, Any,List
import matplotlib as mpl
import matplotlib.patches as patches
import matplotlib.collections as collections
from PIL import Image
import commonroad.prediction.prediction
import commonocean.scenario.obstacle
import commonocean.visualization.draw_dispatch_cr
from commonroad.geometry.shape import *
from commonocean.scenario.traffic_sign import TrafficSign
from matplotlib.offsetbox import OffsetImage, \
 AnnotationBbox, \
 HPacker, \
 TextArea, \
 VPacker, \
 OffsetBox
# Tunneling from CR-IO #
from commonroad.visualization.traffic_sign import isfloat as isfloat_CR
from commonroad.visualization.traffic_sign import rescale_text as rescale_text_CR
########################
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
traffic_sign_path = os.path.join(os.path.dirname(__file__), 'traffic_signs/')
def isfloat(value: str):
 return isfloat_CR(value)
def text_prop_dict() -> dict:
 """Properties of text for additional_value."""
 return {
 '274': {
 'mpl_args': {'weight': 'bold', 'size': 13.5},
 'rescale_threshold': 2,
 'position_offset': -21.0
 }, '275': {
 'mpl_args': {
 'weight': 'bold', 'color': 'white', 'size': 13.5
 }, 'rescale_threshold': 2, 'position_offset': -21.0
 }, '278': {
 'mpl_args': {
 'weight': 'bold', 'color': 'gray', 'size': 10
 }, 'position_offset': -16.5
 }, '279': {
 'mpl_args': {
 'weight': 'bold', 'color': 'white', 'size': 10
 }, 'position_offset': -16.5
 }, '310': {
 'mpl_args': {
 'weight': 'normal', 'color': 'black', 'size': 10
 }
 }, '380': {
 'mpl_args': {
 'weight': 'bold', 'color': 'white', 'size': 10
 }, 'position_offset': -16.5
 }, '381': {
 'mpl_args': {
 'weight': 'bold', 'color': 'white', 'size': 10
 }, 'position_offset': -16.5
 }, 'R2-1': {
 'mpl_args': {
 'weight': 'normal', 'color': 'black', 'size': 10.5
 }, 'position_offset': -13.5
 }
 }
def rescale_text(string: str, prop: dict, scale_factor: float,
 default_scale_factor: float) -> dict:
 """Rescales text size proportionally to the max. number of strings given
 by prop['rescale_threshold'] and to the
 'scale_factor' compared to the default scale_factor. Used e.g. for
 fitting speed limits into the traffic sign."""
 return rescale_text_CR(string, prop, scale_factor, default_scale_factor)
def create_img_boxes_traffic_sign(
 traffic_signs: Union[List[TrafficSign], TrafficSign], draw_params: dict,
 call_stack: Tuple[str, ...]) -> Dict[
 Tuple[float, float], List[OffsetBox]]:
 """
 For each Traffic sign an OffsetBox is created, containing the png image
 and optionally labels. These boxes can
 be stacked horizontally later when multiple signs share the
 same position.
 :param traffic_signs:
 :param draw_params:
 :param call_stack:
 :return:
 """
 if type(traffic_signs) is not list:
 traffic_signs = [traffic_signs]
 if len(traffic_signs) == 0:
 return dict()
 scale_factor = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('traffic_sign', 'scale_factor'),
 ('scenario', 'waters_network', 'traffic_sign', 'scale_factor'))
 show_label_default = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('traffic_sign', 'show_label'),
 ('scenario', 'waters_network', 'traffic_sign', 'show_label'))
 show_traffic_signs = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('traffic_sign', 'show_traffic_signs'), (
 'scenario', 'waters_network', 'traffic_sign',
 'show_traffic_signs'))
 zorder = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('traffic_sign', 'zorder'),
 ('scenario', 'waters_network', 'traffic_sign', 'zorder'))
 scale_factor_default = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_value(
 commonocean.visualization.draw_dispatch_cr.default_draw_params,
 call_stack,
 ('scenario', 'waters_network', 'traffic_sign', 'scale_factor'))
 assert any([show_traffic_signs == 'all',
 isinstance(show_traffic_signs, list) and type(
 show_traffic_signs[0] is enum)]), 'Plotting option ' \
 'traffic_sign.show_traffic_signs must ' \
 'be either "all" or ' \
 'list of type ' \
 'TrafficSignID'
 prop_dict = text_prop_dict()
 imageboxes_all = defaultdict(list)
 for traffic_sign in traffic_signs:
 if traffic_sign.virtual is True or traffic_sign.position is None:
 continue
 imageboxes = []
 for element in traffic_sign.traffic_sign_elements:
 el_id = element.traffic_sign_element_id
 if not (show_traffic_signs == 'all' or el_id in show_traffic_signs):
 continue
 show_label = show_label_default
 path = os.path.join(traffic_sign_path, el_id.value + '.png')
 plot_img = True
 if not os.path.exists(path):
 show_label = True
 warnings.warn(
 'No png file for traffic sign id {} exists under '
 'path '
 '{}, skipped plotting.'.format(el_id, path))
 plot_img = False
 boxes = []
 if show_label:
 boxes.append(TextArea(el_id.name))
 if plot_img:
 sign_img = Image.open(path)
 boxes.append(
 OffsetImage(sign_img, zoom=scale_factor, zorder=zorder,
 interpolation='bicubic'))
 if len(boxes) > 1:
 boxes = [VPacker(children=boxes, pad=0, sep=0, align='center')]
 sep = 0
 if len(element.additional_values) > 0:
 add_text = '\n'.join(element.additional_values)
 props = prop_dict[
 el_id.value] if el_id.value in prop_dict else {
 'mpl_args': {}
 }
 props = rescale_text(add_text, props, scale_factor,
 scale_factor_default)
 boxes.append(TextArea(add_text, textprops=props['mpl_args']))
 if plot_img and 'position_offset' in props:
 sep = props['position_offset']
 img = VPacker(children=boxes, pad=0, sep=sep, align='center')
 imageboxes.append(img)
 if len(imageboxes) > 0:
 hbox = HPacker(children=imageboxes, pad=0, sep=0.05,
 align='baseline')
 imageboxes_all[tuple(traffic_sign.position.tolist())].append(hbox)
 return imageboxes_all
def draw_traffic_light_signs(traffic_lights_signs: Union[
 List[Union[TrafficSign]], Union[TrafficSign]],
 plot_limits: Union[List[Union[int, float]], None],
 ax: mpl.axes.Axes, draw_params: dict,
 draw_func: Dict[type, Callable], handles: Dict[
 Any, List[Union[mpl.patches.Patch, mpl.collections.Collection]]],
 call_stack: Tuple[str, ...]) -> None:
 """
 Draws OffsetBoxes which are first collected for all traffic signs and
 -lights. Boxes are stacked together when they
 share the same position.
 :param traffic_lights_signs:
 :param plot_limits:
 :param ax:
 :param draw_params:
 :param draw_func:
 :param handles:
 :param call_stack:
 :return:
 """
 kwargs = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('kwargs_traffic_light_signs',),
 ('scenario', 'waters_network', 'kwargs_traffic_light_signs'))
 zorder_1 = commonocean.visualization.draw_dispatch_cr\
 ._retrieve_alternate_value(
 draw_params, call_stack, ('traffic_sign', 'zorder'),
 ('scenario', 'waters_network', 'traffic_sign', 'zorder'))
 zorder = zorder_1
 threshold_grouping = 0.8
 if not isinstance(traffic_lights_signs, list):
 traffic_lights_signs = [traffic_lights_signs]
 traffic_signs = []
 for obj in traffic_lights_signs:
 if isinstance(obj, TrafficSign):
 traffic_signs.append(obj)
 else:
 warnings.warn('Object of type {}, but expected type TrafficSign'.format(type(obj)))
 boxes_signs = create_img_boxes_traffic_sign(traffic_signs, draw_params,
 call_stack)
 img_boxes = defaultdict(list)
 [img_boxes[pos].extend(box_list) for pos, box_list in boxes_signs.items()]
 if not img_boxes:
 return None
 positions = list(img_boxes.keys())
 box_lists = list(img_boxes.values())
 groups = dict()
 grouped = set()
 i = 1
 for pos, box_list in zip(positions[:-1], box_lists[:-1]):
 i += 1
 group_tmp = list(box_list)
 if pos in grouped:
 continue
 gr_pos_tmp = [np.array(pos)]
 for pos2, box_list2 in zip(positions[i:], box_lists[i:]):
 if pos2 in grouped:
 continue
 if np.linalg.norm(np.array(pos) - np.array(pos2),
 ord=np.inf) < threshold_grouping:
 group_tmp.extend(box_list2)
 gr_pos_tmp.append(np.array(pos2))
 grouped.add(pos)
 groups[tuple(np.average(gr_pos_tmp, axis=0).tolist())] = group_tmp
 if positions[-1] not in grouped:
 groups[positions[-1]] = box_lists[-1]
 default_params = dict(xycoords='data', frameon=False)
 for param, value in default_params.items():
 if param not in kwargs:
 kwargs[param] = value
 for position_tmp, box_list_tmp in groups.items():
 position_tmp = np.array(position_tmp)
 kwargs_tmp = copy.deepcopy(kwargs)
 if 'xybox' not in kwargs_tmp:
 kwargs_tmp['xybox'] = position_tmp
 hbox = HPacker(children=box_list_tmp, pad=0, sep=0.1, align='baseline')
 ab = AnnotationBbox(hbox, position_tmp, **kwargs_tmp)
 ab.zorder = zorder
 ax.add_artist(ab)
</src\commonocean\visualization\traffic_sign.py>

<src\commonocean\visualization\util.py>
import warnings
import numpy as np
from commonroad.scenario.scenario import Scenario
from matplotlib.lines import Line2D
from matplotlib.path import Path
import matplotlib.patches as patches
import matplotlib as mpl
import matplotlib.collections as collections
from typing import List, Dict, Tuple, Union
from commonocean.scenario.obstacle import DynamicObstacle
from commonocean.scenario.waters import WatersNetwork
# Tunneling from CR-IO #
from commonroad.visualization.util import draw_polygon_as_patch as draw_polygon_as_patch_cr
from commonroad.visualization.util import draw_polygon_collection_as_patch as draw_polygon_collection_as_patch_cr
########################
__author__ = "Hanna Krasowski, Benedikt Pfleiderer, Fabian Thomas-Barein"
__copyright__ = "TUM Cyber-Physical System Group"
__credits__ = ["ConVeY"]
__version__ = "2022a"
__maintainer__ = "Hanna Krasowski"
__email__ = "commonocean@lists.lrz.de"
__status__ = "released"
class LineDataUnits(Line2D):
 def __init__(self, *args, **kwargs):
 _lw_data = kwargs.pop("linewidth", 1)
 super().__init__(*args, **kwargs)
 self._lw_data = _lw_data
 def _get_lw(self):
 if self.axes is not None:
 ppd = 72. / self.axes.figure.dpi
 trans = self.axes.transData.transform
 return ((trans((1, self._lw_data)) - trans((0, 0))) * ppd)[1]
 else:
 return 1
 def _set_lw(self, lw):
 self._lw_data = lw
 _linewidth = property(_get_lw, _set_lw)
def draw_polygon_as_patch(vertices, ax, zorder=5, facecolor='#ffffff',
 edgecolor='#000000', lw=0.5, alpha=1.0) -> mpl.patches.Patch:
 """
 vertices are no closed polygon (first element != last element)
 """
 return draw_polygon_as_patch_cr(vertices, ax, zorder, facecolor, edgecolor, lw, alpha)
def draw_polygon_collection_as_patch(vertices: List[list], ax, zorder=5, facecolor='#ffffff',
 edgecolor='#000000', lw=0.5, alpha=1.0,
 antialiased=True) -> mpl.collections.Collection:
 """
 vertices are no closed polygon (first element != last element)
 """
 return draw_polygon_collection_as_patch_cr(vertices, ax, zorder, facecolor, edgecolor, lw, alpha, antialiased)
def approximate_bounding_box_dyn_obstacles(obj: list, time_step=0) -> Union[Tuple[list], None]:
 """
 Compute bounding box of dynamic obstacles at time step
 :param obj: All possible objects. DynamicObstacles are filtered.
 :return:
 """
 def update_bounds(new_point: np.ndarray, bounds: List[list]):
 """Update bounds with new point"""
 if new_point[0] < bounds[0][0]:
 bounds[0][0] = new_point[0]
 if new_point[1] < bounds[1][0]:
 bounds[1][0] = new_point[1]
 if new_point[0] > bounds[0][1]:
 bounds[0][1] = new_point[0]
 if new_point[1] > bounds[1][1]:
 bounds[1][1] = new_point[1]
 return bounds
 dynamic_obstacles_filtered = []
 for o in obj:
 if type(o) == DynamicObstacle:
 dynamic_obstacles_filtered.append(o)
 elif type(o) == Scenario:
 dynamic_obstacles_filtered.extend(o.dynamic_obstacles)
 x_int = [np.inf, -np.inf]
 y_int = [np.inf, -np.inf]
 bounds = [x_int, y_int]
 for obs in dynamic_obstacles_filtered:
 occ = obs.occupancy_at_time(time_step)
 if occ is None: continue
 shape = occ.shape
 if hasattr(shape, 'center'):
 bounds = update_bounds(shape.center, bounds=bounds)
 elif hasattr(shape, 'vertices'):
 v = shape.vertices
 bounds = update_bounds(np.min(v, axis=0), bounds=bounds)
 bounds = update_bounds(np.max(v, axis=0), bounds=bounds)
 if np.inf in bounds[0] or -np.inf in bounds[0] or np.inf in bounds[1] or -np.inf in bounds[1]:
 return None
 else:
 return tuple(bounds)
</src\commonocean\visualization\util.py>

<src\concrete_level\concrete_scene_abstractor.py>
from itertools import chain, permutations
from typing import Any, Dict, List, Set, Tuple
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from functional_level.metamodels.functional_scenario import FuncObject, FunctionalScenario
from functional_level.metamodels.interpretation import CrossingFromPortInterpretation, HeadOnInterpretation, OSInterpretation, OvertakingInterpretation, TSInterpretation, VesselClass1Interpretation, VesselClass2Interpretation, VesselClass3Interpretation, VesselClass4Interpretation, VesselClass5Interpretation, VesselClass0Interpretation, VesselClass6Interpretation, VesselClass7Interpretation, VesselClass8Interpretation, VesselInterpretation
from functional_level.models.functional_model_manager import FunctionalModelManager
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.mapping.instance_initializer import RandomInstanceInitializer
from logical_level.mapping.logical_scenario_builder import LogicalScenarioBuilder
from logical_level.models.logical_scenario import LogicalScenario
from concrete_level.models.concrete_scene import ConcreteScene
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.models.actor_variable import ActorVariable, VesselVariable
from logical_level.models.relation_constraints import RelationConstrComposite, RelationConstrTerm
from logical_level.models.vessel_types import ALL_VESSEL_TYPES
class ConcreteSceneAbstractor():
 __all_scenario_hash_cache : Dict[int, List[Tuple[int, FunctionalScenario]]] = {}
 __ambiguous_scenario_hash_cache : Dict[int, List[Tuple[int, FunctionalScenario]]] = {}
 @staticmethod
 def get_abstractions_from_concrete(scene : ConcreteScene, init_method = RandomInstanceInitializer.name) -> MultiLevelScenario:
 os_interpretation = OSInterpretation()
 ts_interpretation = TSInterpretation()
 head_on_interpretation = HeadOnInterpretation()
 overtaking_interpretation = OvertakingInterpretation()
 crossing_interpretation = CrossingFromPortInterpretation()
 vessel_class_interpretations : List[VesselInterpretation] = [VesselClass0Interpretation(), VesselClass1Interpretation(),
 VesselClass2Interpretation(), VesselClass3Interpretation(),
 VesselClass4Interpretation(), VesselClass5Interpretation(),
 VesselClass6Interpretation(), VesselClass7Interpretation(),
 VesselClass8Interpretation()]
 vessel_object_map: Dict[ConcreteVessel, FuncObject] = dict()
 vessel_actor_map: Dict[ConcreteVessel, VesselVariable] = dict()
 for vessel in scene.sorted_keys:
 obj = FuncObject(vessel.id)
 vessel_object_map[vessel] = obj
 logical_actor = vessel.logical_variable
 vessel_actor_map[vessel] = logical_actor
 vessel_class_interpretations[ALL_VESSEL_TYPES.index(logical_actor.vessel_type)].add(obj)
 if vessel.is_os:
 os_interpretation.add(obj)
 else:
 ts_interpretation.add(obj)
 actor_variables : List[ActorVariable] = list(vessel_actor_map.values())
 relation_constr_exprs : Set[RelationConstrComposite] = set()
 assignments = Assignments(actor_variables).update_from_individual(scene.individual)
 vessel_pairs = list(permutations(scene.actors, 2))
 for v1, v2 in vessel_pairs:
 if not ConcreteScene.is_os_ts_pair(v1, v2):
 continue
 obj1, obj2 = vessel_object_map[v1], vessel_object_map[v2]
 var1, var2 = vessel_actor_map[v1], vessel_actor_map[v2]
 # Define terms and their corresponding actions
 exprs_and_assertions : List[Tuple[RelationConstrComposite, RelationConstrComposite, Any]] = [
 #(LogicalScenarioBuilder.get_no_collide_out_vis_clause(var1, var2), None),
 (LogicalScenarioBuilder.get_crossing_term_soft(var1, var2), LogicalScenarioBuilder.get_crossing_term(var1, var2), lambda: crossing_interpretation.add(obj1, obj2)),
 (LogicalScenarioBuilder.get_overtaking_term_soft(var1, var2), LogicalScenarioBuilder.get_overtaking_term(var1, var2), lambda: overtaking_interpretation.add(obj1, obj2)),
 (LogicalScenarioBuilder.get_head_on_term_soft(var1, var2), LogicalScenarioBuilder.get_head_on_term(var1, var2), lambda: head_on_interpretation.add(obj1, obj2)),
 ]
 eval_cache = EvaluationCache(assignments)
 for soft_distance_expr, expr, assertion in exprs_and_assertions:
 penalty = soft_distance_expr._evaluate_penalty(eval_cache)
 if penalty.is_zero:
 relation_constr_exprs.add(expr)
 assertion()
 break
 functional_scenario = FunctionalScenario(os_interpretation, ts_interpretation,
 head_on_interpretation, overtaking_interpretation,
 crossing_interpretation, *vessel_class_interpretations)
 xl = list(chain.from_iterable([var.lower_bounds for var in actor_variables]))
 xu = list(chain.from_iterable([var.upper_bounds for var in actor_variables]))
 initializer = LogicalScenarioBuilder.get_initializer(init_method, actor_variables)
 logical_scenario = LogicalScenario(initializer, RelationConstrTerm(relation_constr_exprs), xl, xu)
 return MultiLevelScenario(scene, logical_scenario, functional_scenario)
 @staticmethod
 def get_abstractions_from_eval(eval_data : EvaluationData) -> MultiLevelScenario:
 return ConcreteSceneAbstractor.get_abstractions_from_concrete(eval_data.best_scene, eval_data.init_method)
 @staticmethod
 def __get_equivalence_class_distribution(equivalence_classes : Dict[int, Tuple[FunctionalScenario, int]], scenes : List[ConcreteScene]) -> Tuple[Dict[int, Tuple[FunctionalScenario, int]], Dict[int, Tuple[FunctionalScenario, int]]]:
 extra_scenarios : Dict[int, Tuple[FunctionalScenario, int]] = {}
 for scene in scenes:
 scenario = ConcreteSceneAbstractor.get_abstractions_from_concrete(scene)
 hash = scenario.functional_scenario.shape_hash()
 if hash not in equivalence_classes:
 #print('WARNING: new equivalence class found')
 if hash not in extra_scenarios:
 extra_scenarios[hash] = (scenario.functional_scenario, 1)
 else:
 _, count = extra_scenarios[hash]
 extra_scenarios[hash] = (scenario.functional_scenario, count + 1)
 else:
 _, count = equivalence_classes[hash]
 equivalence_classes[hash] = (scenario.functional_scenario, count + 1)
 return equivalence_classes, extra_scenarios
 @staticmethod
 def get_all_equivalence_classes(vessel_number):
 if vessel_number not in ConcreteSceneAbstractor.__all_scenario_hash_cache:
 ConcreteSceneAbstractor.__all_scenario_hash_cache[vessel_number] = [(scenario.shape_hash(), scenario) for scenario in FunctionalModelManager.get_x_vessel_scenarios(vessel_number)]
 return {shape_hash : (scenario, 0) for shape_hash, scenario in ConcreteSceneAbstractor.__all_scenario_hash_cache[vessel_number]}
 @staticmethod
 def get_ambiguous_equivalence_classes(vessel_number):
 if vessel_number not in ConcreteSceneAbstractor.__ambiguous_scenario_hash_cache:
 ConcreteSceneAbstractor.__ambiguous_scenario_hash_cache[vessel_number] = [(scenario.shape_hash(), scenario) for scenario in FunctionalModelManager.get_x_vessel_ambiguous_scenarios(vessel_number)]
 return {shape_hash : (scenario, 0) for shape_hash, scenario in ConcreteSceneAbstractor.__ambiguous_scenario_hash_cache[vessel_number]}
 @staticmethod
 def get_equivalence_class_distribution(scenes : List[ConcreteScene], vessel_number) -> Dict[int, Tuple[FunctionalScenario, int]]:
 equivalence_classes = ConcreteSceneAbstractor.get_all_equivalence_classes(vessel_number)
 return ConcreteSceneAbstractor.__get_equivalence_class_distribution(equivalence_classes, scenes)[0]
 @staticmethod
 def get_unspecified_equivalence_class_distribution(scenes : List[ConcreteScene], vessel_number) -> Dict[int, Tuple[FunctionalScenario, int]]:
 equivalence_classes = ConcreteSceneAbstractor.get_all_equivalence_classes(vessel_number)
 return ConcreteSceneAbstractor.__get_equivalence_class_distribution(equivalence_classes, scenes)[1]
 @staticmethod
 def get_ambiguous_equivalence_class_distribution(scenes : List[ConcreteScene], vessel_number) -> Dict[int, Tuple[FunctionalScenario, int]]:
 equivalence_classes = ConcreteSceneAbstractor.get_ambiguous_equivalence_classes(vessel_number)
 return ConcreteSceneAbstractor.__get_equivalence_class_distribution(equivalence_classes, scenes)[0]
</src\concrete_level\concrete_scene_abstractor.py>

<src\concrete_level\data_parser.py>
from abc import ABC, abstractmethod
from dataclasses import asdict
from typing import List, Tuple
import pandas as pd
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
import tkfilebrowser
from utils.file_system_utils import ASSET_FOLDER, get_all_file_paths
from concrete_level.trajectory_generation.trajectory_data import TrajectoryData
class DataParser(ABC):
 gen_data_dir = f'{ASSET_FOLDER}/gen_data'
 RRT_DIR = f'{gen_data_dir}/RRTStar_algo'
 EVAL_DATA_COLUMN_NAMES = list(sorted(asdict(EvaluationData()).keys()))
 TRAJ_COLUMN_NAMES = ['trajectories', 'config_name', 'measurement_name', 'rrt_evaluation_times',
 'iter_numbers', 'overall_eval_time', 'path', 'env_path', 'expand_distance',
 'goal_sample_rate', 'random_seed']
 def __init__(self, column_names : List[str], dir : str) -> None:
 self.column_names = column_names
 self.dir = dir
 def get_data_lines(self, files : List[str]) -> List[dict]:
 return [self.load_dict_from_file(file) for file in files]
 @abstractmethod
 def load_dict_from_file(self, file : str) -> dict:
 pass
 def load_df_from_files(self, files : List[str]) -> pd.DataFrame:
 data_lines = self.get_data_lines(files)
 data_lists : List[List[float]] = []
 for data in data_lines:
 measurement_data = []
 if data['error_message'] != None and data['best_solution'] != None:
 continue
 for column in self.column_names:
 measurement_data.append(data[column])
 data_lists.append(measurement_data)
 return pd.DataFrame(data_lists, columns=self.column_names)
 def load_dirs_merged(self, dirs=[]) -> Tuple[pd.DataFrame, List[str]]:
 files = []
 if len(dirs) == 0:
 dirs = tkfilebrowser.askopendirnames(initialdir=self.dir)
 for dir in dirs:
 files += get_all_file_paths(dir, 'json')
 if len(files) == 0:
 continue
 return self.load_df_from_files(files), dirs
class EvalDataParser(DataParser):
 def __init__(self) -> None:
 super().__init__(self.EVAL_DATA_COLUMN_NAMES, self.gen_data_dir)
 def load_data_models(self) -> List[EvaluationData]:
 files = tkfilebrowser.askopenfilenames(initialdir=self.dir)
 return self.load_data_models_from_files(files)
 def load_data_models_from_files(self, files : List[str]) -> List[EvaluationData]:
 data_models = [self.load_model_from_file(file) for file in files]
 return [model for model in data_models if model.error_message is None and model.best_scene is not None]
 def load_dirs_merged_as_models(self) -> List[EvaluationData]:
 files = []
 for dir in tkfilebrowser.askopendirnames(initialdir=self.dir):
 files += get_all_file_paths(dir, 'json')
 if len(files) == 0:
 continue
 return self.load_data_models_from_files(files)
 def load_dict_from_file(self, file : str) -> dict:
 dict = EvaluationData.load_dict_from_json(file)
 dict['path'] = file
 return dict
 def load_model_from_file(self, file : str) -> EvaluationData:
 model : EvaluationData = EvaluationData.load_from_json(file)
 model.path = file
 return model
class TrajDataParser(DataParser):
 def __init__(self) -> None:
 super().__init__(self.TRAJ_COLUMN_NAMES, self.RRT_DIR)
 def load_data_models(self) -> List[TrajectoryData]:
 files = tkfilebrowser.askopenfilenames(initialdir=self.dir)
 return self.load_models_from_files(files)
 def load_models_from_files(self, files : List[str]) -> List[TrajectoryData]:
 data_models = [self.load_model_from_file(file) for file in files]
 return [model for model in data_models if model.error_message is None and model.trajectories is not None]
 def load_dict_from_file(self, file : str) -> dict:
 dict = TrajectoryData.load_dict_from_json(file)
 dict['path'] = file
 return dict
 def load_model_from_file(self, file : str) -> TrajectoryData:
 model : EvaluationData = TrajectoryData.load_from_json(file)
 model.path = file
 return model
</src\concrete_level\data_parser.py>

<src\concrete_level\models\concrete_scene.py>
from dataclasses import dataclass
from itertools import combinations
from typing import Any, Dict, List, Optional, Set, Type
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.models.actor_variable import ActorVariable
from logical_level.models.relation_constraints import DoCollide, MayCollide
from utils.serializable import Serializable
@dataclass(frozen=True)
class ConcreteScene(Serializable):
 _data : Dict[ConcreteVessel, VesselState]
 dcpa : Optional[float] = None
 tcpa : Optional[float] = None
 danger_sector : Optional[float] = None
 proximity_index : Optional[float] = None
 @property
 def has_risk_metrics(self):
 return all(value is not None for value in [self.dcpa, self.tcpa, self.danger_sector, self.proximity_index])
 def __post_init__(self):
 object.__setattr__(self, '_data', dict(self._data))
 def __getitem__(self, key):
 return self._data[key]
 @property
 def actors(self):
 return [actor for actor, _ in self.sorted_items]
 @property
 def all_actor_pairs(self):
 return {(ai, aj) for ai, aj in combinations(self.actors, 2)}
 @property
 def actor_states(self):
 return self._data.values()
 def items(self):
 return self._data.items()
 @property
 def sorted_items(self):
 return sorted(self.items(), key=lambda item: item[0].id)
 @property
 def sorted_keys(self) -> List[ConcreteVessel]:
 return [key for key, value in self.sorted_items]
 def get(self, key, default=None):
 return self._data.get(key, default)
 def __len__(self):
 return len(self._data)
 def __iter__(self):
 return iter(self._data)
 def __repr__(self):
 return f"{self.__class__.__name__}({self._data})"
 def as_dict(self) -> Dict[ConcreteVessel, VesselState]:
 return self._data
 @property
 def individual(self) -> List[float]:
 individual : List[float] = []
 for vessel, state in self.sorted_items:
 individual += [state.x, state.y, state.heading, vessel.length, state.speed]
 return individual
 @property
 def vessel_number(self) -> int:
 return len(self)
 @property
 def os(self) -> ConcreteVessel:
 vessel = next((actor for actor in self.actors if actor.is_os), None)
 if vessel is None:
 raise ValueError('No OS in the scene.')
 return vessel
 @property
 def non_os(self) -> Set[ConcreteVessel]:
 return {actor for actor in self.actors if not actor.is_os}
 def assignments(self, variables : List[ActorVariable]) -> Assignments:
 if len(self) != len(variables):
 raise ValueError('Variable and actor numbers do not match.')
 for actor, var in zip(self.sorted_keys, variables):
 if actor.id != var.id:
 raise ValueError('Insufficient order of actors and variables.')
 return Assignments(variables).update_from_individual(self.individual)
 def may_collide(self, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> bool:
 vars = {v : v.logical_variable for v in self.actors}
 return MayCollide(vars[actor1], vars[actor2]).evaluate_penalty(self.assignments(list(vars.values()))).is_zero
 def do_collide(self, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> bool:
 vars = {v : v.logical_variable for v in self.actors}
 return DoCollide(vars[actor1], vars[actor2]).evaluate_penalty(self.assignments(list(vars.values()))).is_zero
 def others_than(self, vessel : ConcreteVessel) -> List[ConcreteVessel]:
 return [v for v in self.actors if v is not vessel]
 def to_dict(self):
 result = {}
 for key, value in self.__dict__.items():
 if key == '_data':
 result[key] = [(vessel.to_dict(), state.to_dict())
 for vessel, state in self._data.items()]
 else: # Handle primitive types
 result[key] = value
 return result
 @classmethod
 def from_dict(cls: Type['ConcreteScene'], data: Dict[str, Any]) -> 'ConcreteScene':
 copy_data = data.copy()
 for attr, value in data.items():
 if attr == '_data':
 copy_data[attr] = {
 ConcreteVessel.from_dict(vessel):
 VesselState.from_dict(state)
 for vessel, state in value
 }
 return ConcreteScene(**copy_data)
 @staticmethod
 def is_os_ts_pair(v1 : ConcreteVessel, v2 : ConcreteVessel) -> bool:
 return (v1.is_os and not v2.is_os) or (v2.is_os and not v1.is_os)
</src\concrete_level\models\concrete_scene.py>

<src\concrete_level\models\concrete_vessel.py>
from dataclasses import dataclass
from typing import Any, Dict, Optional, Type
from logical_level.models.actor_variable import OSVariable, TSVariable, VesselVariable
from logical_level.models.vessel_types import VesselType
from utils.serializable import Serializable
@dataclass(frozen=True)
class ConcreteVessel(Serializable):
 id: int
 is_os : bool
 length: float
 radius: float
 max_speed: float
 vessel_type : str
 beam: Optional[float] = None
 @property
 def name(self) -> str:
 return f'OS_{self.id}' if self.is_os else f'TS_{self.id}'
 def __repr__(self):
 return self.name
 @property
 def max_turning_angle(self) -> float:
 return self.max_speed / 2.5 * self.length
 @property
 def max_acceleration(self) -> float:
 return self.max_speed**2 / (2* 15 * self.length)
 @property
 def logical_variable(self) -> VesselVariable:
 t = VesselType.get_vessel_type_by_name(self.vessel_type)
 if t is None :
 raise TypeError('Vessel type is not found')
 if self.is_os:
 return OSVariable(self.id, t)
 else:
 return TSVariable(self.id, t)
 @classmethod
 def from_dict(cls: Type['ConcreteVessel'], data: Dict[str, Any]) -> 'ConcreteVessel':
 return ConcreteVessel(**data)
</src\concrete_level\models\concrete_vessel.py>

<src\concrete_level\models\multi_level_scenario.py>
from typing import Dict, Optional, Set, Tuple, Union
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from functional_level.metamodels.functional_scenario import FuncObject, FunctionalScenario
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache, GeometricProperties
from logical_level.models.actor_variable import ActorVariable
from logical_level.models.logical_scenario import LogicalScenario
from logical_level.models.relation_constraints import DoCollide, MayCollide
class MultiLevelScenario():
 def __init__(self, concrete_scene : ConcreteScene,
 logical_scenario : LogicalScenario, functional_scenario : FunctionalScenario):
 self.concrete_scene = concrete_scene
 self.logical_scenario = logical_scenario
 self.functional_scenario = functional_scenario
 self.concrete_actor_map : Dict[int, ConcreteVessel] = {actor.id : actor for actor in self.concrete_scene.actors}
 self.logical_actor_map : Dict[int, ActorVariable] = {actor.id : actor for actor in self.logical_scenario.actor_vars}
 self.functional_object_map : Dict[int, FuncObject] = {obj.id : obj for obj in self.functional_scenario.func_objects}
 self.evaluation_cache = EvaluationCache(self.concrete_scene.assignments(self.logical_scenario.actor_vars))
 def to_concrete_vessel(self, actor_or_obj : Union[ActorVariable, FuncObject]) -> ConcreteScene:
 return self.concrete_actor_map[actor_or_obj.id]
 def to_variable(self, actor_or_obj : Union[ConcreteVessel, FuncObject]) -> ActorVariable:
 return self.logical_actor_map[actor_or_obj.id]
 def to_object(self, actor_or_var : Union[ActorVariable, ConcreteVessel]) -> FuncObject:
 return self.functional_object_map[actor_or_var.id]
 def get_geo_props(self, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> GeometricProperties:
 var1, var2 = self.to_variable(actor1), self.to_variable(actor2)
 return self.evaluation_cache.get_props(var1, var2)
 def may_collide(self, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> bool:
 var1, var2 = self.to_variable(actor1), self.to_variable(actor2)
 may_collide = MayCollide(var1, var2)
 return may_collide._evaluate_penalty(self.evaluation_cache).is_zero
 def do_collide(self, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> bool:
 var1, var2 = self.to_variable(actor1), self.to_variable(actor2)
 do_collide = DoCollide(var1, var2)
 return do_collide._evaluate_penalty(self.evaluation_cache).is_zero
 def may_collide_anyone(self, actor1 : ConcreteVessel) -> bool:
 for actor2 in self.concrete_actor_map.values():
 if actor1 == actor2:
 continue
 if self.may_collide(actor1, actor2):
 return True
 return False
 @property
 def os_non_os_pairs(self) -> Set[Tuple[ConcreteVessel, ConcreteVessel]]:
 os = self.concrete_scene.os
 return {(os, actor) for actor in self.concrete_scene.non_os}
 def get_vessel_name(self, vessel : ConcreteVessel) -> str:
 return self.to_variable(vessel).name
 def modify_copy(self, vessel: ConcreteVessel, x : Optional[float] = None, y : Optional[float] = None,
 speed : Optional[float] = None, heading : Optional[float] = None) -> 'MultiLevelScenario':
 new_state = self.concrete_scene[vessel].modify_copy(x=x, y=y, speed=speed, heading=heading)
 new_scene = SceneBuilder(self.concrete_scene.as_dict()).set_state(vessel, new_state).build()
 return MultiLevelScenario(new_scene, self.logical_scenario, self.functional_scenario)
</src\concrete_level\models\multi_level_scenario.py>

<src\concrete_level\models\rrt_models.py>
from abc import ABC, abstractmethod
from enum import Enum, auto
import random
from typing import List, Optional, Tuple
import numpy as np
from shapely import Point, Polygon
from concrete_level.models.vessel_state import VesselState
class TrajectoryState(Enum):
 START = auto()
 STAND_ON_1 = auto()
 GIVE_WAY_ARC = auto()
 GIVE_WAY_ARC_ADJUST = auto()
 STAND_ON_2 = auto()
 RETURN_ARC = auto()
 RETURN_ARC_ADJUST = auto()
 STAND_ON_3 = auto()
class RandomPoint():
 def __init__(self, p : np.ndarray, towards_goal : bool) -> None:
 self.p = p
 self.towards_goal = towards_goal
 @staticmethod
 def get(sample_area : List[Tuple[float, float]]):
 return RandomPoint(np.array([random.uniform(*sample_area[0]), random.uniform(*sample_area[1])]), False)
class RRTNode():
 """
 RRT Node
 """
 def __init__(self, p : np.ndarray):
 self.p = p
 self.distance_cost = 0.0
 self.time_cost : int = 0
 self.s_fraction : float = 0.0
 self.parent : Optional[int] = None
 self.children : set[int] = set()
 @staticmethod
 def calc_cost(vessel_state : VesselState, d : float) -> Tuple[int, float]:
 # Calculate the distance and heading between the points
 s_dist = int(d // vessel_state.speed)
 # Calculate the number of seconds required to cover the distance
 s_fraction = d / vessel_state.speed - s_dist
 if s_fraction > 0.0001:
 return s_dist + 1, d / vessel_state.speed - s_dist
 return s_dist, 0.0
 def set_cost(self, d : float, time : int, fraction : bool):
 self.distance_cost = d
 self.time_cost = time
 self.s_fraction = fraction
class Obstacle(ABC):
 MARGIN = 0.02
 def __init__(self, x : float, y : float) -> None:
 super().__init__()
 self.p = np.array([x, y])
 @abstractmethod
 def check_no_collision(self, node : RRTNode) -> bool:
 pass
class CircularObstacle(Obstacle):
 def __init__(self, p : np.ndarray, radius : float) -> None:
 super().__init__(p[0], p[1])
 self.radius = radius
 def check_no_collision(self, node : RRTNode) -> bool:
 d = np.linalg.norm(node.p - self.p)
 if d <= self.radius + self.radius * self.MARGIN:
 return False # collision
 return True # safe
 def __str__(self) -> str:
 return f'Circle'
class PolygonalObstacle(Obstacle):
 def __init__(self, p1: np.ndarray, p2: np.ndarray, p3: np.ndarray, p4: np.ndarray) -> None:
 super().__init__(p1[0], p1[1])
 self.polygon = [p1, p2, p3, p4]
 # Create a Polygon object
 self.polygon_shape = Polygon(self.polygon)
 def check_no_collision(self, node : RRTNode) -> bool:
 point = Point(node.p[0], node.p[1])
 return not self.polygon_shape.contains(point)
 def __str__(self) -> str:
 return f'Polygon'
class LineObstacle(Obstacle):
 def extend(self):
 return LineObstacle(self.p[0], self.p[1], self.dir_vec, self.above_initial_point, self.shift*2)
 def __init__(self, x : float, y : float, dir_vec : np.ndarray, above_initial_point : bool, shift) -> None:
 super().__init__(x, y)
 self.shift = shift
 self.dir_vec = dir_vec
 self.above_initial_point = above_initial_point
 if above_initial_point:
 perpendicular = np.array([-dir_vec[1], dir_vec[0]])
 else:
 perpendicular = np.array([dir_vec[1], -dir_vec[0]])
 # Normalize the perpendicular vector
 self.perpendicular = perpendicular / np.linalg.norm(perpendicular)
 # Compute the shifted point on the line
 self.shifted_point = self.p + self.shift * self.perpendicular
 def __str__(self) -> str:
 return f'Line {"above" if self.above_initial_point else "below"} initial'
 def check_no_collision(self, node : RRTNode) -> bool:
 # Compute the cross product to determine the position relative to the shifted line
 # Line equation is implicit: (P - shifted_point) dotted with the perpendicular vector should be checked
 position_value = np.dot(self.perpendicular, node.p - self.shifted_point)
 if self.above_initial_point:
 if position_value > 0:
 return False # collision
 else:
 return True # safe
 else:
 if position_value < 0:
 return True # collision
 else:
 return False # safe
 # Determine if point is above or below the shifted line
</src\concrete_level\models\rrt_models.py>

<src\concrete_level\models\trajectories.py>
from collections import defaultdict
from dataclasses import dataclass, asdict
import json
from typing import Any, Dict, List, Type
import numpy as np
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from concrete_level.models.concrete_scene import ConcreteScene
from utils.serializable import Serializable
@dataclass(frozen=True)
class Trajectories(Serializable):
 _data : Dict[ConcreteVessel, List[VesselState]]
 def __post_init__(self):
 object.__setattr__(self, '_data', dict(self._data).copy())
 def __getitem__(self, key):
 return self._data[key]
 def keys(self):
 return self._data.keys()
 def values(self):
 return self._data.values()
 def items(self):
 return self._data.items()
 def get(self, key, default=None):
 return self._data.get(key, default)
 def __len__(self):
 return len(self._data)
 def __iter__(self):
 return iter(self._data)
 def __repr__(self):
 return f"{self.__class__.__name__}({self._data})"
 def get_scene(self, t : int) -> ConcreteScene:
 if t >= self.timespan:
 raise ValueError('Timespan out of range.')
 sb = SceneBuilder()
 for vessel, states in self.items():
 sb.set_state(vessel, states[t])
 return sb.build()
 @property
 def timespan(self) -> int:
 return 0 if len(self._data) == 0 else min(len(states) for states in self._data.values())
 @property
 def initial_scene(self) -> ConcreteScene:
 return self.get_scene(0)
 def collision_points(self, vessel : ConcreteVessel) -> Dict[ConcreteVessel, List[np.ndarray]]:
 other_vessels = [v for v in self.keys() if v is not vessel]
 collision_points : Dict[ConcreteVessel, List[np.ndarray]] = defaultdict(list)
 for vessel2 in other_vessels:
 for t in range(self.timespan):
 scene = self.get_scene(t)
 if scene.do_collide(vessel, vessel2):
 collision_points[vessel2] += [scene[vessel].p, scene[vessel2].p]
 return collision_points
 def to_dict(self):
 result = {}
 for key, value in self.__dict__.items():
 if key == '_data':
 result[key] = [(vessel.to_dict(), [state.to_dict() for state in states])
 for vessel, states in self._data.items()]
 else: # Handle primitive types
 result[key] = value
 return result
 @classmethod
 def from_dict(cls: Type['Trajectories'], data: Dict[str, Any]) -> 'Trajectories':
 copy_data = data.copy()
 for attr, value in data.items():
 if attr == '_data':
 copy_data[attr] = {
 ConcreteVessel.from_dict(vessel):
 [VesselState.from_dict(state) for state in states]
 for vessel, states in value
 }
 return Trajectories(**copy_data)
</src\concrete_level\models\trajectories.py>

<src\concrete_level\models\trajectory_manager.py>
from typing import Union
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.models.trajectories import Trajectories
from concrete_level.trajectory_generation.trajectory_builder import TrajectoryBuilder
class TrajectoryManager():
 def __init__(self, trajectories : Union[Trajectories, ConcreteScene]) -> None:
 if isinstance(trajectories, ConcreteScene):
 self.trajectories = TrajectoryBuilder.default_trajectory_from_scene(trajectories)
 elif isinstance(trajectories, Trajectories):
 self.trajectories : Trajectories = trajectories
 else:
 raise ValueError('The passed parameter has incorrect type.')
 self.scenario = ConcreteSceneAbstractor.get_abstractions_from_concrete(self.trajectories.get_scene(0))
 self.logical_scenario = self.scenario.logical_scenario
 self.functional_scenario = self.scenario.functional_scenario
 self.concrete_scene = self.scenario.concrete_scene
 def get_scenario(self, t : int) -> MultiLevelScenario:
 return MultiLevelScenario(self.trajectories.get_scene(t), self.logical_scenario, self.functional_scenario)
 @property
 def timespan(self):
 return self.trajectories.timespan
</src\concrete_level\models\trajectory_manager.py>

<src\concrete_level\models\vessel_order_graph.py>
from typing import Dict, List, Tuple
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from functional_level.metamodels.functional_object import FuncObject
from functional_level.metamodels.functional_scenario import FunctionalScenario
class VesselNode():
 def __init__(self, vessel: ConcreteVessel) -> None:
 self.vessel = vessel
 self.relations : List[Tuple[ConcreteVessel, ConcreteVessel]] = []
 self.in_degree = 0
 self.out_degree = 0
 def __eq__(self, value: object) -> bool:
 return (isinstance(value, VesselNode) and
 self.vessel == value.vessel)
 def __repr__(self) -> str:
 return self.vessel.__repr__()
class VesselOrderGraph():
 def __init__(self, scenario : MultiLevelScenario):
 self.nodes : Dict[ConcreteVessel, VesselNode] = {}
 self.in_degree : Dict[VesselNode, int] = {}
 self.out_degree : Dict[VesselNode, int] = {}
 relations = [(scenario.to_concrete_vessel(obj1), scenario.to_concrete_vessel(obj2)) for obj1, obj2 in scenario.functional_scenario.binary_interpretation_tuples]
 for rel in relations:
 self.add_nodes(rel)
 for rel in relations:
 self.add_edge(rel)
 def add_nodes(self, rel : Tuple[ConcreteVessel, ConcreteVessel]):
 node1 = VesselNode(rel[0])
 if rel[0] not in self.nodes:
 self.nodes[rel[0]] = node1
 node2 = VesselNode(rel[1])
 if rel[1] not in self.nodes:
 self.nodes[rel[1]] = node2
 def add_edge(self, rel : Tuple[ConcreteVessel, ConcreteVessel]):
 node1 = self.nodes[rel[0]]
 node2 = self.nodes[rel[1]]
 node1.relations.append(rel)
 node1.out_degree += 1
 node2.in_degree += 1
 def sort(self)-> list[VesselNode]:
 return sorted(self.nodes.values(), key=lambda node: node.out_degree - node.in_degree)
</src\concrete_level\models\vessel_order_graph.py>

<src\concrete_level\models\vessel_state.py>
from dataclasses import dataclass
from typing import Any, Dict, Optional, Type
import numpy as np
from utils.serializable import Serializable
@dataclass(frozen=True)
class VesselState(Serializable):
 x : float
 y : float
 speed : float
 heading : float
 @property
 def p(self) -> np.ndarray:
 return np.array([self.x, self.y])
 @property
 def v(self) -> np.ndarray:
 return np.array([np.cos(self.heading), np.sin(self.heading)]) * self.speed
 @property
 def v_norm(self) -> np.ndarray:
 return self.v / self.speed
 @property
 def v_norm_perp(self) -> np.ndarray:
 return np.array([self.v_norm[1], -self.v_norm[0]])
 def modify_copy(self, x : Optional[float] = None, y : Optional[float] = None,
 speed : Optional[float] = None, heading : Optional[float] = None) -> 'VesselState':
 return VesselState(x or self.x, y or self.y, speed or self.speed, heading or self.heading)
 @classmethod
 def from_dict(cls: Type['VesselState'], data: Dict[str, Any]) -> 'VesselState':
 return VesselState(**data)
</src\concrete_level\models\vessel_state.py>

<src\concrete_level\trajectory_generation\bidirectional_rrt_star_fnd.py>
import random
from typing import List, Optional, Tuple
import numpy as np
from concrete_level.models.vessel_state import VesselState
from utils.asv_utils import N_MILE_TO_M_CONVERSION
from concrete_level.models.vessel_order_graph import VesselNode
from concrete_level.models.rrt_models import LineObstacle, RRTNode, Obstacle, RandomPoint
from concrete_level.trajectory_generation.path_interpolator import PathInterpolator
DIM = 1000
show_animation = True
class BidirectionalRRTStarFND():
 """
 Class for RRT Planning
 """
 def __init__(self, v_node : VesselNode, start_state : VesselState, goal_state : VesselState,
 min_go_around_line : LineObstacle, go_around_split_line : LineObstacle,
 obstacle_list : List[Obstacle], sample_area : List[Tuple[float, float]],
 collision_points : List[np.ndarray], interpolator : PathInterpolator,
 expand_dist=10.0, goal_sample_rate=15, scaler = 1.0, max_nodes = 1500):
 self.vessel = v_node.vessel
 self.collision_points = collision_points
 self.interpolator = interpolator
 self.start = RRTNode(start_state.p)
 self.goal = RRTNode(goal_state.p)
 self.min_go_around_line = min_go_around_line
 self.go_around_split_line = go_around_split_line
 self.delta_pos_start_end = self.goal.p - self.start.p
 self.start_end_distance = np.linalg.norm(self.delta_pos_start_end)
 self.sample_area = sample_area
 self.expand_dist = expand_dist
 self.goal_sample_rate = goal_sample_rate
 self.obstacle_list : List[Obstacle] = obstacle_list
 self.current_i = 0
 self.stop = False
 self.scaler = scaler
 self.max_nodes = max_nodes
 self.start_state = start_state
 if show_animation:
 from visualization.trajectory_visualizer import TrajectoryVisualizer
 self.trajectory_visualizer = TrajectoryVisualizer(DIM, scaler, sample_area)
 self.trajectory_visualizer.set_caption(v_node, interpolator)
 def do_plan(self) -> Optional[List[RRTNode]]:
 while not self.stop:
 if self.current_i % 100 == 0:
 print(self.current_i)
 rnd = self.get_random_point()
 nearest_index = self.get_nearest_list_index(rnd) # get nearest node index to random point
 new_node = self.steer(rnd, nearest_index) # generate new node from that nearest node in direction of random point
 if self.check_no_collision(new_node, self.obstacle_list): # if it does not collide
 nearest_indexes = self.find_near_nodes(new_node, 5) # find nearest nodes to newNode
 found = self.choose_parent(new_node, nearest_indexes) # from that nearest nodes find the best parent to newNode
 if not found:
 continue
 self.node_list[self.current_i + 100] = new_node # add newNode to nodeList
 self.rewire(self.current_i + 100, new_node, nearest_indexes) # make newNode a parent of another node if necessary
 self.node_list[new_node.parent].children.add(self.current_i + 100)
 if len(self.node_list) > self.max_nodes:
 self.prune_branches()
 self.update_anim()
 self.current_i += 1
 # generate course
 lastIndex = self.get_best_last_index()
 if lastIndex is None:
 return None
 path = self.gen_final_course(lastIndex)
 return path
 def update_anim(self):
 if show_animation:
 if self.current_i % 25 == 0:
 self.trajectory_visualizer.update(self.obstacle_list, self.collision_points,
 self.min_go_around_line, self.go_around_split_line,
 self.start, self.goal,
 self.node_list, self.get_best_last_index(), self.gen_final_course)
 if self.trajectory_visualizer.handle_user_input(self.goal, self.obstacle_list, self.path_validation):
 self.stop = True
 def prune_branches(self):
 leaves = [ key for key, node in self.node_list.items() if len(node.children) == 0 and len(self.node_list[node.parent].children) > 1]
 if len(leaves) > 0:
 ind = leaves[random.randint(0, len(leaves)-1)]
 self.node_list[self.node_list[ind].parent].children.discard(ind)
 self.node_list.pop(ind)
 else:
 leaves = [ key for key, node in self.node_list.items() if len(node.children) == 0 ]
 ind = leaves[random.randint(0, len(leaves)-1)]
 self.node_list[self.node_list[ind].parent].children.discard(ind)
 self.node_list.pop(ind)
 def plan_trajectory(self) -> List[RRTNode]:
 """
 plan_trajectory
 animation: flag for animation on or off
 """
 self.node_list = {0 : self.start}
 path = None
 path = self.do_plan()
 if path is None:
 raise Exception('No path is found')
 path.reverse()
 return path
 def path_validation(self):
 lastIndex = self.get_best_last_index()
 if lastIndex is not None:
 while self.node_list[lastIndex].parent is not None:
 nodeInd = lastIndex
 lastIndex = self.node_list[lastIndex].parent
 if not self.check_no_collision_extend(self.node_list[lastIndex], self.node_list[nodeInd])[0]:
 self.node_list[lastIndex].children.discard(nodeInd)
 self.remove_branch(nodeInd)
 def remove_branch(self, nodeInd):
 for ix in self.node_list[nodeInd].children:
 self.remove_branch(ix)
 self.node_list.pop(nodeInd)
 def choose_parent(self, new_node : RRTNode, nearest_indexes):
 if len(nearest_indexes) == 0:
 return False
 min_cost = np.inf
 min_cost_index = None
 for i in nearest_indexes:
 no_coll, dist = self.check_no_collision_extend(self.node_list[i], new_node)
 if no_coll:
 cost = self.node_list[i].distance_cost + dist
 if cost < min_cost:
 min_cost = cost
 min_cost_index = i
 if min_cost_index == None:
 print("min_cost is inf")
 return False
 new_node.distance_cost = min_cost
 new_node.parent = min_cost_index
 return True
 def steer(self, rnd : RandomPoint, nearest_index : int):
 # expand tree
 nearest_node = self.node_list[nearest_index]
 delta_pos = rnd.p - nearest_node.p
 theta = np.arctan2(delta_pos[1], delta_pos[0])
 new_point = nearest_node.p + np.array([np.cos(theta), np.sin(theta)]) * self.expand_dist
 new_node = RRTNode(new_point)
 # # Apply the condition for adjusting theta
 # abs_theta = abs(theta) # Work with absolute value of theta for comparison
 # if abs_theta < np.radians(30):
 # theta = 0 # Set to 0 if below 30 degrees
 # elif abs_theta > np.radians(60):
 # theta = np.sign(theta) * np.radians(60) # Cap at 60 degrees with the same sign
 s_dist, s_fraction = RRTNode.calc_cost(self.start_state, self.expand_dist)
 new_node.set_cost(nearest_node.distance_cost + self.expand_dist, nearest_node.time_cost + s_dist, s_fraction)
 new_node.parent = nearest_index
 return new_node
 def get_random_point(self) -> RandomPoint:
 if random.randint(0, 100) > self.goal_sample_rate:
 return RandomPoint.get(self.sample_area)
 return RandomPoint(self.goal.p.copy(), True)
 def get_best_last_index(self):
 dist_to_goal_list = [(key, np.linalg.norm(self.goal.p - node.p)) for key, node in self.node_list.items()]
 near_goal_indexes = [key for key, distance in dist_to_goal_list if distance <= self.expand_dist]
 if len(near_goal_indexes) == 0:
 return None
 min_cost_index = min(near_goal_indexes, key=lambda i: self.node_list[i].distance_cost)
 return min_cost_index
 def gen_final_course(self, goal_index : int) -> List[RRTNode]:
 path = [self.goal]
 while self.node_list[goal_index].parent is not None:
 node = self.node_list[goal_index]
 path.append(node)
 goal_index = node.parent
 path.append(self.start)
 return path
 def find_near_nodes(self, newNode: RRTNode, value):
 r_squared = (self.expand_dist * value) ** 2 # Compute the squared distance threshold once
 new_p = newNode.p
 node_positions = np.array([node.p for node in self.node_list.values()]) # Extract positions
 node_keys = np.array(list(self.node_list.keys())) # Extract node keys
 # Compute squared distances between nodes and newNode
 dist_squared = np.sum((node_positions - new_p) ** 2, axis=1)
 # Find nodes with distances less than or equal to r_squared
 nearest_indexes = node_keys[dist_squared <= r_squared]
 return nearest_indexes
 def rewire(self, new_node_index : int, new_node : RRTNode, near_indexes : List[int]):
 for i in near_indexes:
 near_node = self.node_list[i]
 d = np.linalg.norm(new_node.p - near_node.p)
 new_cost = new_node.distance_cost + d
 if near_node.distance_cost > new_cost:
 no_coll, dist = self.check_no_collision_extend(new_node, near_node)
 if no_coll:
 self.node_list[near_node.parent].children.discard(i)
 near_node.parent = new_node_index
 s_d, s_fraction = RRTNode.calc_cost(self.start_state, d)
 near_node.set_cost(new_cost, s_d + new_node.time_cost, s_fraction)
 new_node.children.add(i)
 def get_nearest_list_index(self, rnd: RandomPoint):
 rnd_p = rnd.p
 node_keys = list(self.node_list.keys())
 node_positions = np.array([node.p for node in self.node_list.values()])
 # Compute squared distances directly and lazily find the min
 dist_squared = np.sum((node_positions - rnd_p)**2, axis=1)
 # Get the index with the minimum distance
 min_index = node_keys[np.argmin(dist_squared)]
 return min_index
 def check_no_collision_extend(self, parent_node : RRTNode, node : RRTNode) -> Tuple[bool, float]:
 delta_pos = node.p - parent_node.p
 dist = float(np.linalg.norm(delta_pos))
 if parent_node.parent is not None:
 pass
 # delta_pos_parent = parent_node.p - self.node_list[parent_node.parent].p
 # angle_parent = self.angle_between_vectors(delta_pos_parent, delta_pos, dist)
 # if not (np.radians(0) <= angle_parent <= np.radians(3) or
 # np.radians(30) <= angle_parent <= np.radians(60)):
 # return False, dist
 else:
 angle_start_end = self.angle_between_vectors(self.delta_pos_start_end, delta_pos, dist)
 if not (np.radians(0) <= angle_start_end <= np.radians(0.1)):
 return False, dist
 tmpNode = RRTNode(np.array([parent_node.p[0], parent_node.p[1]]))
 s_d, s_fraction = RRTNode.calc_cost(self.start_state, dist)
 s_d = s_d - np.ceil(s_fraction)
 for s in range(int(s_d)):
 fraction = s / s_d
 tmpNode.p = parent_node.p + delta_pos * fraction
 tmpNode.set_cost(0, parent_node.time_cost + s, 0.0)
 if not self.check_no_collision(tmpNode, self.obstacle_list):
 return False, dist
 return True, dist
 def check_no_collision(self, node : RRTNode, obstacleList : List[Obstacle]):
 for obs in obstacleList:
 if not obs.check_no_collision(node):
 #print(f'Hit obstacle {obs} at {node.p}')
 return False
 # The two trajectories will collide at the specific second
 scene = self.interpolator.get_scene_by_second(node.time_cost)
 for vessel2, vessel2_state in scene.items():
 if np.linalg.norm(node.p - vessel2_state.p) <= max(self.vessel.radius, vessel2.radius):
 print(f'Hit trajectory of {vessel2} at {vessel2_state.p}.')
 return False
 return True # safe
 def angle_between_vectors(self, vec1, vec2, dist2):
 # Calculate the dot product
 dot_product = np.dot(vec1, vec2)
 # Calculate the magnitudes of the vectors
 magnitude1 = np.linalg.norm(vec1)
 # Calculate the cosine of the angle
 cos_theta = dot_product / (magnitude1 * dist2)
 # Clip the cosine value to be within the valid range for arccos
 cos_theta = np.clip(cos_theta, -1.0, 1.0)
 # Calculate the angle in radians and then in degrees
 return np.arccos(cos_theta)
</src\concrete_level\trajectory_generation\bidirectional_rrt_star_fnd.py>

<src\concrete_level\trajectory_generation\path_interpolator.py>
from typing import List, Set, Tuple
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.models.rrt_models import RRTNode
from concrete_level.models.trajectories import Trajectories
from concrete_level.models.vessel_state import VesselState
from concrete_level.trajectory_generation.trajectory_builder import TrajectoryBuilder
class PathInterpolator():
 def __init__(self, scenario : MultiLevelScenario) -> None:
 self.trajectory_builder = TrajectoryBuilder()
 self.vessels : Set[ConcreteVessel] = set()
 self.scenario : MultiLevelScenario = scenario
 self.path_length = 45 * 60
 def add_path(self, vessel : ConcreteVessel, path : List[RRTNode]):
 vessel_state = self.scenario.concrete_scene[vessel]
 if vessel in self.trajectory_builder:
 raise Exception("Cannot add two path for one vessel")
 if len(path) == 0:
 self.trajectory_builder[vessel] = [vessel_state]
 else:
 self.trajectory_builder[vessel] = self.interpolate_path(vessel_state, path)
 self.vessels.add(vessel)
 self.trajectory_builder.extend(self.path_length)
 def get_scene_by_second(self, second : int) -> ConcreteScene:
 if second >= self.path_length:
 self.path_length = self.path_length + (second - self.path_length) + 60
 self.trajectory_builder.extend(self.path_length)
 return self.trajectory_builder.build().get_scene(second)
 def interpolate_path(self, vessel_state: VesselState, path : List[RRTNode]) -> List[VesselState]:
 """
 Interpolates the given path to have positions at one-second intervals
 and calculates the heading based on the direction of movement.
 :param positions: List of (x, y) tuples representing the positions.
 :param speed: Speed of the vessel (units per second).
 :return: List of interpolated (position, heading) tuples.
 """
 interpolated_positions = []
 interpolated_headings = []
 interpolated_speeds = []
 for i in range(len(path) - 1):
 # Start and end points
 node_start = path[i]
 node_end = path[i + 1]
 # Calculate the distance and heading between the points
 delta_pos = node_end.p - node_start.p
 heading = np.arctan2(delta_pos[1], delta_pos[0])
 time_cost = node_end.time_cost - node_start.time_cost
 # Interpolate positions for each second
 for s in range(time_cost):
 fraction = s / time_cost
 new_p = node_start.p + delta_pos * fraction
 interpolated_positions.append(new_p)
 interpolated_headings.append(heading)
 interpolated_speeds.append(vessel_state.speed)
 if node_end.s_fraction > 0.0001: # Bigger than some small value
 speed = vessel_state.speed * node_end.s_fraction
 interpolated_speeds[-1] = speed
 # Append the final position and heading
 interpolated_positions.append(path[-1].p)
 interpolated_headings.append(vessel_state.heading)
 interpolated_speeds.append(vessel_state.speed)
 return [VesselState(interpolated_positions[i][0], interpolated_positions[i][1],
 interpolated_speeds[i], heading) for i, heading in enumerate(interpolated_headings)]
 @property
 def trajectories(self) -> Trajectories:
 return self.trajectory_builder.build()
 @staticmethod
 def interpolate_headings(trajectory : List[Tuple[float, float, float, float, float]]) -> List[Tuple[float, float, float, float, float]]:
 headings = [t[2] for t in trajectory]
 def interpolate_chunk(start, end, num_steps):
 """Linearly interpolate between start and end in num_steps steps."""
 step_values = []
 for i in range(num_steps):
 ratio = i / (num_steps - 1) if num_steps > 1 else 0
 interpolated_value = start * (1 - ratio) + end * ratio
 step_values.append(interpolated_value)
 return step_values
 # Find blocks of same heading
 blocks = []
 current_block = [0]
 for i in range(1, len(headings)):
 if headings[i] == headings[current_block[0]]:
 current_block.append(i)
 else:
 blocks.append(current_block)
 current_block = [i]
 blocks.append(current_block)
 # Interpolate between the end of one block to the start of the next
 for i in range(len(blocks) - 1):
 start_block = blocks[i]
 end_block = blocks[i + 1]
 start_value = headings[start_block[-1]]
 end_value = headings[end_block[0]]
 # Interpolate from the last index of the current block to the first index of the next block
 num_steps = len(start_block) + len(end_block)
 interpolated_values = interpolate_chunk(start_value, end_value, num_steps)
 # Replace values in the original list
 for j in range(len(start_block)):
 headings[start_block[j]] = interpolated_values[j]
 for j in range(len(end_block)):
 headings[end_block[j]] = interpolated_values[len(start_block) + j]
 return [(trajectory[i][0], trajectory[i][1], headings[i], trajectory[i][3], trajectory[i][4]) for i in range(len(headings))]
</src\concrete_level\trajectory_generation\path_interpolator.py>

<src\concrete_level\trajectory_generation\scene_builder.py>
import random
from typing import Dict
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.models.concrete_scene import ConcreteScene
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.models.actor_variable import VesselVariable
from logical_level.models.vessel_types import ALL_VESSEL_TYPES
class SceneBuilder(Dict[ConcreteVessel, VesselState]):
 def __init__(self, existing_dict=None, *args, **kwargs):
 # Initialize with an empty dict if no existing_dict is provided
 if existing_dict is None:
 existing_dict = {}
 # Call the parent constructor with the provided data
 super().__init__(existing_dict, *args, **kwargs)
 def set_state(self, vessel : ConcreteVessel, state : VesselState) -> 'SceneBuilder':
 self[vessel] = state
 return self
 def build(self, dcpa = None, tcpa = None, danger_sector = None, proximity_index = None) -> ConcreteScene:
 return ConcreteScene(self, dcpa, tcpa, danger_sector, proximity_index)
 @staticmethod
 def build_from_assignments(assignments : Assignments) -> ConcreteScene:
 builder = SceneBuilder()
 for actor_var, values in assignments.items():
 if isinstance(actor_var, VesselVariable):
 vessel_type = actor_var.vessel_type
 if vessel_type is None:
 valid_types = [t for t in ALL_VESSEL_TYPES if t.do_match(values.l, values.sp)]
 vessel_type = random.choice(valid_types)
 builder.set_state(ConcreteVessel(actor_var.id, actor_var.is_os, values.l, values.r, vessel_type.max_speed, vessel_type.name),
 VesselState(values.x, values.y, values.sp, values.h))
 else:
 raise TypeError('Unsupported Actor')
 return builder.build()
</src\concrete_level\trajectory_generation\scene_builder.py>

<src\concrete_level\trajectory_generation\trajectory_builder.py>
from typing import Dict, List
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.trajectories import Trajectories
from utils.asv_utils import ONE_HOUR_IN_SEC
class TrajectoryBuilder(Dict[ConcreteVessel, List[VesselState]]):
 def __init__(self, existing_dict : Dict[ConcreteVessel, List[VesselState]]={}, *args, **kwargs):
 super().__init__(existing_dict.copy(), *args, **kwargs)
 def add_state(self, vessel : ConcreteVessel, state : VesselState):
 if vessel not in self:
 self[vessel] = [state]
 else:
 self[vessel].append(state)
 def add_scene(self, scene: ConcreteScene):
 for vessel, state in scene.items():
 self.add_state(vessel, state)
 def build(self):
 return Trajectories(self.even_lengths())
 @staticmethod
 def default_trajectory_from_scene(scene : ConcreteScene, length : int = ONE_HOUR_IN_SEC) -> Trajectories:
 builder = TrajectoryBuilder()
 builder.add_scene(scene)
 builder.extend(length)
 return builder.build()
 def extend(self, length : int = ONE_HOUR_IN_SEC) -> 'TrajectoryBuilder':
 for vessel in self.keys():
 self[vessel] = self.extend_trajectory(self[vessel], length)
 return self
 def even_lengths(self) -> 'TrajectoryBuilder':
 return self.extend(max(len(states) for states in self.values()))
 def extend_trajectory(self, trajectory : List[VesselState], length : int = ONE_HOUR_IN_SEC) -> List[VesselState]:
 new_trajectory = trajectory.copy()
 while len(new_trajectory) < length:
 turned_state = new_trajectory[-1].modify_copy(heading=new_trajectory[0].heading)
 new_p = turned_state.p + turned_state.v
 new_trajectory.append(turned_state.modify_copy(x=new_p[0], y=new_p[1]))
 return new_trajectory
</src\concrete_level\trajectory_generation\trajectory_builder.py>

<src\concrete_level\trajectory_generation\trajectory_data.py>
from dataclasses import dataclass
from datetime import datetime
import json
import os
import pprint
from typing import Optional, Dict
from concrete_level.models.trajectories import Trajectories
from utils.file_system_utils import ASSET_FOLDER
from utils.serializable import Serializable
@dataclass(frozen=False)
class TrajectoryData(Serializable):
 algorithm_desc: Optional[str] = None
 scene_path: Optional[str] = None
 config_name: Optional[str] = None
 random_seed: Optional[int] = None
 max_iter: Optional[int] = None
 goal_sample_rate: Optional[float] = None
 expand_distances: Optional[Dict[int, float]] = None
 timestamp: Optional[str] = None
 measurement_name: Optional[str] = None
 path: Optional[str] = None
 iter_numbers: Optional[Dict[int, int]] = None
 error_message: Optional[str] = None
 rrt_evaluation_times: Optional[Dict[int, float]] = None
 overall_eval_time: Optional[float] = None
 trajectories: Optional[Trajectories] = None
 def save_to_json(self, path2=None):
 if self.path is None:
 if path2 is None:
 raise Exception('No path provided')
 with open(path2, "w") as file:
 json.dump(self.to_dict(), file, indent=4)
 else:
 with open(self.path, 'w') as file:
 dict = self.to_dict()
 json.dump(dict, file, indent=4)
 @classmethod
 def load_dict_from_json(cls, file_path: str) -> dict:
 with open(file_path, "r") as file:
 return json.load(file)
 @classmethod
 def load_from_json(cls, file_path: str) -> 'TrajectoryData':
 return cls.from_dict(TrajectoryData.load_dict_from_json(file_path))
 def __str__(self) -> str:
 return pprint.pformat(dict(sorted(self.to_dict().items())))
 def __repr__(self) -> str:
 return pprint.pformat(dict(sorted(self.to_dict().items())))
 def save_as_measurement(self):
 measurement_id = f"{self.measurement_name} - {datetime.now().isoformat().replace(':','-')}"
 asset_folder = f'{ASSET_FOLDER}/gen_data/{self.algorithm_desc}/{self.config_name}/{measurement_id}'
 if not os.path.exists(asset_folder):
 os.makedirs(asset_folder)
 file_path=f"{asset_folder}/{self.timestamp.replace(':','-')}.json"
 self.path = file_path
 self.save_to_json()
</src\concrete_level\trajectory_generation\trajectory_data.py>

<src\concrete_level\trajectory_generation\trajectory_generator.py>
from datetime import datetime
from itertools import chain
import random
from typing import List, Dict
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.trajectory_generation.trajectory_builder import TrajectoryBuilder
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from utils.asv_utils import MAX_COORD, TWO_N_MILE
from utils.math_utils import find_center_and_radius
from concrete_level.models.rrt_models import Obstacle, PolygonalObstacle, LineObstacle, CircularObstacle
from concrete_level.models.vessel_order_graph import VesselNode, VesselOrderGraph
from concrete_level.trajectory_generation.trajectory_data import TrajectoryData
from concrete_level.trajectory_generation.path_interpolator import PathInterpolator
import numpy as np
from concrete_level.trajectory_generation.bidirectional_rrt_star_fnd import BidirectionalRRTStarFND, DIM
SCALER = 1 / MAX_COORD / 1.5 * DIM
DIRECTION_THRESHOLD = 100 # meter
GOAL_SAMPLE_RATE = 5.0 #%
class TrajectoryGenerator:
 def __init__(self, eval_data : EvaluationData, scenario : MultiLevelScenario):
 seed = 1234
 random.seed(seed)
 np.random.seed(seed)
 self.scenario = scenario
 interpolator = PathInterpolator(self.scenario)
 ordered_vessels = VesselOrderGraph(self.scenario).sort()
 # give_way_vessels_precedence = sorted(
 # list(give_way_vessels.values()),
 # key=lambda item: (len(item[1]), item[0].maneuverability()) # Sort firstly by the give-way numbers (how many corrections the vessel has to make) then by maneuverability (less maneuverable ships has to adapt to less other trajectories)
 # )
 start_time = datetime.now()
 iter_numbers : Dict[int, int] = {}
 eval_times : Dict[int, float] = {}
 expand_distances : Dict[int, float] = {}
 for v_node in ordered_vessels:
 o_start_time = datetime.now()
 path, iter_number, expand_distance = self.run_trajectory_generation(v_node, interpolator)
 interpolator.add_path(v_node.vessel, path)
 o_eval_time = (datetime.now() - o_start_time).total_seconds()
 eval_times[v_node.vessel.id] = o_eval_time
 iter_numbers[v_node.vessel.id] = iter_number
 expand_distances[v_node.vessel.id] = expand_distance
 overall_eval_time = (datetime.now() - start_time).total_seconds()
 timestamp = datetime.now().isoformat()
 self.trajectories = interpolator.trajectories
 traj_data = TrajectoryData(measurement_name='test', iter_numbers=iter_numbers, algorithm_desc='RRTStar_algo',
 config_name=eval_data.scenario_name, scene_path=eval_data.path, random_seed=seed,
 expand_distances=expand_distances, goal_sample_rate=GOAL_SAMPLE_RATE,
 timestamp=timestamp, trajectories=self.trajectories,
 overall_eval_time=overall_eval_time, rrt_evaluation_times=eval_times)
 traj_data.save_as_measurement()
 def run_trajectory_generation(self, v_node : VesselNode, interpolator : PathInterpolator):
 vessel = v_node.vessel
 vessel_state = self.scenario.concrete_scene[vessel]
 print(f'Calculation {vessel}:')
 expand_distance = vessel_state.speed * 20 # half minute precision
 if len(v_node.relations) == 0:
 return [], 0, expand_distance
 # collision_points : List[np.ndarray] = []
 # for v1, v2 in v_node.relations:
 # print(f'Collision points for static colreg ({v1}, {v2})')
 # var1 = scenario.to_variable(v1)
 # var2 = scenario.to_variable(v2)
 # collision_points += scenario.evaluation_cache.get_collision_points(var1, var2)
 new_trajectory_builder = TrajectoryBuilder(interpolator.trajectory_builder)
 new_trajectory_builder.add_state(vessel, vessel_state)
 trajectory_collision_points = new_trajectory_builder.build().collision_points(vessel)
 collision_points = list(chain.from_iterable(list(trajectory_collision_points.values())))
 furthest_collision_point = max(collision_points, key=lambda p: np.linalg.norm(p - vessel_state.p))
 if len(collision_points) != 0:
 collision_center, collision_center_radius = find_center_and_radius(collision_points)
 else:
 collision_center = vessel_state.p + vessel_state.v * interpolator.path_length / 2
 start_coll_center_dist = np.linalg.norm(vessel_state.p - collision_center)
 start_furthest_point_dist = np.linalg.norm(vessel_state.p - furthest_collision_point)
 start_goal_dist = start_coll_center_dist * 2
 goal_pos = vessel_state.v_norm * start_goal_dist + vessel_state.p
 goal_state = vessel_state.modify_copy(x=goal_pos[0], y=goal_pos[1])
 poly_p1 = vessel_state.p + vessel_state.v_norm * start_coll_center_dist / 3
 poly_p2 = vessel_state.p + vessel_state.v_norm * start_furthest_point_dist
 poly_p3 = poly_p2 + vessel_state.v_norm_perp * collision_center_radius
 poly_p4 = poly_p1 + vessel_state.v_norm_perp * collision_center_radius
 obstacle_list : List[Obstacle] = []
 #obstacle_list += [PolygonalObstacle(p1=poly_p1, p2=poly_p2, p3=poly_p3, p4=poly_p4)]
 #obstacle_list += [CircularObstacle(p, max(v.radius, vessel.radius)) for v, points in trajectory_collision_points.items() for p in points]
 obstacle_list.append(CircularObstacle(collision_center, collision_center_radius))
 # Define the bounding lines
 min_go_around_line = LineObstacle(vessel_state.x, vessel_state.y, vessel_state.v_norm, False, collision_center_radius)
 go_around_split_line = LineObstacle(collision_center[0], collision_center[1], vessel_state.v_norm_perp, False, 0)
 bounding_lines = [
 LineObstacle(vessel_state.x, vessel_state.y, vessel_state.v_norm, True, DIRECTION_THRESHOLD), # Left bounding line
 LineObstacle(goal_state.x, goal_state.y, vessel_state.v_norm, False, collision_center_radius + TWO_N_MILE), # Right bounding line
 LineObstacle(vessel_state.x, vessel_state.y, vessel_state.v_norm, False, collision_center_radius + TWO_N_MILE), # Right bounding line
 LineObstacle(vessel_state.x, vessel_state.y, vessel_state.v_norm_perp, False, DIRECTION_THRESHOLD), # Behind bounding line
 LineObstacle(goal_state.x, goal_state.y, vessel_state.v_norm_perp, True, DIRECTION_THRESHOLD), # Front bounding line
 ]
 # Add circular obstacle and bounding lines to obstacle list
 #obstacle_list += [CircularObstacle(collision_center[0], collision_center[1], collision_radius)] + bounding_lines
 obstacle_list += bounding_lines
 # Calculate X and Y distances
 shifted_points_x = [line.shifted_point[0] for line in bounding_lines]
 shifted_points_y = [line.shifted_point[1] for line in bounding_lines]
 X_DIST = (min(shifted_points_x), max(shifted_points_x))
 Y_DIST = (min(shifted_points_y), max(shifted_points_y))
 # ====Search Path with RRT====
 print(f"start RRT path planning for {vessel}")
 # Set Initial parameters
 rrt = BidirectionalRRTStarFND(
 v_node=v_node,
 start_state=vessel_state,
 goal_state=goal_state,
 min_go_around_line=min_go_around_line,
 go_around_split_line=go_around_split_line,
 sample_area=[X_DIST, Y_DIST],
 obstacle_list=obstacle_list,
 expand_dist=expand_distance,
 goal_sample_rate=GOAL_SAMPLE_RATE,
 collision_points=collision_points,
 interpolator=interpolator,
 scaler = SCALER * MAX_COORD / start_goal_dist / 1.5)
 # Add the original position to start the path
 path = rrt.plan_trajectory()
 return path, rrt.current_i, expand_distance
</src\concrete_level\trajectory_generation\trajectory_generator.py>

<src\evaluation\chi_square_kl_div.py>
from typing import List
import numpy as np
from scipy.stats import chi2_contingency, entropy
class ChiSquareKLDiv():
 def __init__(self, freq1 : List[int], freq2 : List[int]) -> None:
 list1len = sum(freq1)
 list2len = sum(freq2)
 freq1 = np.array(freq1) / list1len + 1e-10
 freq2 = np.array(freq2) / list2len + 1e-10
 # Expected frequencies: average of A and B
 expected = (freq1 + freq2) / 2
 # Compute Chi-square statistic
 #self.chi2_stat = np.sum((freq1 - expected) ** 2 / expected)
 self.p_value = chi2_contingency([freq1 * list1len, freq2 * list2len]).pvalue
 # Avoid zero probabilities by adding a small value
 freq1 += 1e-10
 freq2 += 1e-10
 # Normalize
 freq1 /= freq1.sum()
 freq2 /= freq2.sum()
 # Compute KL divergence
 self.kl_div = entropy(freq1, freq2) # KL(A || B)
</src\evaluation\chi_square_kl_div.py>

<src\evaluation\fishers_exact_odds_ratio.py>
import itertools
from typing import Dict, List, Tuple
from scipy.stats import fisher_exact
class FisherExactOddsRatio():
 def __init__(self, samples : Dict[str, List[int]] = {}) -> None:
 self.samples = samples
 pairs = list(itertools.combinations(samples.items(), 2))
 self.odds_ratios : Dict[Tuple[str, str], float] = {}
 self.p_values : Dict[Tuple[str, str], float] = {}
 for algo1, algo2 in pairs:
 contingency_table_pair = [
 [sum(algo1[1]), len(algo1[1]) - sum(algo1[1])], # [Success, Failure] for Algorithm 1
 [sum(algo2[1]), len(algo2[1]) - sum(algo2[1])] # [Success, Failure] for Algorithm 2
 ]
 odds_ratio, p_value = fisher_exact(contingency_table_pair)
 self.odds_ratios[(algo1[0], algo2[0])] = odds_ratio
 self.p_values[(algo1[0], algo2[0])] = p_value
</src\evaluation\fishers_exact_odds_ratio.py>

<src\evaluation\mann_whitney_u_cliff_delta.py>
from typing import List
import numpy as np
from scipy.stats import mannwhitneyu, ttest_ind
import cliffs_delta
from scipy.stats import rankdata
class MannWhitneyUCliffDelta():
 def __init__(self, samples1 : List[float], samples2 : List[float]) -> None:
 samples1 = np.array(samples1, dtype=float)
 samples2 = np.array(samples2, dtype=float)
 stat, p_value = mannwhitneyu(samples1, samples2)
 self.p_value_mann_w = p_value
 stat, p_value = ttest_ind(samples1, samples2)
 self.p_value_ttest = p_value
 delta, interpretation = cliffs_delta.cliffs_delta(samples1, samples2)
 self.effect_size_cliff = (delta, interpretation)
 self.effect_size_A12 = self.A12(samples1, samples2)
 self.effect_size_cohens_d = self.cohens_d(samples1, samples2)
 def A12(self, x, y):
 """
 Compute Vargha and Delaney's A12 effect size.
 Parameters:
 x: list or numpy array of first sample
 y: list or numpy array of second sample
 Returns:
 A12: Vargha and Delaney's A12 effect size
 """
 combined = np.concatenate([x, y])
 ranks = rankdata(combined)
 nx = len(x)
 ny = len(y)
 rank_x = np.sum(ranks[:nx]) - (nx * (nx + 1)) / 2
 A12 = (rank_x - nx * ny / 2) / (nx * ny)
 return A12
 def cohens_d(self, x1, x2):
 # Calculate the size of each group
 n1, n2 = len(x1), len(x2)
 # Calculate the means of each group
 mean1, mean2 = np.mean(x1), np.mean(x2)
 # Calculate the standard deviations of each group
 std1, std2 = np.std(x1, ddof=1), np.std(x2, ddof=1)
 # Calculate the pooled standard deviation
 pooled_std = np.sqrt(((n1 - 1) * std1**2 + (n2 - 1) * std2**2) / (n1 + n2 - 2))
 # Calculate Cohen's d
 d = (mean1 - mean2) / pooled_std
 return d
</src\evaluation\mann_whitney_u_cliff_delta.py>

<src\evaluation\permutation_evenness_test.py>
from typing import List
import numpy as np
from scipy.stats import entropy, ks_2samp, chisquare, permutation_test
class PermutationEvennessTest:
 def __init__(self, dist1 : List[int], dist2 : List[int], num_permutations=10000):
 """Perform a permutation test on Shannon Evenness Index"""
 self.evenness_1 = self.shannon_evenness(dist1)
 self.evenness_2 = self.shannon_evenness(dist2)
 self.observed_diff = self.evenness_1 - self.evenness_2
 def statistic(x, y):
 return self.shannon_evenness(x) - self.shannon_evenness(y)
 self.p_value = permutation_test((dist1, dist2), statistic, n_resamples=num_permutations, alternative='two-sided').pvalue
 def shannon_evenness(self, dist):
 """Compute Shannon Evenness Index: J' = H' / log(N)"""
 dist = np.array(dist, dtype=np.float64)
 dist = dist / np.sum(dist) # Normalize to probability distribution
 H = entropy(dist, base=np.e) # Shannon entropy
 N = len(dist) # Number of categories
 return H / np.log(N) if N > 1 else 0
</src\evaluation\permutation_evenness_test.py>

<src\evaluation\risk_evaluation.py>
from typing import Dict, List, Tuple
import numpy as np
from concrete_level.models.trajectory_manager import TrajectoryManager
from utils.asv_utils import N_MILE_TO_M_CONVERSION
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from logical_level.models.actor_variable import VesselVariable
class RiskVector():
 def __init__(self, scenario: MultiLevelScenario) -> None:
 self.proximity_vectors : Dict[Tuple[ConcreteVessel, ConcreteVessel], ProximityVector] = {(a1, a2) : ProximityVector(scenario, a1, a2) for a1, a2 in scenario.os_non_os_pairs}
 self.danger_sectors : Dict[ConcreteVessel, float] = {vessel : NavigationRiskIndex(scenario, vessel).find_danger_sector() for vessel in [scenario.concrete_scene.os]}
 self.max_proximity_index = min(self.proximity_vectors.values(), key=lambda obj: obj.tcpa)
 #self.safe_navigation_area_index = self.nav_risk_vector.find_safe_navigation_area_index()
 self.danger_sector = self.danger_sectors[scenario.concrete_scene.os]
 self.min_dcpa = self.max_proximity_index.dcpa
 self.min_tcpa = self.max_proximity_index.tcpa
 self.max_proximity_index = self.max_proximity_index.proximity_index
 #self.distance = (pow(np.e, np.linalg.norm(self.risk_vector) / np.sqrt(3)) - 1) / (np.e - 1)
class ProximityVector():
 def __init__(self, scenario : MultiLevelScenario, actor1 : ConcreteVessel, actor2 : ConcreteVessel) -> None:
 self.props = scenario.get_geo_props(actor1, actor2)
 self.dist = self.props.o_distance
 self.tcpa = self.props.tcpa
 self.dcpa = self.props.dcpa
 dr = 1 * N_MILE_TO_M_CONVERSION
 ts = 10 * 60
 if self.tcpa < 0 or self.tcpa > ts:
 self.dcpa_norm = 0
 self.tcpa_norm = 0
 else:
 if self.dcpa < self.props.safety_dist:
 self.dcpa_norm = 1
 else:
 #self.dcpa_norm = (pow(np.e, (dr - self.dcpa) / (dr - relation.safety_dist)) - 1) / (np.e - 1)
 self.dcpa_norm = (pow(np.e, (dr - self.dcpa) / (dr - self.props.safety_dist)) - 1) / (np.e - 1)
 #self.tcpa_norm = (pow(np.e, (ts - self.tcpa) / ts) - 1) / (np.e - 1)
 self.tcpa_norm = (pow(np.e, (ts - self.tcpa) / ts) - 1) / (np.e - 1)
 if self.dcpa_norm * self.tcpa_norm > 0:
 self.proximity_index = np.sqrt(self.dcpa_norm * self.tcpa_norm)
 else:
 self.proximity_index = 0
class NavigationRiskIndex():
 def __init__(self, scenario: MultiLevelScenario, vessel : ConcreteVessel) -> None:
 self.scenario = scenario
 self.scene = scenario.concrete_scene
 self.initial_state = self.scene[vessel]
 self.vessel = vessel
 self.variable : VesselVariable = scenario.to_variable(self.vessel)
 def find_danger_sector(self) -> float:
 for i in range(91):
 new_scenario = self.scenario.modify_copy(self.vessel, heading=self.initial_state.heading + np.radians(i))
 if not new_scenario.may_collide_anyone(self.vessel):
 break
 for j in range(91):
 new_scenario = self.scenario.modify_copy(self.vessel, heading=self.initial_state.heading - np.radians(i))
 if not new_scenario.may_collide_anyone(self.vessel):
 break
 return pow((i + j) / 180, 0.33)
 def find_safe_navigation_area_index(self) -> float:
 collides = 0
 no_collides = 0
 partitions = 50
 speeds = [i * (self.variable.max_speed / partitions) for i in range(1, partitions + 1)]
 for speed in speeds:
 for i in range(0, 180):
 for direction in [-1, 1]: # -1 for counterclockwise, 1 for clockwise
 new_state = self.initial_state.modify_copy(heading=self.initial_state.heading + direction * np.radians(i), speed=speed)
 new_scene = SceneBuilder(self.scene.as_dict()).set_state(self.vessel, new_state)
 scenario = MultiLevelScenario(new_scene, self.scenario.logical_scenario, self.scenario.functional_scenario)
 if scenario.may_collide_anyone(self.vessel):
 collides += 1
 else:
 no_collides += 1
 return (pow(np.e, collides / (collides + no_collides)) - 1) / (np.e - 1)
class TrajectoryRiskEvaluator():
 def __init__(self, trajectory_manager : TrajectoryManager) -> None:
 self.trajectory_manager = trajectory_manager
 self.risk_vectors : List[RiskVector] = []
 last_vector = RiskVector(trajectory_manager.scenario)
 for t in range(self.trajectory_manager.timespan):
 if t % 15 == 0:
 scenario = self.trajectory_manager.get_scenario(t)
 last_vector = RiskVector(scenario)
 self.risk_vectors.append(last_vector)
</src\evaluation\risk_evaluation.py>

<src\evaluation\vessel_type_sampler.py>
import random
from typing import Dict, List
from functional_level.metamodels.functional_scenario import FunctionalScenario
class VesselTypeSampler():
 @staticmethod
 def sample(scenarios : List[FunctionalScenario], sample_size, distribution : Dict[str, float] = {}) -> List[float]:
 random.shuffle(scenarios)
 # sized_distribution = {vessel_type : math.floor(percentage * sample_size / 100) for vessel_type, percentage in distribution.items()}
 result = [0.0, 0.0, 0.0]
 current_distribution = {vessel_type : 0 for vessel_type in distribution.keys()}
 for scenario in scenarios:
 if len(current_distribution) == 0:
 result[0] += len(scenario.overtaking_interpretation)
 result[1] += len(scenario.head_on_interpretation) / 2
 result[2] += len(scenario.crossing_interpretation)
 # else:
 # for obj in scenario.concrete_scene.non_os:
 # if obj.vessel_type in sized_distribution and current_distribution[obj.vessel_type] < sized_distribution[obj.vessel_type]:
 # current_distribution[obj.vessel_type] += 1
 # if scenario.overtaking(obj, None):
 # result[0] += 1
 # elif scenario.head_on(obj, None):
 # result[1] += 1
 # elif scenario.crossing(obj, None):
 # result[2] += 1
 # achieved_size = sum(current_distribution.values())
 # if sample_size != achieved_size:
 # print(f'More sample is needed : >{sample_size - achieved_size}')
 # achieved_distribution = {vessel_type : size / achieved_size * 100 for vessel_type, size in current_distribution.items()}
 # print(achieved_distribution)
 return result
</src\evaluation\vessel_type_sampler.py>

<src\functional_level\metamodels\functional_object.py>
from dataclasses import dataclass
@dataclass(frozen=True)
class FuncObject():
 id : int
</src\functional_level\metamodels\functional_object.py>

<src\functional_level\metamodels\functional_scenario.py>
from collections import defaultdict
from dataclasses import dataclass, field
from itertools import combinations
from typing import Dict, List, Optional, Set, Tuple
import copy
from functional_level.metamodels.functional_object import FuncObject
from functional_level.metamodels.interpretation import (
 BinaryInterpretation, HeadOnInterpretation, OvertakingInterpretation, CrossingFromPortInterpretation, OSInterpretation, TSInterpretation,
 VesselClass1Interpretation, VesselClass2Interpretation, VesselClass3Interpretation, VesselClass4Interpretation,
 VesselClass5Interpretation, VesselClass0Interpretation, VesselClass6Interpretation, VesselClass7Interpretation,
 VesselClass8Interpretation, VesselInterpretation)
from utils.scenario import Scenario
@dataclass(frozen=True)
class FunctionalScenario(Scenario):
 os_interpretation : OSInterpretation = OSInterpretation()
 ts_interpretation : TSInterpretation = TSInterpretation()
 head_on_interpretation : HeadOnInterpretation = HeadOnInterpretation()
 overtaking_interpretation : OvertakingInterpretation = OvertakingInterpretation()
 crossing_interpretation : CrossingFromPortInterpretation = CrossingFromPortInterpretation()
 vessel_class_0_interpretation : VesselClass0Interpretation = VesselClass0Interpretation()
 vessel_class_1_interpretation : VesselClass1Interpretation = VesselClass1Interpretation()
 vessel_class_2_interpretation : VesselClass2Interpretation = VesselClass2Interpretation()
 vessel_class_3_interpretation : VesselClass3Interpretation = VesselClass3Interpretation()
 vessel_class_4_interpretation : VesselClass4Interpretation = VesselClass4Interpretation()
 vessel_class_5_interpretation : VesselClass5Interpretation = VesselClass5Interpretation()
 vessel_class_6_interpretation : VesselClass6Interpretation = VesselClass6Interpretation()
 vessel_class_7_interpretation : VesselClass7Interpretation = VesselClass7Interpretation()
 vessel_class_8_interpretation : VesselClass8Interpretation = VesselClass8Interpretation()
 func_objects : List[FuncObject] = field(init=False)
 class_interpretation_list : List[VesselInterpretation] = field(init=False)
 def __post_init__(self):
 object_set : Set[FuncObject] = set()
 for interpretations in [self.os_interpretation, self.ts_interpretation, self.head_on_interpretation, self.overtaking_interpretation, self.crossing_interpretation]:
 for interpretation in interpretations:
 for func_object in interpretation:
 object_set.add(func_object)
 object.__setattr__(self, 'func_objects', sorted(list(object_set), key=lambda x: x.id))
 head_on_interpretation_temp = copy.deepcopy(self.head_on_interpretation)
 for o1, o2 in head_on_interpretation_temp:
 self.head_on_interpretation.add(o1, o2)
 class_interpretation_list = [self.vessel_class_0_interpretation, self.vessel_class_1_interpretation,
 self.vessel_class_2_interpretation, self.vessel_class_3_interpretation,
 self.vessel_class_4_interpretation, self.vessel_class_5_interpretation,
 self.vessel_class_6_interpretation, self.vessel_class_7_interpretation,
 self.vessel_class_8_interpretation,
 ]
 object.__setattr__(self, 'class_interpretation_list', class_interpretation_list)
 @property
 def name(self):
 return f'{str(self.size)}vessel'
 def in_colreg_rel(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.colreg_rel(o1, o2) or self.colreg_rel(o2, o1)
 def in_overtaking(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.overtaking(o1, o2) or self.overtaking(o2, o1)
 def in_crossing(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.crossing(o1, o2) or self.crossing(o2, o1)
 def colreg_rel(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.head_on(o1, o2) or self.overtaking(o1, o2) or self.crossing(o1, o2)
 def head_on(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.head_on_interpretation.contains((o1, o2))
 def overtaking(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.overtaking_interpretation.contains((o1, o2))
 def crossing(self, o1 : Optional[FuncObject], o2 : Optional[FuncObject]) -> bool:
 return self.crossing_interpretation.contains((o1, o2))
 def is_os(self, o : FuncObject) -> bool:
 return self.os_interpretation.contains(o)
 def is_ts(self, o : FuncObject) -> bool:
 return self.ts_interpretation.contains(o)
 def is_vessel_class_x(self, class_num : int, o: FuncObject):
 return self.class_interpretation_list[class_num].contains(o)
 @property
 def binary_interpretation_tuples(self) -> List[Tuple[FuncObject, FuncObject]]:
 return (list(self.overtaking_interpretation.get_tuples()) +
 list(self.head_on_interpretation.get_tuples()) +
 list(self.crossing_interpretation.get_tuples()))
 @property
 def os_object(self) -> FuncObject:
 return self.os_interpretation.next
 @property
 def size(self) -> int:
 return len(self.func_objects)
 @property
 def all_object_pairs(self) -> Set[Tuple[FuncObject, FuncObject]]:
 return {(oi, oj) for oi, oj in combinations(self.func_objects, 2)}
 @property
 def not_in_colreg_pairs(self):
 not_in_colreg_pairs : Set[Tuple[FuncObject, FuncObject]] = set()
 for o1, o2 in self.all_object_pairs:
 if not self.in_colreg_rel(o1, o2):
 not_in_colreg_pairs.add((o1, o2))
 return not_in_colreg_pairs
 def shape_hash(self, hops: int = 1) -> int:
 """
 Compute the hash of the node attributes and their neighborhoods up to the given number of hops.
 :param hops: Number of hops to consider in the neighborhood.
 :return: Hash of the neighborhood information.
 """
 # Initialize a dictionary to store neighborhoods for all hop levels
 neighborhoods: Dict[int, Dict[FuncObject, tuple]] = defaultdict(dict)
 neighborhood_counter : Dict[int, Dict[FuncObject, Dict[tuple, int]]] = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
 def generate_tuples(hop : int, interpretation : BinaryInterpretation, node : FuncObject) -> Set[tuple]:
 relation_descs = interpretation.get_relation_descs(node)
 tuples : set[tuple] = set()
 for rd in relation_descs:
 nbh = None if hop == 0 else neighborhoods[hop - 1][rd[2]]
 t = (rd[0], rd[1], nbh)
 neighborhood_counter[hop][node][t] += 1
 tuples.add((*t, neighborhood_counter[hop][node][t]))
 return tuples
 # Initialize base (0-hop) attributes
 for node in self.func_objects:
 attributes: Set[tuple] = set()
 if self.os_interpretation.contains(node):
 attributes.add((OSInterpretation.name, 1))
 if self.ts_interpretation.contains(node):
 attributes.add((TSInterpretation.name, 1))
 attributes.update(generate_tuples(0, self.overtaking_interpretation, node))
 attributes.update(generate_tuples(0, self.head_on_interpretation, node))
 attributes.update(generate_tuples(0, self.crossing_interpretation, node))
 neighborhoods[0][node] = (None, frozenset(attributes))
 # Build neighborhoods iteratively for each hop
 for hop in range(1, hops + 1):
 neighborhoods[hop] = {}
 for node in self.func_objects:
 attributes: Set[tuple] = set()
 if self.os_interpretation.contains(node):
 attributes.add((OSInterpretation.name, 1))
 if self.ts_interpretation.contains(node):
 attributes.add((TSInterpretation.name, 1))
 attributes.update(generate_tuples(hop, self.overtaking_interpretation, node))
 attributes.update(generate_tuples(hop, self.head_on_interpretation, node))
 attributes.update(generate_tuples(hop, self.crossing_interpretation, node))
 neighborhoods[hop][node] = (neighborhoods[hop - 1][node], frozenset(attributes))
 # Return hash of the last neighborhood
 shape = frozenset(neighborhoods[hops].values())
 return hash(shape)
</src\functional_level\metamodels\functional_scenario.py>

<src\functional_level\metamodels\interpretation.py>
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Set, Tuple
from functional_level.metamodels.functional_scenario import FuncObject
@dataclass(frozen=True)
class Interpretation(ABC):
 name : str = ''
 _data : Set[tuple] = field(default_factory=set)
 def __len__(self):
 return len(self._data)
 def __iter__(self):
 return iter(self._data)
 def __repr__(self):
 return f"{self.__class__.__name__}({self._data})"
 @abstractmethod
 def contains(self, objects) -> bool:
 pass
 @abstractmethod
 def _add(self, objects):
 pass
@dataclass(frozen=True)
class UnaryInterpretation(Interpretation, ABC):
 _data : Set[Tuple[FuncObject]] = field(default_factory=set)
 def contains(self, object : FuncObject) -> bool:
 return (object,) in self._data
 def _add(self, objects : Tuple[FuncObject]):
 self._data.add(objects)
 def add(self, object : FuncObject):
 self._add((object,))
 @property
 def next(self) -> FuncObject:
 return next(iter(self._data))[0]
@dataclass(frozen=True)
class BinaryInterpretation(Interpretation, ABC):
 _data : Set[Tuple[FuncObject, FuncObject]] = field(default_factory=set)
 def contains(self, objects : Tuple[Optional[FuncObject], Optional[FuncObject]]) -> bool:
 if objects[0] == None and objects[1] == None:
 return False
 return len(self.get_tuples(*objects)) > 0
 def _add(self, objects : Tuple[FuncObject, FuncObject]):
 self._data.add(objects)
 def add(self, o1 : FuncObject, o2 : FuncObject):
 self._add((o1, o2))
 def get_tuples(self, o1 : Optional[FuncObject] = None, o2 : Optional[FuncObject] = None):
 if o1 is None and o2 is None:
 return self._data
 return {
 (t1, t2) for t1, t2 in self._data
 if (o1 is None or o1 == t1) and (o2 is None or o2 == t2)
 }
 def get_relation_descs(self, o : FuncObject) -> Set[Tuple[str, int, FuncObject]]:
 descs : Set[Tuple[str, int, FuncObject]] = set()
 for _o1, _o2 in self._data:
 if _o1 is o:
 descs.add((self.name, 1, _o2))
 elif _o2 is o:
 descs.add((self.name, 2, _o1))
 return descs
@dataclass(frozen=True)
class VesselInterpretation(UnaryInterpretation, ABC):
 pass
@dataclass(frozen=True)
class OSInterpretation(VesselInterpretation):
 name : str = field(default='OS', init=False)
@dataclass(frozen=True)
class TSInterpretation(VesselInterpretation):
 name : str = field(default='TS', init=False)
@dataclass(frozen=True)
class HeadOnInterpretation(BinaryInterpretation):
 name : str = field(default='HeadOn', init=False)
@dataclass(frozen=True)
class CrossingFromPortInterpretation(BinaryInterpretation):
 name : str = field(default='Crossing', init=False)
@dataclass(frozen=True)
class OvertakingInterpretation(BinaryInterpretation):
 name : str = field(default='Overtaking', init=False)
@dataclass(frozen=True)
class VesselClass0Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass0', init=False)
@dataclass(frozen=True)
class VesselClass1Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass1', init=False)
@dataclass(frozen=True)
class VesselClass2Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass2', init=False)
@dataclass(frozen=True)
class VesselClass3Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass3', init=False)
@dataclass(frozen=True)
class VesselClass4Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass4', init=False)
@dataclass(frozen=True)
class VesselClass5Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass5', init=False)
@dataclass(frozen=True)
class VesselClass6Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass6', init=False)
@dataclass(frozen=True)
class VesselClass7Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass7', init=False)
@dataclass(frozen=True)
class VesselClass8Interpretation(VesselInterpretation):
 name : str = field(default='VesselClass8', init=False)
</src\functional_level\metamodels\interpretation.py>

<src\functional_level\models\functional_model_manager.py>
from typing import List
from functional_level.metamodels.functional_scenario import FunctionalScenario
from functional_level.models.model_parser import ModelParser
class FunctionalModelManager():
 __scenario_cache_map = {
 2 : None,
 3 : None,
 4 : None,
 5 : None,
 6 : None
 }
 __ambiguous_scenario_cache_map = {
 2 : None,
 3 : None,
 4 : None,
 5 : None,
 6 : None
 }
 @classmethod
 def get_x_vessel_ambiguous_scenarios(cls, vessel_number: int) -> List[FunctionalScenario]:
 if cls.__ambiguous_scenario_cache_map[vessel_number] is None:
 cls.__ambiguous_scenario_cache_map[vessel_number] = ModelParser.load_ambiguous_functional_scenarios(vessel_number)
 return cls.__ambiguous_scenario_cache_map[vessel_number]
 @classmethod
 def get_x_vessel_scenarios(cls, vessel_number: int) -> List[FunctionalScenario]:
 if cls.__scenario_cache_map[vessel_number] is None:
 cls.__scenario_cache_map[vessel_number] = ModelParser.load_functional_scenarios(vessel_number)
 return cls.__scenario_cache_map[vessel_number]
</src\functional_level\models\functional_model_manager.py>

<src\functional_level\models\model_parser.py>
import re
from typing import Dict, List
from functional_level.metamodels.functional_object import FuncObject
from functional_level.metamodels.functional_scenario import FunctionalScenario
from functional_level.metamodels.interpretation import CrossingFromPortInterpretation, HeadOnInterpretation, OSInterpretation, OvertakingInterpretation, TSInterpretation
from functional_level.models.object_generator import ObjectGenerator
from utils.file_system_utils import ASSET_FOLDER, get_all_file_paths
class ModelParser():
 FUNCTIONAL_MODELS_PATH_ALL = f'{ASSET_FOLDER}/functional_models/all'
 FUNCTIONAL_MODELS_PATH_AMBIGUOUS = f'{ASSET_FOLDER}/functional_models/ambiguous'
 scenario_path_map = {
 2 : f'{FUNCTIONAL_MODELS_PATH_ALL}/2vessel_scenarios',
 3 : f'{FUNCTIONAL_MODELS_PATH_ALL}/3vessel_scenarios',
 4 : f'{FUNCTIONAL_MODELS_PATH_ALL}/4vessel_scenarios',
 5 : f'{FUNCTIONAL_MODELS_PATH_ALL}/5vessel_scenarios',
 6 : f'{FUNCTIONAL_MODELS_PATH_ALL}/6vessel_scenarios'
 }
 ambiguous_scenario_path_map = {
 2 : f'{FUNCTIONAL_MODELS_PATH_AMBIGUOUS}/2vessel_scenarios',
 3 : f'{FUNCTIONAL_MODELS_PATH_AMBIGUOUS}/3vessel_scenarios',
 4 : f'{FUNCTIONAL_MODELS_PATH_AMBIGUOUS}/4vessel_scenarios',
 5 : f'{FUNCTIONAL_MODELS_PATH_AMBIGUOUS}/5vessel_scenarios',
 6 : f'{FUNCTIONAL_MODELS_PATH_AMBIGUOUS}/6vessel_scenarios'
 }
 @staticmethod
 def parse_problem(problem : str) -> FunctionalScenario:
 cropped_problem = problem.split('declare')[1]
 os_interpretation = OSInterpretation()
 ts_interpretation = TSInterpretation()
 head_on_interpretation = HeadOnInterpretation()
 overtaking_interpretation = OvertakingInterpretation()
 crossing_interpretation = CrossingFromPortInterpretation()
 object_generator = ObjectGenerator()
 objects : Dict[str, FuncObject] = dict()
 # Parse object declarations
 object_pattern = r"(\bOS|\bTS)\((\w+)\)\."
 for obj_type, obj_name in re.findall(object_pattern, cropped_problem):
 obj = object_generator.new_object
 objects[obj_name] = obj
 if obj_type == "OS":
 os_interpretation.add(obj)
 elif obj_type == "TS":
 ts_interpretation.add(obj)
 # Parse relationships
 relationship_patterns = {
 "headOn": lambda o1, o2: head_on_interpretation.add(o1, o2),
 "overtaking": lambda o1, o2: overtaking_interpretation.add(o1, o2),
 "crossingFromPort": lambda o1, o2: crossing_interpretation.add(o1, o2),
 }
 for rel_type, assertion in relationship_patterns.items():
 rel_pattern = fr"{rel_type}\((\w+), (\w+)\)\."
 for o1, o2 in re.findall(rel_pattern, cropped_problem):
 if o1 in objects and o2 in objects:
 assertion(objects[o1], objects[o2])
 scenario = FunctionalScenario(os_interpretation, ts_interpretation,
 head_on_interpretation, overtaking_interpretation,
 crossing_interpretation)
 return scenario
 @staticmethod
 def load_problem_from_file(file_path : str) -> str:
 with open(file_path, 'r') as file:
 return file.read()
 @staticmethod
 def __load_functional_scenarios(dir : str) -> List[FunctionalScenario]:
 return [ModelParser.parse_problem(ModelParser.load_problem_from_file(path)) for path in get_all_file_paths(dir, 'problem')]
 @staticmethod
 def load_functional_scenarios(vessel_num : int) -> List[FunctionalScenario]:
 return ModelParser.__load_functional_scenarios(ModelParser.scenario_path_map[vessel_num])
 @staticmethod
 def load_ambiguous_functional_scenarios(vessel_num : int) -> List[FunctionalScenario]:
 return ModelParser.__load_functional_scenarios(ModelParser.ambiguous_scenario_path_map[vessel_num])
</src\functional_level\models\model_parser.py>

<src\functional_level\models\object_generator.py>
from functional_level.metamodels.functional_scenario import FuncObject
class ObjectGenerator():
 def __init__(self) -> None:
 self.__id_count = 0
 @property
 def new_object(self) -> FuncObject:
 id = self.__id_count
 self.__id_count += 1
 return FuncObject(id)
</src\functional_level\models\object_generator.py>

<src\logical_level\constraint_satisfaction\assignments.py>
from typing import Dict, List, Union
import numpy as np
from logical_level.models.values import Values
from logical_level.models.actor_variable import ActorVariable
class Assignments(Dict[ActorVariable, Values]):
 def __init__(self, actor_variables : List[ActorVariable] = [], *args, **kwargs):
 super().__init__({var : None for var in actor_variables}, *args, **kwargs)
 def update_from_individual(self, states : Union[np.ndarray, List[float]]) -> 'Assignments':
 if len(states) != sum(len(var) for var in self.keys()):
 raise Exception("the variable number is insufficient.")
 for i, var in enumerate(self.keys()):
 var_len = len(var)
 self[var] = Values(x=states[i * var_len],
 y=states[i * var_len + 1],
 h=states[i * var_len + 2],
 l=states[i * var_len + 3],
 sp=states[i * var_len + 4])
 return self
</src\logical_level\constraint_satisfaction\assignments.py>

<src\logical_level\constraint_satisfaction\evaluation_cache.py>
from typing import Dict, List, Tuple
import numpy as np
from utils.asv_utils import EPSILON, N_MILE_TO_M_CONVERSION, o2VisibilityByo1
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.models.values import Values
from logical_level.models.actor_variable import ActorVariable
class GeometricProperties():
 def __init__(self, var1 : ActorVariable, var2 : ActorVariable, assignments : Assignments):
 self.val1 : Values = assignments[var1]
 self.val2 : Values = assignments[var2]
 self.safety_dist = max(self.val1.r, self.val2.r)
 self.p12 = self.val2.p - self.val1.p
 self.p21 = self.val1.p - self.val2.p
 self.v12 = self.val1.v - self.val2.v
 # Define the norm of the relative position (distance(p1 p2))
 self.o_distance = float(max(np.linalg.norm(self.p12), EPSILON))
 self.cos_p21_v2_theta = np.clip(np.dot(self.p21, self.val2.v) / self.o_distance / self.val2.sp, -1, 1)
 self.angle_p21_v2 = np.arccos(self.cos_p21_v2_theta)
 self.cos_p12_v1_theta = np.clip(np.dot(self.p12, self.val1.v) / self.o_distance / self.val1.sp, -1, 1)
 self.angle_p12_v1 = np.arccos(self.cos_p12_v1_theta)
 self.vis_distance = min(o2VisibilityByo1(self.angle_p12_v1, self.val1.l),
 o2VisibilityByo1(self.angle_p21_v2, self.val2.l)) * N_MILE_TO_M_CONVERSION
 # angle between the relative velocity and the relative position vector
 self.v12_norm_stable = max(np.linalg.norm(self.v12), EPSILON)
 self.dot_p12_v12 = np.dot(self.p12, self.v12)
 #self.cos_p12_v12_theta = np.clip(self.dot_p12_v12 / self.o_distance / self.v12_norm_stable, -1, 1)
 #self.angle_v12_p12 = np.arccos(self.cos_p12_v12_theta)
 self.tcpa = self.dot_p12_v12 / self.v12_norm_stable**2
 self.dcpa = float(np.linalg.norm(self.p21 + self.v12 * max(0, self.tcpa)))
 def get_collision_points(self, time_limit=np.inf) -> List[np.ndarray]:
 # Relative position and velocity
 v_21 = self.val2.v - self.val1.v
 # Coefficients for the quadratic equation
 a = np.dot(v_21, v_21)
 b = 2 * np.dot(self.p12, v_21)
 c = np.dot(self.p12, self.p12) - self.safety_dist**2
 # Calculate discriminant
 discriminant = b**2 - 4*a*c
 collision_points = []
 # Check for real solutions (collision possible)
 if discriminant >= 0:
 sqrt_discriminant = np.sqrt(discriminant)
 # Find times of collision
 t1 = (-b + sqrt_discriminant) / (2 * a)
 t2 = (-b - sqrt_discriminant) / (2 * a)
 # Check if times are within the time limit and positive
 for t in [t1, t2]:
 if 0 <= t <= time_limit:
 # Compute the collision points
 collision_point_vessel1 = self.val1.p + self.val1.v * t
 collision_point_vessel2 = self.val2.p + self.val2.v * t
 collision_points.append(collision_point_vessel1)
 collision_points.append(collision_point_vessel2)
 # Return the list of collision points as standard list of np.ndarray
 return collision_points
class EvaluationCache(Dict[Tuple[ActorVariable, ActorVariable], GeometricProperties]):
 def __init__(self, assignments : Assignments, *args, **kwargs):
 super().__init__(*args, **kwargs)
 self.assignments = assignments
 def get_props(self, var1 : ActorVariable, var2 : ActorVariable) -> GeometricProperties:
 props = self.get((var1, var2), None)
 if props is None:
 props = GeometricProperties(var1, var2, self.assignments)
 self[(var1, var2)] = props
 return props
 def get_collision_points(self, var1 : ActorVariable, var2 : ActorVariable, time_limit=np.inf) -> List[np.ndarray]:
 return self.get_props(var1, var2).get_collision_points(time_limit)
</src\logical_level\constraint_satisfaction\evaluation_cache.py>

<src\logical_level\constraint_satisfaction\scenic_sampling.py>
from datetime import datetime
import gc
from typing import Dict
import numpy as np
import random, scenic
from scenic.core.scenarios import Scenario
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.models.vessel_types import ALL_VESSEL_TYPES, PassengerShip
from utils.file_system_utils import ASSET_FOLDER
import scenic
from scenic.core.distributions import (
 RejectionException,
 Samplable,
 needsSampling,
)
from scenic.core.errors import optionallyDebugRejection
WARMUPS = 2
RANDOM_SEED = 1234
TIMEOUT = 240
NUMBER_OF_RUNS = 1000
def generate_scene(scenario : Scenario, timeout, verbosity, feedback=None):
 # choose which custom requirements will be enforced for this sample
 for req in scenario.userRequirements:
 if random.random() <= req.prob:
 req.active = True
 else:
 req.active = False
 # do rejection sampling until requirements are satisfied
 rejection = True
 iterations = 0
 start_time = datetime.now()
 while rejection is not None:
 if iterations > 0: # rejected the last sample
 if verbosity >= 2:
 print(f" Rejected sample {iterations} because of {rejection}")
 if scenario.externalSampler is not None:
 feedback = scenario.externalSampler.rejectionFeedback
 if (datetime.now() - start_time).total_seconds() >= timeout:
 print(f"Sampling reached timeout.")
 return None, iterations, datetime.now() - start_time
 iterations += 1
 try:
 if scenario.externalSampler is not None:
 scenario.externalSampler.sample(feedback)
 sample = Samplable.sampleAll(scenario.dependencies)
 except RejectionException as e:
 optionallyDebugRejection(e)
 rejection = e
 continue
 rejection = None
 # Ensure nothing else is lazy
 for obj in scenario.objects:
 sampledObj = sample[obj]
 assert not needsSampling(sampledObj)
 # Check validity of sample, storing state so that
 # checker heuristics don't affect determinism
 rand_state, np_state = random.getstate(), np.random.get_state()
 rejection = scenario.checker.checkRequirements(sample)
 random.setstate(rand_state)
 np.random.set_state(np_state)
 if rejection is not None:
 optionallyDebugRejection()
 # obtained a valid sample; assemble a scene from it
 scene = scenario._makeSceneFromSample(sample)
 return scene, iterations, datetime.now() - start_time
def calculate_heading(vx, vy):
 heading_radians = np.arctan2(vy, vx)
 return heading_radians
scenarios : Dict[int, Scenario] = {
 2 : scenic.scenarioFromFile(f'{ASSET_FOLDER}/scenic/2vessel_scenario.scenic'),
 3 : scenic.scenarioFromFile(f'{ASSET_FOLDER}/scenic/3vessel_scenario.scenic'),
 4 : scenic.scenarioFromFile(f'{ASSET_FOLDER}/scenic/4vessel_scenario.scenic'),
 5 : scenic.scenarioFromFile(f'{ASSET_FOLDER}/scenic/5vessel_scenario.scenic'),
 6 : scenic.scenarioFromFile(f'{ASSET_FOLDER}/scenic/6vessel_scenario.scenic')
}
for vessel_num, scenario in scenarios.items():
 random.seed(RANDOM_SEED)
 np.random.seed(RANDOM_SEED)
 scenario.resetExternalSampler()
 for i in range(NUMBER_OF_RUNS + WARMUPS):
 eval_data = EvaluationData(timeout=TIMEOUT, random_seed=RANDOM_SEED)
 eval_data.config_group = 'scenic_distribution'
 eval_data.vessel_number = vessel_num
 eval_data.measurement_name = f'test_{vessel_num}_vessel_scenarios'
 eval_data.algorithm_desc = 'scenic_sampling'
 eval_data.scenario_name = f'{vessel_num}vessel'
 eval_data.timestamp = datetime.now().isoformat()
 gc.collect()
 start_time = datetime.now()
 scene, num_iterations, runtime = generate_scene(scenario, TIMEOUT, 0, )
 eval_data.evaluation_time = runtime.total_seconds()
 eval_data.best_fitness_index = np.inf
 eval_data.best_fitness = (np.inf)
 builder = SceneBuilder()
 if scene is not None:
 for obj in scene.objects:
 if obj.is_vessel:
 speed = np.linalg.norm(obj.velocity)
 valid_types = [t for t in ALL_VESSEL_TYPES if t.do_match(obj.length, speed)]
 vessel_type = PassengerShip() if obj.is_os else random.choice(valid_types)
 builder.set_state(ConcreteVessel(obj.id, obj.is_os, obj.length, obj.length*4, vessel_type.max_speed, vessel_type.name),
 VesselState(obj.position[0], obj.position[1], speed, calculate_heading(obj.velocity[0], obj.velocity[1])))
 eval_data.best_fitness_index = 0.0
 eval_data.best_fitness = (0.0)
 eval_data.best_scene = builder.build()
 eval_data.number_of_generations = num_iterations
 if i >= WARMUPS:
 eval_data.save_as_measurement()
</src\logical_level\constraint_satisfaction\scenic_sampling.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\aggregates.py>
from typing import List
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.models.logical_scenario import LogicalScenario
from abc import ABC, abstractmethod
import numpy as np
from logical_level.models.penalty import Penalty
class Aggregate(ABC):
 name = 'unspecified'
 def __init__(self, logical_scenario : LogicalScenario, minimize : bool):
 super().__init__()
 self.logical_scenario = logical_scenario
 self.minimize = minimize
 @property
 def sign(self):
 return 1.0 if self.minimize else -1.0
 @property
 @abstractmethod
 def object_num(self) -> int:
 pass
 @abstractmethod
 def evaluate(self, individual : np.ndarray):
 pass
 def derive_penalty(self, individual : np.ndarray) -> Penalty :
 assignments = Assignments(self.logical_scenario.actor_vars).update_from_individual(individual)
 penalty = self.logical_scenario.relation_constraint.evaluate_penalty(assignments)
 return penalty
 def _signed_penalty(self, penalty) -> float:
 return self.sign * abs(penalty)
 @staticmethod
 def factory(logical_scenario : LogicalScenario, name : str, minimize):
 if name == ActorAggregate.name:
 return ActorAggregate(logical_scenario, minimize)
 elif name == AggregateAll.name:
 return AggregateAll(logical_scenario, minimize)
 elif name == AggregateAllSwarm.name:
 return AggregateAllSwarm(logical_scenario, minimize)
 elif name == CategoryAggregate.name:
 return CategoryAggregate(logical_scenario, minimize)
 else:
 raise Exception('Unknown aggregate')
class ActorAggregate(Aggregate):
 name = 'actor'
 def __init__(self, logical_scenario : LogicalScenario, minimize):
 super().__init__(logical_scenario, minimize)
 @property
 def object_num(self) -> int:
 return int(self.logical_scenario.size)
 def evaluate(self, individual : np.ndarray):
 penalty = self.derive_penalty(individual)
 return tuple((penalty.actor_penalties[var] for var in self.logical_scenario.actor_vars))
class AggregateAll(Aggregate):
 name = 'all'
 def __init__(self, logical_scenario : LogicalScenario, minimize):
 super().__init__(logical_scenario, minimize)
 @property
 def object_num(self) -> int:
 return 1
 def evaluate(self, individual : np.ndarray):
 fitness = self._signed_penalty(self.derive_penalty(individual).total_penalty)
 return (fitness, )
class AggregateAllSwarm(AggregateAll):
 name = 'all_swarm'
 def __init__(self, logical_scenario : LogicalScenario, minimize):
 super().__init__(logical_scenario, minimize)
 def evaluate(self, individual : np.ndarray):
 fitnesses : List[float] = []
 for particle in individual:
 fitnesses.append(super().evaluate(particle)[0])
 return np.array(fitnesses)
class CategoryAggregate(Aggregate):
 name = 'category'
 def __init__(self, logical_scenario, minimize):
 super().__init__(logical_scenario, minimize)
 @property
 def object_num(self) -> int:
 return Penalty.category_num
 def evaluate(self, individual : np.ndarray):
 penalty = self.derive_penalty(individual)
 return tuple((self._signed_penalty(pen) for pen in penalty.categorical_penalties))
</src\logical_level\constraint_satisfaction\evolutionary_computation\aggregates.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evaluation_data.py>
from dataclasses import dataclass
import json
import os
import pprint
from typing import Optional, List
from concrete_level.models.concrete_scene import ConcreteScene
from utils.file_system_utils import ASSET_FOLDER
from utils.serializable import Serializable
@dataclass(frozen=False)
class EvaluationData(Serializable):
 algorithm_desc: Optional[str] = None
 scenario_name: Optional[str] = None
 random_seed: Optional[int] = None
 vessel_number: Optional[int] = None
 evaluation_time: Optional[float] = None
 number_of_generations: Optional[int] = None
 population_size: Optional[int] = None
 num_parents_mating: Optional[int] = None
 best_fitness: Optional[List[float]] = None
 mutate_eta: Optional[float] = None
 mutate_prob: Optional[float] = None
 crossover_eta: Optional[float] = None
 crossover_prob: Optional[float] = None
 error_message: Optional[str] = None
 timestamp: Optional[str] = None
 measurement_name: Optional[str] = None
 path: Optional[str] = None
 timeout: Optional[float] = None
 init_method: Optional[str] = None
 c_1: Optional[float] = None # cognitive coefficient
 c_2: Optional[float] = None # social coefficient
 w: Optional[float] = None # inertia weight
 best_fitness_index: Optional[float] = None # best_fitness_index
 aggregate_strat: Optional[str] = None # aggregation strategy
 config_group: Optional[str] = None # config group
 best_scene: ConcreteScene = None
 def save_to_json(self, path2=None):
 if self.path is None:
 if path2 is None:
 raise Exception('No path provided')
 with open(path2, "w") as file:
 json.dump(self.to_dict(), file, indent=4)
 else:
 with open(self.path, 'w') as file:
 dict = self.to_dict()
 json.dump(dict, file, indent=4)
 @classmethod
 def load_dict_from_json(cls, file_path: str) -> dict:
 with open(file_path, "r") as file:
 return json.load(file)
 @classmethod
 def load_from_json(cls, file_path: str) -> 'EvaluationData':
 return cls.from_dict(EvaluationData.load_dict_from_json(file_path))
 def __str__(self) -> str:
 return pprint.pformat(dict(sorted(self.to_dict().items())))
 def __repr__(self) -> str:
 return pprint.pformat(dict(sorted(self.to_dict().items())))
 def save_as_measurement(self):
 asset_folder = f'{ASSET_FOLDER}/gen_data/{self.measurement_name}/{self.config_group}/{self.algorithm_desc}'
 if not os.path.exists(asset_folder):
 os.makedirs(asset_folder)
 file_path=f"{asset_folder}/{self.scenario_name}_{self.timestamp.replace(':','-')}.json"
 self.path = file_path
 self.save_to_json()
</src\logical_level\constraint_satisfaction\evolutionary_computation\evaluation_data.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\evolutionary_algorithm_base.py>
from copy import deepcopy
from datetime import datetime
import gc
import traceback
import os
import random
from typing import List, Tuple, Union
import numpy as np
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from abc import ABC, abstractmethod
from logical_level.mapping.logical_scenario_builder import LogicalScenarioBuilder
from utils.file_system_utils import ASSET_FOLDER
from logical_level.models.logical_scenario import LogicalScenario
from functional_level.metamodels.functional_scenario import FunctionalScenario
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from utils.scenario import Scenario
class EvolutionaryAlgorithmBase(ABC):
 def __init__(self, measurement_name: str, algorithm_desc : str, scenarios: List[Scenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 self.measurement_name = measurement_name
 self.algorithm_desc = f'{algorithm_desc}_{test_config.aggregate_strat}'
 self.logical_scenarios = [LogicalScenarioBuilder.build(scenario, test_config.init_method) for scenario in scenarios]
 self.test_config = test_config
 self.number_of_runs = number_of_runs
 self.warmups = warmups
 self.verbose = verbose
 def run(self) -> List[List[EvaluationData]]:
 self.set_seed(self.test_config.random_seed)
 for i in range(self.warmups):
 res = self.evaluate(self.logical_scenarios[0], False)
 results : List[List[EvaluationData]] = []
 for scenario in self.logical_scenarios:
 results.append([])
 for i in range(self.number_of_runs):
 res = self.evaluate(scenario, True)
 results[-1].append(res)
 return results
 def evaluate(self, logical_scenario : LogicalScenario, save : bool) -> EvaluationData:
 try:
 eval_data = deepcopy(self.test_config)
 eval_data.vessel_number = logical_scenario.size
 eval_data.measurement_name = self.measurement_name
 eval_data.algorithm_desc = self.algorithm_desc
 eval_data.scenario_name = logical_scenario.name
 eval_data.timestamp = datetime.now().isoformat()
 initial_pop = logical_scenario.get_population(eval_data.population_size)
 some_input = self.init_problem(logical_scenario, initial_pop, eval_data)
 gc.collect()
 start_time = datetime.now()
 some_results = self.do_evaluate(some_input, eval_data)
 eval_data.evaluation_time = (datetime.now() - start_time).total_seconds()
 best_solution, best_fitness, number_of_generations = self.convert_results(some_results, eval_data)
 assignments = Assignments(logical_scenario.actor_vars).update_from_individual(best_solution)
 eval_data.best_scene = SceneBuilder().build_from_assignments(assignments)
 eval_data.best_fitness = best_fitness
 eval_data.number_of_generations = number_of_generations
 eval_data.best_fitness_index = sum(best_fitness)
 if self.verbose:
 print("Best individual is:", best_solution)
 print("Best individual fitness is:", best_fitness)
 except Exception as e:
 eval_data.error_message = f'{str(e)}\n{traceback.format_exc()}'
 print(eval_data.error_message)
 finally:
 if save:
 eval_data.save_as_measurement()
 return eval_data
 @abstractmethod
 def init_problem(self, logical_scenario: LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 pass
 @abstractmethod
 def do_evaluate(self, some_input, eval_data : EvaluationData):
 pass
 @abstractmethod
 def convert_results(self, some_results, eval_data : EvaluationData) -> Tuple[List[float], List[float], int]:
 pass
 def set_seed(self, seed):
 random.seed(seed)
 np.random.seed(seed)
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\evolutionary_algorithm_base.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pygad_ga_algorithm.py>
import time
from typing import List, Tuple
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
import pygad
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import Aggregate
from functional_level.metamodels.functional_scenario import FunctionalScenario
from logical_level.models.logical_scenario import LogicalScenario
class PyGadGAAlgorithm(EvolutionaryAlgorithmBase):
 def __init__(self, measurement_name: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, 'pygad_GA_algorithm', functional_scenarios,test_config, number_of_runs, warmups, verbose)
 def init_problem(self, logical_scenario: LogicalScenario, initial_population: List[List[float]], eval_data: EvaluationData) -> None:
 def fitness_func(cls, solution, solution_idx):
 return Aggregate.factory(logical_scenario, eval_data.aggregate_strat, minimize=False).evaluate(solution)[0]
 start_time = time.time()
 def on_generation(ga_instance : pygad.GA):
 if self.verbose:
 print(f"Generation = {ga_instance.generations_completed}")
 print(f"Best solution = {ga_instance.best_solution()}")
 elapsed_time = time.time() - start_time
 solution, solution_fitness, solution_idx = ga_instance.best_solution()
 if abs(solution_fitness) == 0.0:
 if self.verbose:
 print(f"Terminating due to fitness reaching 0.0.")
 raise StopIteration
 if elapsed_time > eval_data.timeout:
 if self.verbose:
 print(f"Terminating due to timeout of {eval_data.timeout} seconds.")
 raise StopIteration
 # Setting up the GA
 ga_instance : pygad.GA = pygad.GA(
 num_generations=np.iinfo(np.int64).max,
 num_parents_mating=eval_data.num_parents_mating,
 fitness_func=fitness_func,
 sol_per_pop=eval_data.population_size,
 num_genes=logical_scenario.all_variable_num,
 gene_space=[{'low': low, 'high': high} for low, high in zip(logical_scenario.xl, logical_scenario.xu)],
 initial_population=initial_population,
 on_generation=on_generation,
 mutation_probability=eval_data.mutate_prob,
 crossover_probability=eval_data.crossover_prob,
 parent_selection_type='tournament',
 K_tournament=2
 )
 return ga_instance
 def do_evaluate(self, some_input : pygad.GA, eval_data : EvaluationData):
 try:
 # Run the GA
 some_input.run()
 except StopIteration:
 pass
 finally:
 return some_input
 def convert_results(self, some_results, eval_data : EvaluationData) -> Tuple[List[float], List[float], int]:
 ga_instance : pygad.GA= some_results
 # After the GA run, print the best solution found
 solution, solution_fitness, solution_idx = ga_instance.best_solution()
 # if self.verbose:
 # # Get the best solutions
 # num_best_solutions = 1
 # population_fitness = ga_instance.last_generation_fitness
 # sorted_indices = np.argsort(population_fitness)[::-1] # Sort in descending order of fitness
 # best_solutions = [ga_instance.population[idx] for idx in sorted_indices[:num_best_solutions]]
 # for sol in best_solutions:
 # ColregPlot(self.logical_scenario.update(sol))
 return list(solution.flatten()), [abs(solution_fitness)], ga_instance.generations_completed
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pygad_ga_algorithm.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga2_algorithm.py>
from typing import List
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from logical_level.models.logical_scenario import LogicalScenario
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga_algorithm import BestSolutionCallback, NSGAProblem, OptimumTermination, PyMooNSGAAlgorithm
from pymoo.core.population import Population
from functional_level.metamodels.functional_scenario import FunctionalScenario
import time
class PyMooNSGA2Algorithm(PyMooNSGAAlgorithm):
 def __init__(self, measurement_name: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, 'pymoo_NSGA2_algorithm', functional_scenarios,test_config, number_of_runs, warmups, verbose)
 def init_problem(self, logical_scenario: LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 # Instantiate the problem
 problem = NSGAProblem(logical_scenario, eval_data)
 initial_population = Population.new("X", initial_population)
 # Define the NSGA-II algorithm
 algorithm = NSGA2(pop_size=eval_data.population_size,
 crossover=SBX(eta=eval_data.crossover_eta, prob=eval_data.crossover_prob,),
 mutation=PM(eta=eval_data.mutate_eta, prob=eval_data.mutate_prob), sampling=initial_population,)
 callback = BestSolutionCallback(time.time(), self.verbose)
 termination = OptimumTermination(time.time(), eval_data.timeout, self.verbose)
 return problem, algorithm, callback, termination
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga2_algorithm.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga3_algorithm.py>
from typing import List
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from pymoo.algorithms.moo.nsga3 import NSGA3
from pymoo.util.ref_dirs import get_reference_directions
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from logical_level.models.logical_scenario import LogicalScenario
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga_algorithm import BestSolutionCallback, NSGAProblem, OptimumTermination, PyMooNSGAAlgorithm
from pymoo.core.population import Population
from functional_level.metamodels.functional_scenario import FunctionalScenario
import time
class PyMooNSGA3Algorithm(PyMooNSGAAlgorithm):
 def __init__(self, measurement_name: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, 'pymoo_NSGA3_algorithm', functional_scenarios,test_config, number_of_runs, warmups, verbose)
 def init_problem(self, logical_scenario: LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 # Instantiate the problem
 problem = NSGAProblem(logical_scenario, eval_data)
 initial_population = Population.new("X", initial_population)
 if problem.aggregate.object_num > eval_data.population_size:
 eval_data.population_size = problem.aggregate.object_num
 ref_dirs = get_reference_directions("das-dennis", problem.aggregate.object_num, n_partitions=1)
 # Define the NSGA-III algorithm
 algorithm = NSGA3(ref_dirs, pop_size=eval_data.population_size,
 crossover=SBX(eta=eval_data.crossover_eta, prob=eval_data.crossover_prob,),
 mutation=PM(eta=eval_data.mutate_eta, prob=eval_data.mutate_prob), sampling=initial_population,)
 callback = BestSolutionCallback(time.time(), self.verbose)
 termination = OptimumTermination(time.time(), eval_data.timeout, self.verbose)
 return problem, algorithm, callback, termination
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga3_algorithm.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga_algorithm.py>
from abc import ABC, abstractmethod
from typing import List, Tuple
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import Aggregate
from pymoo.optimize import minimize
from pymoo.core.problem import ElementwiseProblem
from pymoo.core.result import Result
import matplotlib.pyplot as plt
import matplotlib
from logical_level.models.logical_scenario import LogicalScenario
from utils.asv_utils import EPSILON
matplotlib.cm.get_cmap = matplotlib.colormaps.get_cmap
from functional_level.metamodels.functional_scenario import FunctionalScenario
from pymoo.core.callback import Callback
from pymoo.core.termination import Termination
import time
from pymoo.algorithms.base.genetic import GeneticAlgorithm
# Define the custom multi-objective optimization problem
class NSGAProblem(ElementwiseProblem):
 def __init__(self,logical_scenario: LogicalScenario, eval_data : EvaluationData):
 self.aggregate = Aggregate.factory(logical_scenario, eval_data.aggregate_strat, minimize=True)
 super().__init__(n_var=logical_scenario.all_variable_num, # Number of decision variables
 n_obj=self.aggregate.object_num, # Number of objective functions
 n_constr=0, # Number of constraints
 xl=logical_scenario.xl, # Lower bounds for variables
 xu=logical_scenario.xu) # Upper bounds for variables
 def _evaluate(self, x, out, *args, **kwargs):
 out["F"] = self.aggregate.evaluate(x)
class OptimumTermination(Termination):
 def __init__(self, start_time, max_time, verbose):
 super().__init__()
 self.verbose = verbose
 self.max_time = max_time
 self.start_time = start_time
 def _update(self, algorithm : GeneticAlgorithm):
 # Check for timeout
 elapsed_time = time.time() - self.start_time
 if elapsed_time > self.max_time:
 if self.verbose:
 print("Stopping due to timeout.")
 return 1.0
 if len(algorithm.callback.best_objective) == 0:
 return 0.0
 f_dist = sum(algorithm.callback.best_objective)
 if f_dist == 0.0:
 if self.verbose:
 print("Stopping as a solution with the desired fitness value is found.")
 return 1.0
 return 0.0
class BestSolutionCallback(Callback):
 def __init__(self, start_time, verbose : bool):
 super().__init__()
 self.verbose = verbose
 self.best_solution : List[float] = []
 self.best_objective : List[float] = []
 self.best_dist = None
 self.number_of_generations = 0
 self.start_time = start_time
 def notify(self, algorithm : GeneticAlgorithm):
 current_pop = algorithm.pop
 for ind in current_pop:
 f_dist = sum(ind.F)
 if self.best_dist == None or (f_dist < self.best_dist):
 self.best_solution = ind.X
 self.best_objective = ind.F
 self.best_dist = f_dist
 if self.verbose:
 print(f"{int(time.time() - self.start_time)} - New best solution found: {ind.X} with objective: {ind.F}")
 self.number_of_generations += 1
class PyMooNSGAAlgorithm(EvolutionaryAlgorithmBase, ABC):
 def __init__(self, measurement_name: str, algorithm_desc: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, algorithm_desc, functional_scenarios,test_config, number_of_runs, warmups, verbose)
 @abstractmethod
 def init_problem(self, logical_scenario: LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 pass
 def do_evaluate(self, some_input, eval_data : EvaluationData):
 # Perform the optimization
 problem, algorithm, callback, termination = some_input
 res : Result = minimize(problem,
 algorithm,
 save_history=self.verbose,
 verbose=self.verbose,
 termination=termination,
 callback=callback)
 return res, callback
 def convert_results(self, some_results : Tuple[Result, BestSolutionCallback], eval_data : EvaluationData) -> Tuple[List[float], List[float], int]:
 res, callback = some_results
 if self.verbose:
 # Plot the convergence
 n_evals = [] # corresponding number of function evaluations
 opt = [] # the optima for each evaluation
 for entry in res.history:
 n_evals.append(entry.evaluator.n_eval)
 opt.append(entry.opt[0].F)
 fig, ax = plt.subplots(figsize=(7, 5))
 ax.plot(n_evals, opt, marker="o")
 ax.set_title("Convergence")
 ax.set_xlabel("Number of Evaluations")
 ax.set_ylabel("Optimum Value")
 fig.show()
 # X = res.X.tolist()
 # X = sorted(X, key=self.logical_scenario.evaluate)
 # Extract the decision variables (X) and objective values (F)
 # return X[0], self.aggregate.evaluate(X[0])
 eval_data.num_parents_mating = 2
 return (list(callback.best_solution), list(callback.best_objective), callback.number_of_generations)
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pymoo_nsga_algorithm.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pyswarm_pso_algorithm.py>
import time
from typing import List, Tuple
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import Aggregate
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
import pyswarms as ps
from functional_level.metamodels.functional_scenario import FunctionalScenario
from logical_level.models.logical_scenario import LogicalScenario
class ObjectiveMonitor():
 def __init__(self, logical_scenario : LogicalScenario, eval_data : EvaluationData, start_time, max_time, verbose) -> None:
 self.verbose = verbose
 self.max_time = max_time
 self.start_time = start_time
 self.best_solution : np.ndarray = np.array([])
 self.best_fitness : float = np.inf
 self.iter_count = 0
 self.aggregate = Aggregate.factory(logical_scenario, eval_data.aggregate_strat, minimize=True)
 def objective(self, x):
 self.iter_count+=1
 elapsed_time = time.time() - self.start_time
 if elapsed_time > self.max_time:
 if self.verbose:
 print('Stopping due to timeout.')
 raise StopIteration()
 F = self.aggregate.evaluate(x)
 for i, f in enumerate(F):
 if f < self.best_fitness:
 self.best_fitness = f
 self.best_solution = x[i]
 if self.best_fitness == 0.0:
 if self.verbose:
 print('Optimal fitness reached.')
 raise StopIteration()
 return F
 def print(self):
 if self.verbose:
 print(f'Best Position: {self.best_solution}')
 print(f'Best Cost: {self.best_fitness}')
 print(f'Iter count: {self.iter_count}')
class PySwarmPSOAlgorithm(EvolutionaryAlgorithmBase):
 def __init__(self, measurement_name: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, 'pyswarm_PSO_algorithm', functional_scenarios,test_config, number_of_runs, warmups, verbose)
 def init_problem(self, logical_scenario: LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 pos = np.array([np.array(ind) for ind in initial_population])
 # Create a PSO instance
 optimizer = ps.single.GlobalBestPSO(options={'c1': eval_data.c_1, 'c2': eval_data.c_2, 'w': eval_data.w},
 n_particles=eval_data.population_size,
 dimensions=logical_scenario.all_variable_num,
 bounds=(np.array(logical_scenario.xl), np.array(logical_scenario.xu)),
 init_pos=pos)
 monitor = ObjectiveMonitor(logical_scenario, eval_data, time.time(), eval_data.timeout, self.verbose)
 return optimizer, monitor
 def do_evaluate(self, some_input : Tuple[ps.single.GlobalBestPSO, ObjectiveMonitor], eval_data : EvaluationData):
 optimizer, monitor = some_input
 try:
 optimizer.optimize(monitor.objective, iters=np.iinfo(np.int64).max, verbose=self.verbose)
 except StopIteration:
 pass
 finally:
 return monitor
 def convert_results(self, some_results : ObjectiveMonitor, eval_data : EvaluationData) -> Tuple[List[float], List[float], int]:
 some_results.print()
 return some_results.best_solution.tolist(), [some_results.best_fitness,], some_results.iter_count
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\pyswarm_pso_algorithm.py>

<src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\scipy_de_algorithm.py>
import time
from typing import List, Tuple
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import Aggregate
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
from scipy.optimize import differential_evolution, OptimizeResult
from functional_level.metamodels.functional_scenario import FunctionalScenario
from logical_level.models.logical_scenario import LogicalScenario
from utils.asv_utils import EPSILON
class ObjectiveMonitorCallback:
 def __init__(self, aggregate : Aggregate, max_time_sec, verbose : bool):
 self.start_time = time.time()
 self.max_time_sec = max_time_sec
 self.current_best_objective = np.inf
 self.aggregate = aggregate
 self.verbose = verbose
 def __call__(self, xk, convergence):
 current_time = time.time()
 if current_time - self.start_time > self.max_time_sec:
 if self.verbose:
 print("Termination stopped due to timeout")
 return True # Stop optimization
 if self.current_best_objective == 0.0:
 if self.verbose:
 print("Optimal solution reached")
 return True # Stop optimization
 return False
 def objective(self, solution):
 objective = self.aggregate.evaluate(solution)[0]
 if self.current_best_objective > objective:
 self.current_best_objective = objective
 return objective
class SciPyDEAlgorithm(EvolutionaryAlgorithmBase):
 def __init__(self, measurement_name: str, functional_scenarios: List[str | FunctionalScenario], test_config : EvaluationData,
 number_of_runs : int, warmups : int, verbose : bool) -> None:
 super().__init__(measurement_name, 'scipy_DE_algorithm', functional_scenarios,test_config, number_of_runs, warmups, verbose)
 self.current_best_objective = np.inf
 def init_problem(self, logical_scenario : LogicalScenario, initial_population : List[List[float]], eval_data : EvaluationData):
 aggregate = Aggregate.factory(logical_scenario, eval_data.aggregate_strat, minimize=True)
 objective_monitor = ObjectiveMonitorCallback(aggregate, eval_data.timeout, self.verbose)
 return list(zip(logical_scenario.xl, logical_scenario.xu)), objective_monitor, initial_population
 def do_evaluate(self, some_input : Tuple[List[Tuple[int, int]], ObjectiveMonitorCallback, List[List[float]]], eval_data : EvaluationData):
 bounds, objective_monitor, initial_pop = some_input
 return differential_evolution(objective_monitor.objective,
 bounds,
 popsize=eval_data.population_size,
 maxiter=np.iinfo(np.int64).max,
 tol=-np.inf, # Relative tolerance for convergence
 atol=-np.inf,
 mutation=eval_data.mutate_prob, # Mutation constant
 recombination=eval_data.crossover_prob, # Recombination constant (crossover)
 callback=objective_monitor, # Custom callback to handle time termination
 disp=self.verbose,
 init=initial_pop)
 def convert_results(self, some_results : OptimizeResult, eval_data : EvaluationData) -> Tuple[List[float], List[float], int]:
 if self.verbose:
 print(some_results)
 iter_num = some_results['nit']
 X : np.ndarray = some_results['x']
 F : np.ndarray = np.array([some_results['fun']])
 return X.tolist(), F.tolist(), iter_num
</src\logical_level\constraint_satisfaction\evolutionary_computation\evolutionary_algorithms\scipy_de_algorithm.py>

<src\logical_level\mapping\instance_initializer.py>
import random
from typing import List
import numpy as np
from abc import ABC, abstractmethod
from logical_level.models.actor_variable import ActorVariable
class InstanceInitializer(ABC):
 def __init__(self, name: str, vessel_vars : List[ActorVariable]) -> None:
 self.actor_vars = vessel_vars
 self.name = name
 @abstractmethod
 def _do_get_population(self) -> List[float]:
 pass
 def get_population(self, pop_size) -> List[List[float]]:
 result : List[List[float]] = []
 for i in range(int(pop_size)):
 result.append(self._do_get_population())
 return result
class RandomInstanceInitializer(InstanceInitializer):
 name = 'uniform'
 def __init__(self, vessel_vars : List[ActorVariable]) -> None:
 super().__init__(self.name, vessel_vars)
 def _do_get_population(self) -> List[float]:
 population : List[float] = []
 for vessel_var in self.actor_vars:
 population += [random.uniform(x, y) for x, y in zip(vessel_var.lower_bounds, vessel_var.upper_bounds)]
 return population
class DeterministicInitializer(InstanceInitializer):
 name = 'deterministic'
 def __init__(self, vessel_vars : List[ActorVariable]) -> None:
 super().__init__(self.name, vessel_vars)
 def _do_get_population(self) -> List[float]:
 population : List[float] = []
 for vessel_var in self.actor_vars:
 population += [(x + y) / 2 for x, y in zip(vessel_var.lower_bounds, vessel_var.upper_bounds)]
 return population
class LatinHypercubeInitializer(InstanceInitializer):
 name = 'lhs'
 def __init__(self, vessel_vars : List[ActorVariable]) -> None:
 super().__init__(self.name, vessel_vars)
 def lhs_sampling(self, n_samples: int, lower_bounds: List[float], upper_bounds: List[float]) -> np.ndarray:
 """
 Generate Latin Hypercube samples within specified bounds for each dimension.
 :param n_samples: Number of samples to generate.
 :param lower_bounds: List of lower bounds for each dimension.
 :param upper_bounds: List of upper bounds for each dimension.
 :return: Array of Latin Hypercube samples.
 """
 n_dim = len(lower_bounds)
 result = np.zeros((n_samples, n_dim))
 # Create intervals for each dimension
 intervals = np.linspace(0, 1, n_samples + 1)
 for i in range(n_dim):
 points = np.random.uniform(intervals[:-1], intervals[1:])
 np.random.shuffle(points) # Ensure random ordering of points in this dimension
 result[:, i] = lower_bounds[i] + points * (upper_bounds[i] - lower_bounds[i])
 return result
 def _do_get_population(self) -> List[float]:
 population: List[float] = []
 for vessel_var in self.actor_vars:
 population += self.lhs_sampling(1, vessel_var.lower_bounds, vessel_var.upper_bounds)[0]
 return population
</src\logical_level\mapping\instance_initializer.py>

<src\logical_level\mapping\logical_scenario_builder.py>
from itertools import chain
from typing import List, Optional, Tuple
from functional_level.metamodels.functional_object import FuncObject
from logical_level.models.relation_constraints import AtVis, CrossingBear, HeadOnBear, MayCollide, OutVis, OvertakingBear, RelationConstrClause, RelationConstrTerm
from logical_level.models.actor_variable import ActorVariable, OSVariable, TSVariable, VesselVariable
from logical_level.mapping.instance_initializer import DeterministicInitializer, InstanceInitializer, LatinHypercubeInitializer, RandomInstanceInitializer
from logical_level.models.logical_scenario import LogicalScenario
from functional_level.metamodels.functional_scenario import FunctionalScenario
from logical_level.models.vessel_types import ALL_VESSEL_TYPES, VesselType
from utils.scenario import Scenario
class LogicalScenarioBuilder():
 @staticmethod
 def build_from_functional(functional_scenario : FunctionalScenario, init_method=RandomInstanceInitializer.name) -> LogicalScenario:
 def class_type_map(obj : FuncObject) -> Optional[VesselType]:
 for i, vessel_type in enumerate(ALL_VESSEL_TYPES):
 if functional_scenario.is_vessel_class_x(i, obj):
 return vessel_type
 return None
 object_variable_map = {
 obj: OSVariable(obj.id, class_type_map(obj)) if functional_scenario.is_os(obj)
 else TSVariable(obj.id, class_type_map(obj)) if functional_scenario.is_ts(obj)
 else ValueError('Neither OS or TS.')
 for obj in functional_scenario.func_objects
 }
 # Define interpretations and their corresponding LogicalScenarioBuilder methods
 interpretations = [
 (functional_scenario.not_in_colreg_pairs, LogicalScenarioBuilder.get_no_collide_out_vis_clause),
 (functional_scenario.head_on_interpretation.get_tuples(), LogicalScenarioBuilder.get_head_on_term),
 (functional_scenario.crossing_interpretation.get_tuples(), LogicalScenarioBuilder.get_crossing_term),
 (functional_scenario.overtaking_interpretation.get_tuples(), LogicalScenarioBuilder.get_overtaking_term),
 ]
 # Generate relation constraint expressions
 relation_constr_exprs = {
 method(
 object_variable_map[o1],
 object_variable_map[o2]
 )
 for tuples, method in interpretations
 for o1, o2 in tuples
 }
 actor_variables : List[ActorVariable] = sorted(object_variable_map.values(), key=lambda x: x.id)
 return LogicalScenario(LogicalScenarioBuilder.get_initializer(init_method, actor_variables),
 RelationConstrTerm(relation_constr_exprs), *LogicalScenarioBuilder.get_bounds(actor_variables))
 @staticmethod
 def build(scenario : Scenario, init_method : str) -> LogicalScenario:
 if isinstance(scenario, FunctionalScenario):
 return LogicalScenarioBuilder.build_from_functional(scenario, init_method)
 elif isinstance(scenario, LogicalScenario):
 return scenario
 else:
 raise ValueError('Insufficient scenario type')
 @staticmethod
 def get_bounds(actor_variables : List[ActorVariable]) -> Tuple[List[float], List[float]]:
 xl = list(chain.from_iterable([var.lower_bounds for var in actor_variables]))
 xu = list(chain.from_iterable([var.upper_bounds for var in actor_variables]))
 return xl, xu
 @staticmethod
 def get_initializer(init_method : str, vessel_vars : List[ActorVariable]) -> InstanceInitializer:
 if init_method == RandomInstanceInitializer.name or init_method == None:
 return RandomInstanceInitializer(vessel_vars)
 elif init_method == DeterministicInitializer.name:
 return DeterministicInitializer(vessel_vars)
 elif init_method == LatinHypercubeInitializer.name:
 return LatinHypercubeInitializer(vessel_vars)
 else:
 raise Exception('unknown parameter')
 @staticmethod
 def get_head_on_term(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({AtVis(var1, var2), HeadOnBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_overtaking_term(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({AtVis(var1, var2), OvertakingBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_crossing_term(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({AtVis(var1, var2), CrossingBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_head_on_term_soft(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({HeadOnBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_overtaking_term_soft(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({OvertakingBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_crossing_term_soft(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({CrossingBear(var1, var2), MayCollide(var1, var2)})
 @staticmethod
 def get_no_collide_out_vis_clause(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrClause:
 return RelationConstrClause({OutVis(var1, var2), MayCollide(var1, var2, negated=True)})
 @staticmethod
 def get_at_vis_may_collide_term(var1 : VesselVariable, var2 : VesselVariable) -> RelationConstrTerm:
 return RelationConstrTerm({AtVis(var1, var2), MayCollide(var1, var2)})
</src\logical_level\mapping\logical_scenario_builder.py>

<src\logical_level\models\actor_variable.py>
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Optional
import numpy as np
from logical_level.models.vessel_types import PassengerShip, VesselType
from utils.asv_utils import EPSILON, MAX_BEAM, MAX_COORD, MAX_HEADING, MAX_LENGTH, MAX_SPEED_IN_MS, MIN_BEAM, MIN_COORD, MIN_HEADING, MIN_LENGTH, MIN_SPEED_IN_MS
@dataclass(frozen=True)
class ActorVariable(ABC):
 id : int
 @property
 @abstractmethod
 def name(self) -> str:
 pass
 def __str__(self) -> str:
 return self.name
 def __repr__(self) -> str:
 return self.name
 @property
 @abstractmethod
 def upper_bounds(self) -> List[float]:
 pass
 @property
 @abstractmethod
 def lower_bounds(self) -> List[float]:
 pass
 def __len__(self) -> int:
 return len(self.lower_bounds)
@dataclass(frozen=True)
class VesselVariable(ActorVariable, ABC):
 vessel_type : Optional[VesselType] = None
 @property
 def min_length(self) -> float:
 if self.vessel_type is None:
 return MIN_LENGTH
 return self.vessel_type.min_length
 @property
 def max_length(self) -> float:
 if self.vessel_type is None:
 return MAX_LENGTH
 return self.vessel_type.max_length
 @property
 def min_beam(self) -> float:
 if self.vessel_type is None:
 return MIN_BEAM
 return self.vessel_type.min_beam
 @property
 def max_beam(self) -> float:
 if self.vessel_type is None:
 return MAX_BEAM
 return self.vessel_type.max_beam
 @property
 def min_speed(self) -> float:
 if self.vessel_type is None:
 return MIN_SPEED_IN_MS
 return self.vessel_type.min_speed
 @property
 def max_speed(self) -> float:
 if self.vessel_type is None:
 return MAX_SPEED_IN_MS
 return self.vessel_type.max_speed
 @property
 def min_heading(self) -> float:
 return MIN_HEADING
 @property
 def max_heading(self) -> float:
 return MAX_HEADING
 @property
 def min_coord(self) -> float:
 return MIN_COORD
 @property
 def max_coord(self) -> float:
 return MAX_COORD
 @property
 @abstractmethod
 def is_os(self) -> bool:
 pass
 @property
 @abstractmethod
 def name(self) -> str:
 pass
 @property
 def upper_bounds(self) -> List[float]:
 return [self.max_coord, self.max_coord, self.max_heading, self.max_length, self.max_speed]
 @property
 def lower_bounds(self) -> List[float]:
 return [self.min_coord, self.min_coord, self.min_heading, self.min_length, self.min_speed]
@dataclass(frozen=True)
class OSVariable(VesselVariable):
 vessel_type : Optional[VesselType] = PassengerShip()
 @property
 def min_length(self) -> float:
 return 30 - EPSILON
 @property
 def max_length(self) -> float:
 return 30 + EPSILON
 @property
 def min_beam(self) -> float:
 return 10 - EPSILON
 @property
 def max_beam(self) -> float:
 return 10 + EPSILON
 @property
 def min_heading(self) -> float:
 return np.pi / 2 - EPSILON
 @property
 def max_heading(self) -> float:
 return np.pi / 2 + EPSILON
 @property
 def min_coord(self) -> float:
 return MAX_COORD / 2 - EPSILON
 @property
 def max_coord(self) -> float:
 return MAX_COORD / 2 + EPSILON
 @property
 def name(self) -> str:
 return f'OS_{self.id}'
 @property
 def is_os(self) -> bool:
 return True
@dataclass(frozen=True)
class TSVariable(VesselVariable):
 @property
 def name(self) -> str:
 return f'TS_{self.id}'
 @property
 def is_os(self) -> bool:
 return False
</src\logical_level\models\actor_variable.py>

<src\logical_level\models\logical_model_manager.py>
import itertools
from typing import Dict, List, Optional
from logical_level.mapping.instance_initializer import RandomInstanceInitializer
from logical_level.mapping.logical_scenario_builder import LogicalScenarioBuilder
from logical_level.models.actor_variable import OSVariable, TSVariable
from logical_level.models.logical_scenario import LogicalScenario
from logical_level.models.relation_constraints import RelationConstrTerm
class LogicalModelManager():
 __scenario_cache_map = {
 2 : None,
 3 : None,
 4 : None,
 5 : None,
 6 : None
 }
 @classmethod
 def get_x_vessel_scenarios(cls, vessel_number) -> List[LogicalScenario]:
 if cls.__scenario_cache_map[vessel_number] is not None:
 return [cls.__scenario_cache_map[vessel_number]]
 os = OSVariable(0)
 ts_vessels = [TSVariable(i) for i in range(1, vessel_number)]
 actor_variables = [os] + ts_vessels
 relation_constr_exprs = set([LogicalScenarioBuilder.get_no_collide_out_vis_clause(v1, v2) for v1, v2 in itertools.combinations(ts_vessels, 2)] +
 [LogicalScenarioBuilder.get_at_vis_may_collide_term(os, ts) for ts in ts_vessels])
 cls.__scenario_cache_map[vessel_number] = LogicalScenario(LogicalScenarioBuilder.get_initializer(RandomInstanceInitializer.name, actor_variables),
 RelationConstrTerm(relation_constr_exprs),
 *LogicalScenarioBuilder.get_bounds(actor_variables))
 return [cls.__scenario_cache_map[vessel_number]]
</src\logical_level\models\logical_model_manager.py>

<src\logical_level\models\logical_scenario.py>
from dataclasses import dataclass
from typing import List
import numpy as np
from logical_level.mapping.instance_initializer import InstanceInitializer
from logical_level.models.relation_constraints import RelationConstrComposite
from logical_level.models.actor_variable import ActorVariable
from utils.scenario import Scenario
@dataclass(frozen=True)
class LogicalScenario(Scenario):
 initializer : InstanceInitializer
 relation_constraint : RelationConstrComposite
 xl : List[float]
 xu : List[float]
 @property
 def actor_vars(self) -> List[ActorVariable]:
 return self.initializer.actor_vars
 @property
 def size(self) -> int:
 return len(self.actor_vars)
 @property
 def all_variable_num(self) -> int:
 return len(self.xl)
 @property
 def name(self) -> str:
 return f'{str(self.size)}vessel'
 def get_population(self, pop_size) -> List[List[float]]:
 population = self.initializer.get_population(pop_size=pop_size)
 return population
 def pop_to_np_array(self, pop : List[List[float]]):
 new_pop = []
 for p in pop :
 new_pop.append(np.array(p))
 return np.array(new_pop)
</src\logical_level\models\logical_scenario.py>

<src\logical_level\models\penalty.py>
from dataclasses import dataclass, field
from typing import Dict, Tuple
from logical_level.models.actor_variable import ActorVariable
@dataclass(frozen=True)
class Penalty():
 actor_penalties : Dict[ActorVariable, float] = field(default_factory=dict)
 visibility_penalty : float = 0
 bearing_penalty : float = 0
 collision_penalty : float = 0
 dimension_penalty : float = 0
 category_num = 4
 info : str = ""
 @property
 def total_penalty(self) -> float:
 return self.visibility_penalty + self.bearing_penalty + self.collision_penalty + self.dimension_penalty
 @property
 def categorical_penalties(self) -> Tuple[float, float, float, float]:
 return (self.visibility_penalty, self.bearing_penalty, self.collision_penalty, self.dimension_penalty)
 def __add__(self, other):
 if not isinstance(other, Penalty):
 return NotImplemented
 new_actor_penalties = self.actor_penalties.copy() # Start with a copy of dict1
 for var, value in other.actor_penalties.items():
 if var in new_actor_penalties:
 new_actor_penalties[var] += value # Add values for keys present in both
 else:
 new_actor_penalties[var] = value # Add new key-value pairs
 return Penalty(new_actor_penalties, self.visibility_penalty + other.visibility_penalty,
 self.bearing_penalty + other.bearing_penalty,
 self.collision_penalty + other.collision_penalty,
 self.dimension_penalty + other.dimension_penalty,
 f'{self.info}\n{other.info}')
 def __eq__(self, other):
 if isinstance(other, Penalty):
 return self.total_penalty == other.total_penalty
 return NotImplemented
 def __lt__(self, other):
 if isinstance(other, Penalty):
 return self.total_penalty < other.total_penalty
 return NotImplemented
 def __le__(self, other):
 return self == other or self < other
 def __repr__(self):
 return f"penalty[{self.visibility_penalty}, {self.bearing_penalty}, {self.collision_penalty}, {self.dimension_penalty}]"
 @property
 def is_zero(self) -> bool:
 return self.total_penalty == 0
</src\logical_level\models\penalty.py>

<src\logical_level\models\relation_constraints.py>
from abc import ABC, abstractmethod
from typing import Set
import numpy as np
from utils.asv_utils import BEAM_ANGLE, BOW_ANGLE, DIST_DRIFT, MASTHEAD_LIGHT_ANGLE, MAX_DISTANCE, MAX_LENGTH, MAX_SPEED_IN_MS
from logical_level.constraint_satisfaction.assignments import Assignments
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache, GeometricProperties
from logical_level.models.penalty import Penalty
from logical_level.models.values import Values
from logical_level.models.actor_variable import ActorVariable, VesselVariable
class RelationConstrComposite(ABC):
 def __init__(self, components : Set['RelationConstrComposite']):
 super().__init__()
 self.components : Set['RelationConstrComposite'] = components
 @abstractmethod
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 pass
 def evaluate_penalty(self, assignments : Assignments) -> Penalty:
 cache = EvaluationCache(assignments)
 return self._evaluate_penalty(cache)
class RelationConstrTerm(RelationConstrComposite):
 def __init__(self, components : Set['RelationConstrComposite'] = set()):
 super().__init__(components)
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 return sum([comp._evaluate_penalty(eval_cache) for comp in self.components], Penalty())
 def __repr__(self) -> str:
 return f'({" ∧ ".join(f"{comp}" for comp in self.components)})'
class RelationConstrClause(RelationConstrComposite):
 def __init__(self, components : Set['RelationConstrComposite'] = set()):
 super().__init__(components)
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 return min([comp._evaluate_penalty(eval_cache) for comp in self.components])
 def __repr__(self) -> str:
 return f'({" ∨ ".join(f"{comp}" for comp in self.components)})'
class Literal(RelationConstrComposite, ABC):
 def __init__(self, literal_type : str, max_penalty, negated):
 super().__init__(components=set())
 self.literal_type = literal_type
 self.max_penalty = max_penalty
 self.negated = negated
 @property
 def name(self):
 prefix = "!" if self.negated else ""
 return prefix + self.literal_type
 @abstractmethod
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 pass
 def penalty(self, val, lb, ub) -> float:
 if not self.negated:
 dist = self._penalty(val, lb, ub)
 return self._normalize(dist, lb, ub)
 else:
 dist1 = self._penalty(val, 0, lb)
 dist2 = self._penalty(val, ub, self.max_penalty)
 return min(self._normalize(dist1, 0, lb), self._normalize(dist2, ub, self.max_penalty))
 def _penalty(self, val, lb, ub):
 if val < lb:
 distance = lb - val
 elif val > ub:
 distance = val - ub
 else:
 return 0.0
 return distance
 def _normalize(self, dist, lb, ub) -> float:
 return dist / (max(lb, self.max_penalty - ub))
class BinaryLiteral(Literal, ABC):
 def __init__(self, var1 : ActorVariable, var2 : ActorVariable, literal_type, max_penalty, negated):
 super().__init__(literal_type, max_penalty, negated)
 self.var1 = var1
 self.var2 = var2
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 return self._do_evaluate_penalty(eval_cache.get_props(self.var1, self.var2))
 @abstractmethod
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 pass
 def __repr__(self) -> str:
 return f'{self.name}({self.var1}, {self.var2})'
class UnaryLiteral(Literal, ABC):
 def __init__(self, var : ActorVariable, literal_type, max_penalty, negated):
 super().__init__(literal_type, max_penalty, negated)
 self.var = var
 def _evaluate_penalty(self, eval_cache : EvaluationCache) -> Penalty:
 values = eval_cache.assignments.get(self.var)
 return self._do_evaluate_penalty(values)
 @abstractmethod
 def _do_evaluate_penalty(self, value : Values) -> Penalty:
 pass
 def __repr__(self) -> str:
 return f'{self.name}({self.var})'
############ VISIBILITY DISTANCE ##################
class AtVis(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'AtVis', MAX_DISTANCE, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.o_distance, geo_props.vis_distance - DIST_DRIFT, geo_props.vis_distance + DIST_DRIFT)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, visibility_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
class InVis(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'InVis', MAX_DISTANCE, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.o_distance, geo_props.safety_dist, geo_props.vis_distance)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, visibility_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
class OutVis(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'OutVis', MAX_DISTANCE, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.o_distance, max(geo_props.vis_distance, geo_props.safety_dist), MAX_DISTANCE)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, visibility_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
############ COLREG RELATIVE BEARING ##################
class CrossingBear(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'CrossingBear', np.pi, negated)
 rotation_angle : float = (BOW_ANGLE + BEAM_ANGLE) / 2
 def __rotated_v2(self, geo_props : GeometricProperties):
 rotation_matrix = np.array([
 [np.cos(self.rotation_angle), -np.sin(self.rotation_angle)],
 [np.sin(self.rotation_angle), np.cos(self.rotation_angle)]
 ])
 # Rotate vector
 return np.dot(rotation_matrix, geo_props.val2.v)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 angle_p21_v2_rot = np.arccos(np.dot(geo_props.p21, self.__rotated_v2(geo_props)) /
 geo_props.o_distance / geo_props.val2.sp)
 penalty = (self.penalty(angle_p21_v2_rot, 0.0, BEAM_ANGLE / 2.0) + self.penalty(geo_props.angle_p12_v1, 0.0, MASTHEAD_LIGHT_ANGLE / 2.0))
 return Penalty({self.var1 : penalty, self.var2 : penalty}, bearing_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
class HeadOnBear(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'HeadOnBear', np.pi, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.angle_p21_v2, 0.0, BOW_ANGLE / 2.0) + self.penalty(geo_props.angle_p12_v1, 0.0, BOW_ANGLE / 2.0)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, bearing_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
class OvertakingBear(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'OvertakingBear', np.pi, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.angle_p21_v2, MASTHEAD_LIGHT_ANGLE / 2.0, np.pi) + self.penalty(geo_props.angle_p12_v1, 0.0, MASTHEAD_LIGHT_ANGLE / 2.0)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, bearing_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
############ MAY COLLISION ##################
class MayCollide(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'MayCollide', MAX_DISTANCE, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.dcpa, 0, geo_props.safety_dist)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, collision_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
############ COLLISION ##################
class DoCollide(BinaryLiteral):
 def __init__(self, var1 : VesselVariable, var2 : VesselVariable, negated : bool = False):
 super().__init__(var1, var2, 'DoCollide', MAX_DISTANCE, negated)
 def _do_evaluate_penalty(self, geo_props : GeometricProperties) -> Penalty:
 penalty = self.penalty(geo_props.o_distance, 0, geo_props.safety_dist)
 return Penalty({self.var1 : penalty, self.var2 : penalty}, collision_penalty=penalty,
 info=fr'{self.name}({self.var1, self.var2}) : {penalty}')
class LengthLiteral(UnaryLiteral):
 def __init__(self, var : VesselVariable, negated : bool = False):
 super().__init__(var, 'Length', MAX_LENGTH, negated)
 self.var : VesselVariable = var
 def _do_evaluate_penalty(self, values : Values) -> Penalty:
 penalty = self.penalty(values.l, self.var.min_length, self.var.max_length)
 return Penalty({self.var : penalty}, dimension_penalty=penalty,
 info=fr'{self.name}({self.var}) : {penalty}')
class SpeedLiteral(UnaryLiteral):
 def __init__(self, var : VesselVariable, negated : bool = False):
 super().__init__(var, 'Speed', MAX_SPEED_IN_MS, negated)
 self.var : VesselVariable = var
 def _do_evaluate_penalty(self, values : Values) -> Penalty:
 penalty = self.penalty(values.sp, self.var.min_speed, self.var.max_speed)
 return Penalty({self.var : penalty}, dimension_penalty=penalty,
 info=fr'{self.name}({self.var}) : {penalty}')
</src\logical_level\models\relation_constraints.py>

<src\logical_level\models\values.py>
from dataclasses import dataclass, field
import numpy as np
@dataclass(frozen=True)
class Values():
 x : float
 y : float
 h : float
 l : float
 sp: float
 p: np.ndarray = field(init=False)
 v: np.ndarray = field(init=False)
 v_norm: np.ndarray = field(init=False)
 v_norm_perp: np.ndarray = field(init=False)
 r: float = field(init=False)
 def __post_init__(self):
 object.__setattr__(self, 'p', np.array([self.x, self.y]))
 object.__setattr__(self, 'v', np.array([np.cos(self.h), np.sin(self.h)]) * self.sp)
 object.__setattr__(self, 'v_norm', self.v / self.sp)
 object.__setattr__(self, 'v_norm_perp', np.array([self.v_norm[1], -self.v_norm[0]]))
 object.__setattr__(self, 'r', 4.0 * self.l)
</src\logical_level\models\values.py>

<src\logical_level\models\vessel_types.py>
from abc import ABC
from dataclasses import dataclass
from typing import List
from utils.asv_utils import KNOT_TO_MS_CONVERSION, MAX_BEAM, MAX_LENGTH, MAX_SPEED_IN_MS, MIN_BEAM, MIN_LENGTH, MIN_SPEED_IN_MS
"""
Ship types:
tanker, MMSI: 413474690 : 93 x 17 m
tanker, MMSI: 412377520 : 146 x 21 m
tanker, MMSI: 413441230 : 82 x 12 m
tanker, MMSI: 413697340 : 96 x 16 m
container, MMSI: 413146000 : 263 x 32 m
container, MMSI: 412713000 : 294 x 32 m
container, MMSI: 212602000 : 259 x 32 m
cargo vessel, MMSI: 413700110 : 159 x 23 m
cargo vessel, MMSI: 412766340 : 179 x 28 m
High Speed Craft, MMSI: 477937400 : 47 x 12 m
High Speed Craft, MMSI: 477937500 : 47 x 12 m
High Speed Craft, MMSI: 477937200 : 47 x 12 m
High Speed Craft, MMSI: 477525000 : 40 x 15 m
High Speed Craft, MMSI: 477385000 :	45 x 12 m
Passenger ship, MMSI: 477995974 : 25 x 8 m
Passenger ship, MMSI: 477995293 : 30 x 8 m
"""
@dataclass(frozen=True, repr=False)
class VesselType(ABC):
 name : str = 'VesselType'
 min_length : float = MIN_LENGTH
 max_length : float = MAX_LENGTH
 min_speed : float = MIN_SPEED_IN_MS
 max_speed : float = MAX_SPEED_IN_MS
 min_beam : float = MIN_BEAM
 max_beam : float = MAX_BEAM
 def do_match(self, length : float, speed : float, beam=None) -> bool:
 return (self.min_length <= length <= self.max_length and
 self.min_speed <= speed <= self.max_speed and
 (beam is None or self.min_beam <= beam <= self.max_beam)
 )
 def __repr__(self):
 return self.name
 def __str__(self):
 return self.name
 @staticmethod
 def get_vessel_type_by_name(name):
 return next((t for t in ALL_VESSEL_TYPES if t.name == name), None)
@dataclass(frozen=True, repr=False)
class OtherType(VesselType):
 name : str = 'OtherType'
 pass
@dataclass(frozen=True, repr=False)
class CargoShip(VesselType):
 name : str = 'CargoShip'
 min_length : float = 50
 max_length : float = 400
 max_speed : float = 25 * KNOT_TO_MS_CONVERSION
 min_beam : float = 10
 max_beam : float = 60
@dataclass(frozen=True, repr=False)
class Tanker(VesselType):
 name : str = 'Tanker'
 min_length : float = 60
 max_length : float = 350
 max_speed : float = 20 * KNOT_TO_MS_CONVERSION
 min_beam : float = 10
 max_beam : float = 60
@dataclass(frozen=True, repr=False)
class ContainerShip(VesselType):
 name : str = 'ContainerShip'
 min_length : float = 100
 max_length : float = 400
 max_speed : float = 25 * KNOT_TO_MS_CONVERSION
 min_beam : float = 15
 max_beam : float = 65
@dataclass(frozen=True, repr=False)
class PassengerShip(VesselType):
 name : str = 'PassengerShip'
 min_length : float = 20
 max_length : float = 350
 max_speed : float = 40 * KNOT_TO_MS_CONVERSION
 min_beam : float = 5
 max_beam : float = 50
@dataclass(frozen=True, repr=False)
class FishingShip(VesselType):
 name : str = 'FishingShip'
 min_length : float = 2
 max_length : float = 100
 max_speed : float = 15 * KNOT_TO_MS_CONVERSION
 min_beam : float = 2
 max_beam : float = 20
@dataclass(frozen=True, repr=False)
class MotorVessel(VesselType):
 name : str = 'MotorVessel'
 min_length : float = 10
 max_length : float = 370
 max_speed : float = 30 * KNOT_TO_MS_CONVERSION
 min_beam : float = 3
 max_beam : float = 80
@dataclass(frozen=True, repr=False)
class SailingVessel(VesselType):
 name : str = 'SailingVessel'
 min_length : float = 5
 max_length : float = 60
 max_speed : float = 20 * KNOT_TO_MS_CONVERSION
 min_beam : float = 2
 max_beam : float = 12
@dataclass(frozen=True, repr=False)
class MilitaryVessel(VesselType):
 name : str = 'MilitaryVessel'
 min_length : float = 20
 max_length : float = 300
 max_speed : float = 50 * KNOT_TO_MS_CONVERSION
 min_beam : float = 5
 max_beam : float = 40
ALL_VESSEL_TYPES : List[VesselType] = [OtherType(), Tanker(), CargoShip(), ContainerShip(), PassengerShip(), FishingShip(), MotorVessel(), SailingVessel(), MilitaryVessel()]
</src\logical_level\models\vessel_types.py>

<src\scripts\annotate_risk_vectors.py>
from typing import List
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from concrete_level.data_parser import EvalDataParser
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from evaluation.risk_evaluation import RiskVector
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
dp = EvalDataParser()
eval_datas : List[EvaluationData] = dp.load_dirs_merged_as_models()
skipped = 0
done = 0
# for eval_data in eval_datas:
# pass
# eval_data.save_to_json(path2=eval_data.path)
# done += 1
# print(f'Config Group: {eval_data.config_group}. Done {done}, Skipped: {skipped} / {len(eval_datas)}')
# exit(0)#-------------------------------------------------------
START_FROM = 0
def info(data : EvaluationData):
 print(f'''Measurement: {data.measurement_name}, Algorithm: {data.algorithm_desc}, Config name: {data.scenario_name}
 Config Group: {data.config_group}. Done {done}, Skipped: {skipped}, ({done + skipped} / {len(eval_datas)}, {(done + skipped) / len(eval_datas) * 100:.1f} %)''')
for i, eval_data in enumerate(eval_datas):
 if i < START_FROM:
 if eval_data.best_scene.has_risk_metrics:
 done += 1
 else:
 skipped += 1
 print('Before start, skipped.')
 info(eval_data)
 continue
 if eval_data.best_fitness_index > 0.0:
 eval_data.best_scene = SceneBuilder(eval_data.best_scene._data).build()
 skipped += 1
 print('Not optimal solution, skipped.')
 else:
 risk_vector = RiskVector(ConcreteSceneAbstractor.get_abstractions_from_eval(eval_data))
 eval_data.best_scene = SceneBuilder(eval_data.best_scene._data).build(risk_vector.min_dcpa,
 risk_vector.min_tcpa, risk_vector.danger_sector, risk_vector.max_proximity_index)
 done += 1
 eval_data.save_to_json()
 info(eval_data)
</src\scripts\annotate_risk_vectors.py>

<src\scripts\common_ocean_scenario_parser.py>
from datetime import datetime
from typing import Dict, List
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.vessel_state import VesselState
from concrete_level.trajectory_generation.scene_builder import SceneBuilder
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.models.vessel_types import CargoShip, FishingShip, MilitaryVessel, MotorVessel, PassengerShip, VesselType
from utils.asv_utils import EGO_BEAM, EGO_LENGTH, vessel_radius
from utils.file_system_utils import ASSET_FOLDER, get_all_file_paths
from commonroad.geometry.shape import Rectangle
from commonocean.common.file_reader import CommonOceanFileReader
from commonocean.scenario.obstacle import ObstacleType
COMMON_OCEAN_PATH = f'{ASSET_FOLDER}/common_ocean_scenarios'
COMMON_OCEAN_TWO_VESSEL_SCENARIOS_PATH = f'{COMMON_OCEAN_PATH}/HandcraftedTwoVesselEncounters_01_24'
COMMON_OCEAN_FLO_SCENARIOS_PATH = f'{COMMON_OCEAN_PATH}/Florida'
COMMON_OCEAN_MEC_SCENARIOS_PATH = f'{COMMON_OCEAN_PATH}/MiddleEastCoast'
COMMON_OCEAN_UWC_SCENARIOS_PATH = f'{COMMON_OCEAN_PATH}/UpperWestCoast'
obstacle_type_map : Dict[ObstacleType, VesselType]= {ObstacleType.CARGOSHIP : CargoShip(),
 ObstacleType.FISHINGVESSEL : FishingShip(),
 ObstacleType.MILITARYVESSEL : MilitaryVessel(),
 ObstacleType.MOTORVESSEL : MotorVessel()}
def get_scenes(file_path : str)-> List[ConcreteScene]:
 scenes : List[ConcreteScene] = []
 # read in the scenario and planning problem set
 scenario, planning_problem_set = CommonOceanFileReader(file_path).open()
 builder = SceneBuilder()
 vessel_id = 1
 for obst in scenario.dynamic_obstacles:
 if obst.obstacle_type is None or obst.obstacle_type in obstacle_type_map.keys():
 p = obst.initial_state.position
 speed = obst.initial_state.velocity
 heading = obst.initial_state.orientation
 vessel_type = obstacle_type_map[obst.obstacle_type]
 if isinstance(obst.obstacle_shape, Rectangle):
 if obst.obstacle_shape.length > vessel_type.max_length or obst.obstacle_shape.length < vessel_type.min_length:
 raise ValueError('Object length is out of vessel type limits. Adjust!')
 if obst.obstacle_shape.width > vessel_type.max_beam or obst.obstacle_shape.width < vessel_type.min_beam:
 raise ValueError('Object beam is out of vessel type limits. Adjust!')
 if speed > vessel_type.max_speed or speed < vessel_type.min_speed:
 raise ValueError('Object speed is out of vessel type limits. Adjust!')
 builder.set_state(ConcreteVessel(vessel_id, False, obst.obstacle_shape.length, vessel_radius(obst.obstacle_shape.length), vessel_type.max_speed, vessel_type.name, beam=obst.obstacle_shape.width),
 VesselState(p[0], p[1], speed, heading))
 vessel_id += 1
 if len(builder) == 0:
 return scenes
 ego_vessel_type = PassengerShip()
 ego_vessel = ConcreteVessel(0, True, EGO_LENGTH, vessel_radius(EGO_LENGTH), ego_vessel_type.max_speed, ego_vessel_type.name, beam = EGO_BEAM)
 for planning_problem in planning_problem_set.planning_problem_dict.values():
 p = planning_problem.initial_state.position
 speed = planning_problem.initial_state.velocity
 heading = planning_problem.initial_state.orientation
 builder.set_state(ego_vessel, VesselState(p[0], p[1], speed, heading))
 scenes.append(builder.build())
 return scenes
# generate path of the file to be read
file_paths = (get_all_file_paths(COMMON_OCEAN_TWO_VESSEL_SCENARIOS_PATH, 'xml') + get_all_file_paths(COMMON_OCEAN_FLO_SCENARIOS_PATH, 'xml') +
 get_all_file_paths(COMMON_OCEAN_MEC_SCENARIOS_PATH, 'xml') + get_all_file_paths(COMMON_OCEAN_UWC_SCENARIOS_PATH, 'xml'))
for file_path in file_paths:
 scenes = get_scenes(file_path)
 for scene in scenes:
 eval_data = EvaluationData()
 eval_data.config_group = 'common_ocean_benchmark'
 eval_data.vessel_number = scene.vessel_number
 eval_data.measurement_name = f'test_{scene.vessel_number}_vessel_scenarios_long'
 eval_data.algorithm_desc = 'ais_source'
 eval_data.scenario_name = f'{scene.vessel_number}vessel'
 eval_data.timestamp = datetime.now().isoformat()
 eval_data.best_scene = scene
 eval_data.best_fitness_index = 0.0
 eval_data.best_fitness = (0.0)
 eval_data.save_as_measurement()
</src\scripts\common_ocean_scenario_parser.py>

<src\scripts\evaluation_main.py>
from typing import List
from functional_level.models.functional_model_manager import FunctionalModelManager
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import ActorAggregate, AggregateAll, AggregateAllSwarm, CategoryAggregate
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga2_algorithm import PyMooNSGA2Algorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pygad_ga_algorithm import PyGadGAAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.scipy_de_algorithm import SciPyDEAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pyswarm_pso_algorithm import PySwarmPSOAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga3_algorithm import PyMooNSGA3Algorithm
from logical_level.mapping.instance_initializer import RandomInstanceInitializer
from logical_level.models.logical_model_manager import LogicalModelManager
# NUMBER_OF_RUNS = {2 : 150, 3 : 6 * 17, 4 : 21 * 5, 5 : 50 * 2, 6 : 99 * 1}
# NUMBER_OF_RUNS = {2 : 150, 3 : 6 * 34, 4 : 21 * 10, 5 : 50 * 4, 6 : 99 * 3}
# NUMBER_OF_RUNS = {2 : 150, 3 : 6 * 50, 4 : 21 * 15, 5 : 50 * 6, 6 : 99 * 4}
NUMBER_OF_RUNS = {2 : 1000, 3 : 1000, 4 : 1000, 5 : 1000, 6 : 1000}
WARMUPS = 2
RANDOM_SEED = 1234
TIMEOUT = 240
INIT_METHOD = RandomInstanceInitializer.name
VERBOSE = False
START_FROM = [0,0,0]
measurement_names= ['test_2_vessel_scenarios', 'test_3_vessel_scenarios', 'test_4_vessel_scenarios',
 'test_5_vessel_scenarios', 'test_6_vessel_scenarios']
#interactions = [FunctionalModelManager.get_x_vessel_scenarios(3)]
interactions = [LogicalModelManager.get_x_vessel_scenarios(2), LogicalModelManager.get_x_vessel_scenarios(3),
 LogicalModelManager.get_x_vessel_scenarios(4), LogicalModelManager.get_x_vessel_scenarios(5),
 LogicalModelManager.get_x_vessel_scenarios(6)]
ga_config = EvaluationData(population_size=4, num_parents_mating = 4,
 mutate_eta=20, mutate_prob=0.2, crossover_eta=10,
 crossover_prob=0.2, timeout=TIMEOUT, init_method=INIT_METHOD,
 random_seed=RANDOM_SEED, aggregate_strat=AggregateAll.name)
nsga2_vessel_config = EvaluationData(population_size=10, mutate_eta=15, mutate_prob=0.8,
 crossover_eta=20, crossover_prob=1, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=ActorAggregate.name,
 config_group='SBO')
nsga2_all_config = EvaluationData(population_size=50, mutate_eta=10, mutate_prob=1.0,
 crossover_eta=20, crossover_prob=0.8, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=AggregateAll.name)
nsga2_category_config = EvaluationData(population_size=4, mutate_eta=5, mutate_prob=0.8,
 crossover_eta=15, crossover_prob=1.0, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=CategoryAggregate.name)
nsga3_vessel_config = EvaluationData(population_size=6, mutate_eta=15, mutate_prob=1.0,
 crossover_eta=10, crossover_prob=0.8, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=ActorAggregate.name)
nsga3_all_config = EvaluationData(population_size=20, mutate_eta=1, mutate_prob=0.8,
 crossover_eta=1, crossover_prob=1.0, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=AggregateAll.name)
nsga3_category_config = EvaluationData(population_size=4, mutate_eta=5, mutate_prob=0.8,
 crossover_eta=15, crossover_prob=1.0, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=CategoryAggregate.name)
pso_config = EvaluationData(population_size=30, c_1=2.5, c_2=1.0, w=0.4, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=AggregateAllSwarm.name)
de_config = EvaluationData(population_size=15, mutate_prob=0.5, crossover_prob=0.5,
 timeout=TIMEOUT, init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat=AggregateAll.name)
algos = [PyMooNSGA2Algorithm]
configs = [nsga2_vessel_config]
meas_start = START_FROM[0]
algo_start = START_FROM[1]
interac_group_start = START_FROM[2]
tests : List[EvolutionaryAlgorithmBase] = []
for i, (measurement_name, interaction) in enumerate(zip(measurement_names[meas_start:], interactions[meas_start:])):
 if i == 0:
 algos_to_run = algos[algo_start:]
 configs_to_run = configs[algo_start:]
 else:
 algos_to_run = algos
 configs_to_run = configs
 for algo, config in zip(algos_to_run, configs_to_run):
 if i == 0:
 interactions_to_run = interaction[interac_group_start:]
 else:
 interactions_to_run = interaction
 number_of_runs_per_interaction = int(NUMBER_OF_RUNS[interactions_to_run[0].size] / len(interactions_to_run))
 one_interaction = [algo(measurement_name=measurement_name, functional_scenarios=interactions_to_run, test_config=config,
 number_of_runs=number_of_runs_per_interaction, warmups=WARMUPS, verbose=VERBOSE)]
 tests += one_interaction
for test in tests:
 test.run()
</src\scripts\evaluation_main.py>

<src\scripts\eval_vis.py>
from concrete_level.data_parser import EvalDataParser
from visualization.evaluation_plots.eval_plot_manager import EvalPlotManager
dp = EvalDataParser()
eval_datas = dp.load_dirs_merged_as_models()
EvalPlotManager(eval_datas)
</src\scripts\eval_vis.py>

<src\scripts\generate_project_outline.py>
""" Generate a report of the python code outline of a folder. """
import os
from utils.file_system_utils import ASSET_FOLDER, ROOT_FOLDER
import os
import re
from pathlib import Path
import argparse
DEFAULT_EXTENSIONS = {".py", ".js", ".java", ".cpp", ".h", ".cs", ".rb"}
# Default exclusion patterns
DEFAULT_EXCLUDES = {
 ".git",
 ".gitignore",
 "__pycache__",
 "node_modules",
 ".env",
 ".venv",
 "venv",
 "env",
 ".idea",
 ".vscode",
 "*.pyc",
 "*.pyo",
 "*.pyd",
 ".DS_Store",
 "Thumbs.db",
 ".pytest_cache",
 "*.egg-info",
 ".mypy_cache",
 "*.xml",
 "*.json",
 "*.problem",
 "assets/media",
 "proof_of_concept",
 "*.pdf",
 "*.svg",
 "*.png",
 "*.jpeg",
 "*.jpg",
 "*.tex",
 "*.mp4"
}
def should_exclude(path, exclude_patterns):
 """Check if path should be excluded based on patterns."""
 path_str = str(path)
 name = path.name
 for pattern in exclude_patterns:
 # Handle glob patterns (*.ext)
 if pattern.startswith("*"):
 if name.endswith(pattern[1:]):
 return True
 # Handle direct matches
 elif pattern in path_str or name == pattern:
 return True
 return False
def get_directory_tree(root_path, exclude_patterns, indent=""):
 """Generate a tree-like directory structure, excluding specified patterns."""
 tree = []
 root = Path(root_path)
 def add_to_tree(path, prefix=""):
 if should_exclude(path, exclude_patterns):
 return
 if path.is_file():
 tree.append(prefix + "├── " + path.name)
 elif path.is_dir():
 tree.append(prefix + "├── " + path.name + "/")
 # Sort directories first, then files
 items = sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name))
 for item in items:
 add_to_tree(item, prefix + "│ ")
 add_to_tree(root)
 return "\n".join(tree)
def clean_content(content):
 """Clean file content to minimize tokens while preserving meaning."""
 # Remove empty lines
 content = re.sub(r"\n\s*\n", "\n", content)
 # Remove trailing whitespace
 content = re.sub(r"[ \t]+$", "", content, flags=re.MULTILINE)
 # Collapse multiple spaces
 content = re.sub(r" +", " ", content)
 return content.strip()
def process_directory(
 directory, extensions=DEFAULT_EXTENSIONS, exclude_patterns=DEFAULT_EXCLUDES, output_file="prompts.txt"
):
 """Process directory and create formatted output file."""
 directory = Path(directory)
 # Generate directory tree
 tree = get_directory_tree(directory, exclude_patterns)
 # Collect and process files
 files_content = []
 # Convert extensions to set for faster lookup
 extensions_set = set(ext.lower() for ext in extensions)
 for file_path in directory.rglob("*"):
 # Skip excluded paths
 if should_exclude(file_path, exclude_patterns):
 continue
 if file_path.is_file():
 # Skip empty files
 if os.path.getsize(file_path) == 0:
 continue
 # Check if file extension matches
 if file_path.suffix.lower() in extensions_set:
 try:
 with open(file_path, "r", encoding="utf-8") as f:
 content = f.read()
 # Clean content
 cleaned_content = clean_content(content)
 # Get relative path from input directory
 relative_path = file_path.relative_to(directory)
 # Add to files content list
 files_content.append(
 f"<{relative_path}>\n{cleaned_content}\n</{relative_path}>"
 )
 except Exception as e:
 print(f"Error processing {file_path}: {e}")
 # Write output file
 with open(output_file, "w", encoding="utf-8") as f:
 # Write directory tree
 f.write("Directory Structure:\n")
 f.write(tree)
 f.write("\n\nFiles Content:\n")
 # Write files content
 f.write("\n\n".join(files_content))
# Specify the report and ignore file paths (optional)
REPORT_DIR_PATH = f'{ASSET_FOLDER}/project_report'
if not os.path.exists(REPORT_DIR_PATH):
 os.makedirs(REPORT_DIR_PATH)
REPORT_FILE_PATH=f"{REPORT_DIR_PATH}/project_report.txt"
process_directory(ROOT_FOLDER, output_file=REPORT_FILE_PATH)
</src\scripts\generate_project_outline.py>

<src\scripts\generate_trajectories.py>
from concrete_level.data_parser import EvalDataParser
from concrete_level.models.trajectory_manager import TrajectoryManager
from concrete_level.trajectory_generation.trajectory_generator import TrajectoryGenerator
from visualization.colreg_scenarios.scenario_plot_manager import ScenarioPlotManager
dp = EvalDataParser()
data_models = dp.load_data_models()
if len(data_models) == 0:
 exit(0)
eval_data = data_models[0]
trajectory_manager = TrajectoryManager(eval_data.best_scene)
ScenarioPlotManager(trajectory_manager)
traj_gen = TrajectoryGenerator(eval_data, trajectory_manager.scenario)
ScenarioPlotManager(TrajectoryManager(traj_gen.trajectories))
</src\scripts\generate_trajectories.py>

<src\scripts\hyperparam_test.py>
import random
import time
import itertools
from typing import Any, List, Tuple
from functional_level.models.functional_model_manager import FunctionalModelManager
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga2_algorithm import PyMooNSGA2Algorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pygad_ga_algorithm import PyGadGAAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.scipy_de_algorithm import SciPyDEAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pyswarm_pso_algorithm import PySwarmPSOAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.evolutionary_algorithm_base import EvolutionaryAlgorithmBase
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga3_algorithm import PyMooNSGA3Algorithm
NUMBER_OF_RUNS = 1
WARMUPS = 0
RANDOM_SEED = 1234
TIMEOUT = 60
INIT_METHOD = 'uniform'
population_sizes = [2, 4, 5, 8, 10, 15, 20, 30, 50, 100]
nums_parents_mating = [2, 4, 8, 10]
mutate_probs = [0.2, 0.5, 0.8, 1]
crossover_probs = [0.2, 0.5, 0.8, 1]
mutate_etas = [1, 5, 10, 15, 20]
crossover_etas = [1, 5, 10, 15, 20]
c1_s = [1.0, 1.5, 2.0, 2.5]
c2_s = [1.0, 1.5, 2.0, 2.5]
w_s = [0.4, 0.6, 0.9]
combinations_GA = list(itertools.product(population_sizes, nums_parents_mating, mutate_probs, crossover_probs, mutate_etas, crossover_etas))
combinations_NSGA = list(itertools.product(population_sizes, mutate_probs, crossover_probs, mutate_etas, crossover_etas))
combinations_PSO = list(itertools.product(population_sizes, c1_s, c2_s, w_s))
combination_DE = list(itertools.product(population_sizes, mutate_probs, crossover_probs))
def create_GA_config() -> EvaluationData:
 if len(combinations_GA) == 0:
 return None
 population_size, num_parents_mating, mutate_prob, crossover_prob, mutate_eta, crossover_eta = combinations_GA[0]
 while num_parents_mating > population_size:
 del combinations_GA[0]
 if len(combinations_GA) == 0:
 return None
 population_size, num_parents_mating, mutate_prob, crossover_prob, mutate_eta, crossover_eta = combinations_GA[0]
 return EvaluationData(population_size = population_size, num_parents_mating = num_parents_mating,
 mutate_eta = mutate_eta, mutate_prob = mutate_prob, crossover_eta=crossover_eta,
 crossover_prob=crossover_prob, timeout=TIMEOUT, init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='all')
def create_NSGA_vessel_config() -> EvaluationData:
 if len(combinations_NSGA) == 0:
 return None
 population_size, mutate_prob, crossover_prob, mutate_eta, crossover_eta = combinations_NSGA[0]
 return EvaluationData(population_size = population_size, mutate_eta = mutate_eta, mutate_prob = mutate_prob,
 crossover_eta=crossover_eta, crossover_prob=crossover_prob, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='actor')
def create_NSGA_all_config() -> EvaluationData:
 if len(combinations_NSGA) == 0:
 return None
 population_size, mutate_prob, crossover_prob, mutate_eta, crossover_eta = combinations_NSGA[0]
 return EvaluationData(population_size = population_size, mutate_eta = mutate_eta, mutate_prob = mutate_prob,
 crossover_eta=crossover_eta, crossover_prob=crossover_prob, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='all')
def create_NSGA_category_config() -> EvaluationData:
 if len(combinations_NSGA) == 0:
 return None
 population_size, mutate_prob, crossover_prob, mutate_eta, crossover_eta = combinations_NSGA[0]
 return EvaluationData(population_size = population_size, mutate_eta = mutate_eta, mutate_prob = mutate_prob,
 crossover_eta=crossover_eta, crossover_prob=crossover_prob, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='category')
def create_PSO_config() -> EvaluationData:
 if len(combinations_PSO) == 0:
 return None
 population_size, c_1, c_2, w = combinations_PSO[0]
 return EvaluationData(population_size = population_size, c_1=c_1, c_2=c_2, w=w, timeout=TIMEOUT,
 init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='all_swarm')
def create_DE_config() -> EvaluationData:
 if len(combination_DE) == 0:
 return None
 population_size, mutate_prob, crossover_prob = combination_DE[0]
 while population_size <= 4:
 del combination_DE[0]
 if len(combination_DE) == 0:
 return None
 population_size, mutate_prob, crossover_prob = combination_DE[0]
 return EvaluationData(population_size = population_size, mutate_prob = mutate_prob, crossover_prob=crossover_prob,
 timeout=TIMEOUT, init_method=INIT_METHOD, random_seed=RANDOM_SEED, aggregate_strat='all')
random.seed(time.time())
random.shuffle(combinations_GA)
random.shuffle(combinations_NSGA)
random.shuffle(combinations_PSO)
random.shuffle(combination_DE)
functional_scenarios = [FunctionalModelManager.get_6_vessel_scenarios()[0]]
tests : List[Tuple[Any, EvolutionaryAlgorithmBase]]= [
 # (create_GA_config, PyGadGAAlgorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_GA_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 (create_NSGA_vessel_config, PyMooNSGA2Algorithm(measurement_name='parameter_optimization_2',
 functional_scenarios=functional_scenarios,
 test_config=create_NSGA_vessel_config(), number_of_runs=NUMBER_OF_RUNS,
 warmups = WARMUPS, verbose=False)),
 (create_NSGA_vessel_config, PyMooNSGA3Algorithm(measurement_name='parameter_optimization_2',
 functional_scenarios=functional_scenarios,
 test_config=create_NSGA_vessel_config(), number_of_runs=NUMBER_OF_RUNS,
 warmups = WARMUPS, verbose=False)),
 # (create_NSGA_category_config, PyMooNSGA2Algorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_NSGA_category_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 # (create_NSGA_category_config, PyMooNSGA3Algorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_NSGA_category_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 # (create_NSGA_all_config, PyMooNSGA2Algorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_NSGA_all_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 # (create_NSGA_all_config, PyMooNSGA3Algorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_NSGA_all_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 # (create_PSO_config, PySwarmPSOAlgorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_PSO_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
 # (create_DE_config, SciPyDEAlgorithm(measurement_name='parameter_optimization_2',
 # functional_scenarios=functional_scenarios,
 # test_config=create_DE_config(), number_of_runs=NUMBER_OF_RUNS,
 # warmups = WARMUPS, verbose=False)),
]
while True:
 runs = 0
 for config_fun, test in tests:
 config = config_fun()
 if config is not None:
 test.test_config = config
 test.run()
 runs += 1
 if runs == 0:
 break
 if len(combinations_GA) > 0:
 del combinations_GA[0]
 if len(combinations_NSGA) > 0:
 del combinations_NSGA[0]
 if len(combinations_PSO) > 0:
 del combinations_PSO[0]
 if len(combination_DE) > 0:
 del combination_DE[0]
</src\scripts\hyperparam_test.py>

<src\scripts\scenic_script.py>
from logical_level.constraint_satisfaction import scenic_sampling
</src\scripts\scenic_script.py>

<src\scripts\table_browser.py>
from typing import Optional
from concrete_level.models.trajectory_manager import TrajectoryManager
from visualization.dash_thread import DashThread
from visualization.colreg_scenarios.scenario_plot_manager import ScenarioPlotManager
dash_thread = DashThread()
dash_thread.start()
colreg_plot_manager : Optional[ScenarioPlotManager] = None
# Main loop to listen for data and create windows
while dash_thread.is_alive():
 concrete_scene = dash_thread.data_queue.get() # Wait for data with a timeout
 colreg_plot_manager = ScenarioPlotManager(TrajectoryManager(concrete_scene))
</src\scripts\table_browser.py>

<src\scripts\test_algorithm.py>
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pymoo_nsga2_algorithm import PyMooNSGA2Algorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pygad_ga_algorithm import PyGadGAAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.pyswarm_pso_algorithm import PySwarmPSOAlgorithm
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from logical_level.constraint_satisfaction.evolutionary_computation.evolutionary_algorithms.scipy_de_algorithm import SciPyDEAlgorithm
from logical_level.models.logical_scenario import LogicalScenario
from visualization.colreg_scenarios.scenario_plot_manager import ScenarioPlotManager
de_config = EvaluationData(population_size = 10, mutate_prob = 0.8, crossover_prob=0.5,
 timeout=10, init_method='uniform', random_seed=22, aggregate_strat='all')
test_config_PSO = EvaluationData(population_size = 10, c_1=1.5, c_2=1.7, w=0.5,
 timeout=10, init_method='uniform', random_seed=1234, aggregate_strat='all_swarm')
configs = ['two_way_overtaking_BIG', 'overtaking_and_head_on_BIG', 'crossing_and_head_on_BIG', 'two_way_crossing_BIG', 'overtaking_and_crossing_BIG']
configs = ['crossing']
configs = ['two_way_overtaking', 'overtaking_and_head_on', 'crossing_and_head_on', 'two_way_crossing', 'overtaking_and_crossing']
alg = SciPyDEAlgorithm(measurement_name='test_for_progress_report', functional_scenarios=configs, test_config=de_config, number_of_runs=20, warmups=0, verbose=True)
#alg = PySwarmPSOAlgorithm(measurement_name='test_pso', functional_scenarios=['two_way_overtaking'], test_config=test_config_PSO, number_of_runs=1, warmups=0, verbose=True)
#alg = SciPyDEAlgorithm(measurement_name='test_6_vessel_scenarios', functional_scenarios=six_vessel_interactions, test_config=de_config,
# number_of_runs=1, warmups=0, verbose=True)
results = alg.run()
#ColregPlotManager(USVEnvironment(alg.functional_scenarios[0]).update(results[0][0].best_solution))
</src\scripts\test_algorithm.py>

<src\scripts\trajectory_viewer.py>
from typing import List
from concrete_level.models.trajectory_manager import TrajectoryManager
from concrete_level.trajectory_generation.trajectory_data import TrajectoryData
from concrete_level.data_parser import TrajDataParser
from visualization.colreg_scenarios.scenario_plot_manager import ScenarioPlotManager
while(True):
 tdp = TrajDataParser()
 traj_data_models : List[TrajectoryData] = tdp.load_data_models()
 if len(traj_data_models) == 0:
 exit(0)
 ScenarioPlotManager(TrajectoryManager(traj_data_models[0].trajectories))
</src\scripts\trajectory_viewer.py>

<src\scripts\wang24_eval.py>
import os
from PIL import Image
import numpy as np
from utils.file_system_utils import ASSET_FOLDER
gradient_image_path = f'{ASSET_FOLDER}/images/gradient.png'
striped_image_path = f'{ASSET_FOLDER}/images/distr.png'
gradient_image = Image.open(gradient_image_path)
striped_image = Image.open(striped_image_path)
# Convert images to numpy arrays for processing
gradient_array = np.array(gradient_image)
striped_array = np.array(striped_image)
# Display shapes to understand dimensions
gradient_array.shape, striped_array.shape
# Average the colors along the width of the gradient image to create a 1D gradient mapping
# (57 rows, each row representing a color to a specific value from 0.0 to 0.8)
gradient_1d = np.mean(gradient_array[:, :, :3], axis=1) # Take RGB channels and average across width
# Define the value range from 0.0 to 0.8, mapping each row in the gradient to a value
value_range = np.linspace(0.0, 0.8, len(gradient_1d))
# Flatten the striped image to get each pixel color for comparison
striped_pixels = striped_array[:, :, :3].reshape(-1, 3)
# Function to find the closest color in the gradient mapping
def map_color_to_value(color, gradient_1d, value_range):
 # Calculate Euclidean distance to each color in gradient_1d
 distances = np.linalg.norm(gradient_1d - color, axis=1)
 # Find the index of the closest color
 closest_index = np.argmin(distances)
 # Map to corresponding value
 return value_range[closest_index]
# Map each pixel in the striped image to a value based on the gradient
mapped_values = np.array([map_color_to_value(pixel, gradient_1d, value_range) for pixel in striped_pixels])
# Calculate mean and median of the mapped values
mean_value = np.mean(mapped_values)
median_value = np.median(mapped_values)
mean_value, median_value
import matplotlib.pyplot as plt
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.serif'] = ['Times New Roman']
plt.rcParams['font.size'] = 12
# Plot the distribution as a violin plot
fig, axi = plt.subplots(1,1,figsize=(2, 3))
# Create the violin plot
violinplot = axi.violinplot(mapped_values, showmeans=True, showmedians=True)
# Add labels and title
axi.set_title("4 Vessels")
axi.set_ylabel("Highest DS-based risk index")
for patch in violinplot['bodies']:
 patch.set_facecolor('brown') # Set fill color
 patch.set_linewidth(1.5)
violinplot['cmeans'].set_color('black')
violinplot['cmeans'].set_linewidth(2)
violinplot['cmedians'].set_color('grey')
violinplot['cmedians'].set_linewidth(2)
violinplot['cmedians'].set_linestyle(':')
axi.set_xticks([1], ['Base'])
axi.set_xticklabels(['Base'], rotation=0, ha='center', fontweight='bold')
axi.text(1, 0.8 * 1.05, f'601', ha='center', va='center', fontsize=10, horizontalalignment='center')
axi.set_ylim(0, 1 * 1.15)
fig.tight_layout()
file_name = f'wang2024_risk'
image_folder = f'{ASSET_FOLDER}/images/exported_plots/wang'
if not os.path.exists(image_folder):
 os.makedirs(image_folder)
fig.canvas.figure.savefig(f'{image_folder}/{file_name}.svg', format='svg', bbox_inches='tight', dpi=350)
fig.canvas.figure.savefig(f'{image_folder}/{file_name}.pdf', format='pdf', bbox_inches='tight', dpi=350)
print('image saved')
# Display the plot
plt.show()
</src\scripts\wang24_eval.py>

<src\scripts\manim\manim_first.py>
import copy
from typing import Any, Tuple
from manim import *
from manim.constants import DEFAULT_DOT_RADIUS, ORIGIN
from manim.utils.color import WHITE
from numpy import floating
from utils.file_system_utils import ASSET_FOLDER
from utils.asv_utils import MAX_COORD
from concrete_level.data_parser import EvalDataParser, TrajDataParser
from logical_level.models.logical_scenario import LoadedEnvironment
from functional_level.metamodels.functional_scenario import Vessel
from visualization.colreg_scenarios.scenario_plot import TrajectoryReceiver
light_colors = [BLUE_A, RED_A, GREEN_A, YELLOW_A, LIGHT_BROWN]
colors = [BLUE_C, RED_C, GREEN_C, YELLOW_C, DARK_BROWN]
class Animated(Mobject):
 def path_animate(self, mobject, t):
 pass
 def refresh_data(self):
 pass
class SimDot(Dot3D, Animated):
 def __init__(self, vessel : Vessel, axes : ThreeDAxes, traj: List[Tuple[float, float, float, float, float]],
 def_traj: List[Tuple[float, float, float, float, float]]) -> None:
 self.traj = def_traj
 self.real_traj = traj
 self.def_traj = def_traj
 self.axes = axes
 self.vessel = vessel
 self.traj_length = len(self.traj) - 1
 self.refresh_data(z=200)
 super().__init__(self.point, color=colors[vessel.id], radius=DEFAULT_DOT_RADIUS / 4)
 self.refresh_data()
 self.generate_target()
 self.target.move_to(self.point)
 def path_animate(self, mobject, t):
 index = int(self.traj_length * t)
 self.vessel.update(*self.traj[index])
 self.refresh_data()
 self.move_to(self.point)
 def refresh_data(self, z = 4):
 self.point = self.axes.c2p(self.vessel.p[0], self.vessel.p[1], z)
 self.down_point = self.axes.c2p(self.vessel.p[0], self.vessel.p[1], 0)
 def get_center_0z(self):
 return self.down_point
class SimVec(Arrow, Animated):
 def __init__(self, vessel : Vessel, axes : ThreeDAxes, traj: List[Tuple[float, float, float, float, float]],
 def_traj: List[Tuple[float, float, float, float, float]]) -> None:
 self.traj = def_traj
 self.real_traj = traj
 self.def_traj = def_traj
 self.axes = axes
 self.vessel = vessel
 self.traj_length = len(self.traj) - 1
 self.refresh_data(z=200)
 super().__init__(self.point, self.end, color=colors[vessel.id])
 self.refresh_data()
 self.generate_target()
 self.target.put_start_and_end_on(self.point, self.end)
 def path_animate(self, mobject, t):
 index = int(self.traj_length * t)
 self.vessel.update(*self.traj[index])
 self.refresh_data()
 self.put_start_and_end_on(self.point, self.end)
 def refresh_data(self, z = 4):
 self.point = self.axes.c2p(self.vessel.p[0], self.vessel.p[1], z)
 self.v_end = (self.vessel.p + self.vessel.v*300)
 self.end = self.axes.c2p(self.v_end[0], self.v_end[1], z)
class SimImage(SVGMobject, Animated):
 def __init__(self, vessel : Vessel, axes : ThreeDAxes, traj: List[Tuple[float, float, float, float, float]],
 def_traj: List[Tuple[float, float, float, float, float]]) -> None:
 self.traj = def_traj
 self.real_traj = traj
 self.def_traj = def_traj
 self.axes = axes
 self.vessel = vessel
 self.traj_length = len(self.traj) - 1
 self.refresh_data(z=200)
 super().__init__(f'{ASSET_FOLDER}/images/ship_white.svg', height=0.03, width=0.03)
 self.move_to(self.point)
 self.rotate(self.vessel.heading - PI / 2)
 self.angle = self.vessel.heading - PI / 2
 self.refresh_data()
 self.generate_target()
 self.target.move_to(self.point)
 def refresh_data(self, z = 0):
 self.point = self.axes.c2p(self.vessel.p[0], self.vessel.p[1], z)
 def path_animate(self, mobject, t):
 index = int(self.traj_length * t)
 self.vessel.update(*self.traj[index])
 self.refresh_data()
 self.move_to(self.point)
 self.rotate((self.vessel.heading - PI/2) - self.angle)
 self.angle = self.vessel.heading - PI / 2
class SimRadius(Circle, Animated):
 def __init__(self, vessel : Vessel, axes : ThreeDAxes, traj: List[Tuple[float, float, float, float, float]],
 def_traj: List[Tuple[float, float, float, float, float]]) -> None:
 self.traj = def_traj
 self.real_traj = traj
 self.def_traj = def_traj
 self.axes = axes
 self.vessel = vessel
 self.traj_length = len(self.traj) - 1
 self.refresh_data(z=200)
 super().__init__(radius=vessel.r / 750, color=colors[vessel.id], stroke_width=3)
 self.move_to(self.point)
 self.refresh_data()
 self.generate_target()
 self.target.move_to(self.point)
 def path_animate(self, mobject, t):
 index = int(self.traj_length * t)
 self.vessel.update(*self.traj[index])
 self.refresh_data()
 self.move_to(self.point)
 def refresh_data(self, z = 0):
 self.point = self.axes.c2p(self.vessel.p[0], self.vessel.p[1], z)
class PointsWithVectorsAndRadius(ThreeDScene):
 def construct(self):
 data_parser = EvalDataParser()
 traj_parser = TrajDataParser()
 file1 = 'C:\\Users\\domfr93\\Desktop\\USVLogicSceneGeneration/assets/gen_data/RRTStar_algo/5vessel_MSR_10/test - 2024-11-18T08-37-24.458725/2024-11-18T08-38-24.408477.json'
 file2 = file1.replace('domfr93', 'freyd')
 traj = traj_parser.load_models_from_files([file1])
 env_path1 = traj[0].logical_scenario_path
 env_path2 = env_path1.replace('domfr93', 'freyd')
 data = data_parser.load_data_models_from_files([env_path1])
 self.logical_scenario = LoadedEnvironment(eval_data=data[0])
 self.trajectories = TrajectoryReceiver(self.logical_scenario, traj[0].trajectories)
 # Set the background color to white
 axes_3d = ThreeDAxes(x_range=[-MAX_COORD, MAX_COORD*3, MAX_COORD*3 / 5],
 y_range=[-MAX_COORD, MAX_COORD*3, MAX_COORD*3 / 5],
 z_range=[0, 200, 200],
 axis_config={"decimal_number_config": {"num_decimal_places": 0}},
 x_axis_config={"numbers_to_include": [int(val) for val in np.arange(-MAX_COORD, MAX_COORD*3, MAX_COORD *3 / 5)]},
 y_axis_config={"numbers_to_include": [int(val) for val in np.arange(-MAX_COORD, MAX_COORD*3, MAX_COORD *3 / 5)]},
 tips=True,)
 labels = axes_3d.get_axis_labels(x_label=Tex("x (m)"), y_label=Tex("y (m)"))
 self.add(axes_3d, labels)
 self.move_camera(frame_center=axes_3d.c2p(MAX_COORD*0.5, MAX_COORD*1, 10), zoom=2.5)
 self.wait(1)
 self.move_camera(phi=50 * DEGREES, theta=-45 * DEGREES, run_time=2)
 graphs : List[Animated] = []
 paths1 : List[TracedPath] = []
 paths2 : List[TracedPath] = []
 # Define two points with sufficient distance
 def_trajs = self.trajectories.gen_trajectories()
 for vessel in self.logical_scenario.vessel_vars:
 traj = self.trajectories.trajectories[vessel.id]
 def_traj = def_trajs[vessel.id]
 #rad = SimRadius(vessel, axes_3d, traj, def_traj)
 dot = SimDot(vessel, axes_3d, traj, def_traj)
 graphs += [dot,
 SimVec(vessel, axes_3d, traj, def_traj),
 SimImage(vessel, axes_3d, traj, def_traj)]
 # Create a traced path for the moving object
 traced_path1 = TracedPath(
 dot.get_center_0z,
 stroke_width=2.5,
 stroke_color=light_colors[vessel.id],
 #dissipating_time=12
 )
 traced_path2 = TracedPath(
 dot.get_center_0z,
 stroke_width=2.5,
 stroke_color=light_colors[vessel.id],
 #dissipating_time=12
 )
 # Convert the traced path into a dashed path
 #dashed_path = DashedVMobject(traced_path, dashed_ratio=0.8)
 paths1 += [traced_path1]
 paths2 += [traced_path2]
 for g in graphs:
 self.add(g)
 self.wait(0.1)
 self.play(*[MoveToTarget(g) for g in graphs], rate_func=rate_functions.ease_in_quad, lag_ratio=0.2, run_time=1.2)
 self.wait(3)
 for p in paths1:
 self.add(p)
 self.play(*[UpdateFromAlphaFunc(g, g.path_animate) for g in graphs], rate_func=linear, lag_ratio=0, run_time=20)
 self.wait(2)
 for p in paths1:
 self.remove(p)
 for g in graphs:
 g.move_to(g.target)
 self.wait(2)
 for p in paths2:
 self.add(p)
 for g in graphs:
 g.traj = g.real_traj
 g.traj_length = len(g.traj) - 1
 self.play(*[UpdateFromAlphaFunc(g, g.path_animate) for g in graphs], rate_func=linear, lag_ratio=0, run_time=35)
 self.wait(2)
 for p in paths2:
 p.traced_point_func = lambda: p.points[-1]
 for g in graphs:
 g.move_to(g.target)
 self.wait(5)
</src\scripts\manim\manim_first.py>

<src\utils\asv_utils.py>
import numpy as np
BOW_ANGLE = np.radians(10.0)
STERN_ANGLE = np.radians(135)
BEAM_ANGLE = np.radians(107.5)
MASTHEAD_LIGHT_ANGLE = np.pi * 2 - STERN_ANGLE
KNOT_TO_MS_CONVERSION = 0.5144447 # 1 knot in metres per second
N_MILE_TO_M_CONVERSION = 1852.001 # 1 nautical miles in metres
DIST_DRIFT = 50.0
# 6 nautical miles = 11112,066 meters
# 5 nautical miles = 9260,005 meters
# 4 nautical miles = 7408,004 meters
# 3 nautical miles = 5556,003 meters
# 2 nautical miles = 3704,002 meters
MIN_HEADING = -np.pi
MAX_HEADING = np.pi
MIN_COORD = 0.0
MAX_COORD = 2 * 6.5 * N_MILE_TO_M_CONVERSION # 24076.013 m
MAX_DISTANCE = MAX_COORD * np.sqrt(2) # 34048.624 m
EPSILON=1e-10
MIN_LENGTH = 10
MAX_LENGTH = 400
MIN_BEAM = 2
MAX_BEAM = 80
MIN_SPEED_IN_MS = 0.2 * KNOT_TO_MS_CONVERSION
MAX_SPEED_IN_MS = 50 * KNOT_TO_MS_CONVERSION
EGO_LENGTH = 30
EGO_BEAM = 10
ONE_HOUR_IN_SEC = 60 * 60
TWO_N_MILE = 2 * N_MILE_TO_M_CONVERSION
def vessel_radius(length : float) -> float:
 return length * 4
def o2VisibilityByo1(o2RelativeBearingToo1 : float, o2_length):
 if o2RelativeBearingToo1 >= MASTHEAD_LIGHT_ANGLE / 2:
 if o2_length < 12:
 return 2
 elif o2_length < 20:
 return 2
 elif o2_length < 50:
 return 2
 else:
 return 3
 else:
 if o2_length < 12:
 return 2
 elif o2_length < 20:
 return 3
 elif o2_length < 50:
 return 5
 else:
 return 6
# FOR FUTURE WORK
# Table 1: Approximated minimum spacing for Coldwell's domain if ownship's length and beam are L1 and B1, and target's length and beam are L2 and B2, respectively.
# Encounter/Safety Condition | Own Domain Not Violated | Target's Domain Not Violated | Neither Domain is Violated | Domains Not Overlapping
# ---------------------------------------------------------------------------------------------------------------------------
# Head-on (port to a target) | 1.75L1 - 0.5B1 | 1.75L2 - 0.5B2 | 1.75L2 - 0.5B2 | 1.75L1 - 0.5B1 + 1.75L2 - 0.5B2
# Head-on (starboard to a target) | 3.25L1 - 0.5B1 | 3.25L2 - 0.5B2 | 3.25L2 - 0.5B2 | 3.25L1 - 0.5B1 + 3.25L2 - 0.5B2
# Crossing ahead of a target on starboard | 3.25L1 - 0.5B1 | 6.1L2 - 0.5L2 | 6.1L2 - 0.5L2 | 3.25L1 - 0.5B1 + 6.1L2 - 0.5L2
# Crossing astern of a target from starboard | 1.75L1 - 0.5B1 | 3.9L2 - 0.5L2 | 3.9L2 - 0.5L2 | 1.75L1 - 0.5B1 + 3.9L2 - 0.5L2
# Crossing ahead of a target on port | 1.75L1 - 0.5B1 | 6.1L2 - 0.5L2 | 6.1L2 - 0.5L2 | 1.75L1 - 0.5B1 + 6.1L2 - 0.5L2
# Crossing astern of a target from port | 3.25L1 - 0.5B1 | 3.9L2 - 0.5L2 | 3.9L2 - 0.5L2 | 3.25L1 - 0.5B1 + 3.9L2 - 0.5L2
# Overtaking (port to a target or starboard) | 1.75L1 - 0.5B1 | 1.75L2 - 0.5B2 | 1.75L2 - 0.5B2 | 1.75L1 - 0.5B1 + 1.75L2 - 0.5B2
</src\utils\asv_utils.py>

<src\utils\file_system_utils.py>
import os
ASSET_FOLDER = f'{os.path.dirname(os.path.abspath(__file__))}/../../assets'
ROOT_FOLDER = f'{os.path.dirname(os.path.abspath(__file__))}/../..'
def get_all_file_paths(directory, extension):
 if not os.path.isdir(directory):
 raise ValueError('THe path is not a directory or invalid.')
 file_paths = []
 for root, _, files in os.walk(directory):
 for file in files:
 if f'.{extension}' in file:
 file_paths.append(os.path.join(root, file))
 return file_paths
</src\utils\file_system_utils.py>

<src\utils\math_utils.py>
from typing import List
import numpy as np
def find_center_and_radius(points_array : List[np.ndarray]):
 # Calculate the center (centroid) by averaging the coordinates
 center = np.mean(points_array, axis=0)
 # Calculate the radius as the maximum distance from the center to any point
 distances = np.linalg.norm(points_array - center, axis=1)
 radius = np.max(distances)
 return center, radius
</src\utils\math_utils.py>

<src\utils\scenario.py>
from abc import ABC, abstractmethod
# Length/beam ratio (LBR) = WL/B
# (WL = waterline length; B = maximum beam at the waterline)
# LENGTH-TO-BEAM RATIO (LBR) AND SHIP CATEGORIES
#
# Ratio Description Typical Ship Types
# ------------------------------------------------------------------------------------------
# 2-4 Small to midsize planing powerboats Yachts (6-15m, 15-50 knots)
# Provides stability and spacious deck area Small fishing boats (9-15m, 10-25 knots)
# relative to length, suitable for high-speed
# recreational use.
# ------------------------------------------------------------------------------------------
# 3-4 Small to midsize sailboats, motor yachts Yachts (15-30m, 15-50 knots)
# Balances stability and speed, suitable Larger fishing boats (15-30m, 10-25 knots)
# for both sailing and powerboating.
# ------------------------------------------------------------------------------------------
# 4-6 Large, efficient long-range cruisers Ferries (30-50m, 15-30 knots)
# Designed for fuel efficiency and stability, Small cargo ships (90-150m, 12-20 knots)
# ideal for ocean passages.
# ------------------------------------------------------------------------------------------
# 6-10 Large freighters, cruising trimarans, Ferries (50-150m, 15-30 knots)
# cruising catamarans, and large Larger cargo ships (150-180m, 12-20 knots)
# sailing monohulls Icebreakers (60-180m, 10-20 knots)
# Optimized for long-distance travel, balancing
# stability and carrying capacity.
# ------------------------------------------------------------------------------------------
# 10-16 Fast-cruising catamarans, trimarans, Naval ships (variable length, 20-35+ knots)
# and racing multihulls Specialized racing boats
# High LBR for speed and agility, reducing
# drag for competitive sailing.
# ------------------------------------------------------------------------------------------
# Over 16 Racing multihulls Specialized racing multihulls
# Extreme ratios for ultimate speed, (e.g., America's Cup racers)
# lightweight, minimal beam to length for
# high performance in racing.
# ------------------------------------------------------------------------------------------
# LENGTH AND SPEED CATEGORIES
# ------------------------------------------------------------------------------------------
# Small Ships 6-30 meters 10-50 knots Yachts, fishing boats
# Medium Ships 30-180 meters 12-30 knots Ferries, small cargo ships
# Large Ships 180-460+ meters 12-25 knots Container ships, cruise ships, oil tankers
# Specialized Variable length 10-35+ knots Naval ships, icebreakers, racing multihulls
# ------------------------------------------------------------------------------------------
class Scenario(ABC):
 @property
 @abstractmethod
 def size(self) -> int:
 pass
</src\utils\scenario.py>

<src\utils\serializable.py>
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Type, Union, get_args, get_origin
def is_optional_type(attribute_type : Type):
 # Check if the class is an Optional (or Union with None)
 return get_origin(attribute_type) is Union and type(None) in get_args(attribute_type)
def get_inner_type(attribute_type : Type):
 if is_optional_type(attribute_type):
 # Extract the non-None type(s) from the Optional
 return [arg for arg in get_args(attribute_type) if arg is not type(None)][0]
 raise ValueError("Provided type is not Optional")
class Serializable(ABC):
 def to_dict(self):
 """Convert the object into a dictionary."""
 result = {}
 for key, value in self.__dict__.items():
 if isinstance(value, Serializable): # Handle nested Serializable objects
 result[key] = value.to_dict()
 else: # Handle primitive types
 result[key] = value
 return result
 # @classmethod
 # def from_dict(cls, data):
 # """Create an object from a dictionary."""
 # obj = cls.__new__(cls) # Create an instance without calling __init__
 # for key, value in data.items():
 # attr = getattr(cls, key, None)
 # if isinstance(attr, type) and issubclass(attr, Serializable): # Handle nested objects
 # setattr(obj, key, attr.from_dict(value))
 # elif isinstance(value, list): # Handle lists of Serializable objects
 # if isinstance(attr, dict):
 # else:
 # setattr(obj, key, value)
 # else:
 # setattr(obj, key, value)
 # return obj
 @classmethod
 def from_dict(cls: Type['Serializable'], data: Dict[str, Any]) -> 'Serializable':
 """
 Creates an instance of the class from a dictionary representation,
 handling nested serializable attributes, lists, and dictionaries.
 """
 obj = cls.__new__(cls)
 for attr, value in data.items():
 attr_type = cls.get_type_by_annotation(attr)
 if isinstance(attr_type, Type) and issubclass(attr_type, Serializable):
 setattr(obj, attr, attr_type.from_dict(value))
 else:
 setattr(obj, attr, value)
 return obj
 @classmethod
 def get_type_by_annotation(cls : Type['Serializable'], attribute_name) -> Type:
 annotations = cls.__annotations__
 if attribute_name not in annotations:
 raise ValueError(f"Attribute '{attribute_name}' is not annotated in the class.")
 # Get the type annotation of the attribute
 attr_type = annotations[attribute_name]
 if is_optional_type(attr_type):
 attr_type = get_inner_type(attr_type)
 return attr_type
</src\utils\serializable.py>

<src\visualization\dash_thread.py>
import pprint
from typing import List
from dash import dcc, html
import queue
import threading
import dash
from concrete_level.data_parser import EvalDataParser
from concrete_level.models.concrete_scene import ConcreteScene
from dash import dash_table, html
from dash.dependencies import Input, Output
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
class DashThread(threading.Thread):
 def __init__(self) -> None:
 super().__init__(daemon=True, name='Dash Thread')
 self.data_queue : queue.Queue[ConcreteScene] = queue.Queue()
 self.dp = EvalDataParser()
 self.dirs : List[str] = []
 self.df, self.dirs = self.dp.load_dirs_merged(self.dirs)
 hidden_columns = ['best_scene', 'path', 'risk_vector', 'error_message', 'best_fitness', 'timestamp',
 'vessel_number','aggregate_strat', 'random_seed', 'num_parents_mating', 'init_method',
 'c_1', 'c_2', 'w', 'crossover_prob', 'crossover_eta', 'mutate_prob', 'mutate_eta']
 self.app = dash.Dash(__name__)
 # Function to format cells (list or single value)
 def format_cell(value):
 if isinstance(value, list):
 return ', '.join(map(str, value)) # Comma-separated list as string
 return value
 def fetch_data():
 self.df, self.dirs = self.dp.load_dirs_merged(self.dirs)
 return self.df
 self.app.layout = html.Div([
 dcc.Interval(
 id='interval-component',
 interval=30*1000, # Interval in milliseconds (1 second, only for demo purposes)
 n_intervals=0 # Start counting at 0 on page load
 ),
 dcc.Checklist(
 id='column-checklist',
 options=[{"label": i, "value": i} for i in self.df.columns],
 value=[i for i in self.df.columns if i not in hidden_columns], # Default visible columns
 inline=True,
 style={'fontSize': '22px', 'marginRight': '20px'},
 ),
 dcc.Dropdown(
 id='page-size-dropdown',
 options=[
 {'label': str(size), 'value': size} for size in [5, 10, 20, 50, 100, 200]
 ],
 value=10, # default value
 clearable=False
 ),
 dash_table.DataTable(
 id='table',
 data=[],
 columns=[{"name": i, "id": i} for i in self.df.columns if i not in hidden_columns],
 sort_action='native', # sorting
 filter_action='native', # filtering
 row_selectable='single', # Allow selecting a single row
 page_size=10, # default page size
 page_current=0, # current page
 page_action='native', # enables pagination
 selected_rows=[],
 # Prettify Table
 style_table={'overflowY': 'auto', 'width': '100%', 'margin': '10px 10px 10px 10px'},
 style_cell={
 'textAlign': 'center',
 'padding': '8px',
 'font_family': 'Arial, sans-serif',
 'font_size': '18px',
 'backgroundColor': '#f9f9f9', # light gray background
 'border': '1px solid #ddd' # light border
 },
 style_header={
 'backgroundColor': '#4CAF50', # green header
 'fontWeight': 'bold',
 'color': 'white',
 'border': '1px solid black',
 'font_size': '20px',
 },
 style_data_conditional=[
 {
 'if': {'row_index': 'odd'},
 'backgroundColor': '#f2f2f2' # Alternate row color (light gray)
 },
 {
 'if': {'row_index': 'even'},
 'backgroundColor': '#ffffff' # White background for even rows
 },
 {
 'if': {
 'column_id': 'risk_distance',
 },
 'backgroundColor': '#e0f7fa',
 'color': '#00796b',
 'fontWeight': 'bold'
 },
 {
 'if': {
 'column_id': 'best_fitness_index',
 },
 'backgroundColor': '#e0f7fa',
 'color': '#00796b',
 'fontWeight': 'bold'
 },
 {
 'if': {
 'state': 'selected' # Styling for the selected row
 },
 'backgroundColor': '#D6EAF8',
 'color': 'black',
 'border': '1px solid blue'
 }
 ]
 ),
 html.Div(id='total-rows', style={'textAlign': 'right'}),
 html.Div(id='selected-row')
 ])
 @self.app.callback(
 Output('table', 'data'),
 Output('total-rows', 'children'),
 Input('interval-component', 'n_intervals') # Trigger on page load or at the interval
 )
 def update_data(n_intervals):
 # Fetch new data (or reload data)
 self.df = fetch_data()
 total_rows = f"Total rows: {len(self.df)}"
 return [{col: format_cell(val) for col, val in row.items()} for row in self.df.to_dict('records')], total_rows
 @self.app.callback(
 Output('table', 'columns'),
 Input('column-checklist', 'value'))
 def update_columns(selected_columns):
 # Update the DataTable columns based on the selected checklist
 return [{"name": col, "id": col} for col in selected_columns]
 @self.app.callback(
 Output('table', 'page_size'),
 Input('page-size-dropdown', 'value'))
 def update_table(page_size):
 return page_size
 # Callback to update the graph based on the selected row
 @self.app.callback(
 Output('selected-row', 'children'),
 [Input('table', 'selected_rows')] # Listen to row selection
 )
 def display_selected_row(selected_rows):
 if selected_rows:
 selected_index = selected_rows[0]
 row = self.df.iloc[selected_index]
 eval_data : EvaluationData = EvaluationData.from_dict(row)
 self.data_queue.put(eval_data.best_scene)
 return f"Selected Row:\n{pprint.pformat(dict(sorted(row.to_dict().items())))}"
 return "No row selected"
 def run(self):
 self.app.run_server(debug=False, use_reloader=False)
</src\visualization\dash_thread.py>

<src\visualization\plotting_utils.py>
from abc import ABC, abstractmethod
from collections import defaultdict
from typing import Any, Dict, List, Tuple
from matplotlib import pyplot as plt
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
class PlotBase(ABC):
 plt.rcParams['font.family'] = 'serif'
 plt.rcParams['font.serif'] = ['Times New Roman']
 plt.rcParams['font.size'] = 12
 def __init__(self):
 super().__init__()
 self.fig = self.create_fig()
 @abstractmethod
 def create_fig(self) -> plt.Figure:
 pass
class EvalPlot(PlotBase, ABC):
 config_group_map = {'sbo' : 'SB',
 'msr' : 'MSR',
 'scenic_distribution' : 'Scenic',
 'common_ocean_benchmark' : 'Common',
 'zhu_et_al' : 'Zhu',
 'base_reference' : 'BaseRef'}
 vessel_number_map = {
 2 : '2 Vessels', 3 : '3 Vessels', 4 : '4 Vessels', 5 : '5 Vessels', 6 : '6 Vessels',
 }
 algo_map = {'nsga2' : 'N2', 'nsga3' : 'N3', 'ga' : 'GA', 'de' : 'DE', 'pso' : 'PSO'}
 aggregate_map = {'all' : 'A', 'vessel' : 'V', 'category' : 'C', 'all_swarm' : 'A'}
 def __init__(self, eval_datas : List[EvaluationData], is_algo=False, is_all=False) -> None:
 self.comparison_groups : List[Any] = self.algos if is_algo else self.config_groups
 self.comparison_group_count = len(self.comparison_groups)
 self.vessel_num_count = len(self.vessel_numbers)
 self.colors = self.generate_colors(self.comparison_group_count)
 self.vessel_num_labels = [self.vessel_number_map[vn] for vn in self.vessel_numbers]
 self.group_labels = [self.algo_map[algo] + '-' + self.aggregate_map[aggregate] for algo, aggregate in self.algos] if is_algo else [self.config_group_map[cg.lower()] for cg in self.config_groups]
 self.measurements : Dict[int, Dict[str, List[EvaluationData]]] = defaultdict(lambda: defaultdict(list))
 for vessel_number in self.vessel_numbers:
 for comparison_group in self.comparison_groups:
 self.measurements[vessel_number][comparison_group] = []
 self.eval_datas = eval_datas
 for eval_data in eval_datas:
 comparison_group = (eval_data.algorithm_desc, eval_data.aggregate_strat) if is_algo else eval_data.config_group
 if (not is_all and eval_data.best_fitness_index != 0) or comparison_group not in self.comparison_groups or eval_data.vessel_number not in self.vessel_numbers:
 continue
 self.measurements[eval_data.vessel_number][comparison_group].append(eval_data)
 super().__init__()
 @property
 @abstractmethod
 def config_groups(self) -> List[str]:
 pass
 @property
 @abstractmethod
 def vessel_numbers(self) -> List[int]:
 pass
 @property
 def algos(self) -> List[Tuple[str, str]]:
 return []
 def generate_colors(self, size) -> List[np.ndarray]:
 # Convert the colors to RGB format
 color1_rgb = np.array((0, 0.5, 1))
 # if size == 1:
 # return color1_rgb
 color2_rgb = np.array((1, 0.5, 0))
 # Generate a range of colors by linear interpolation
 colors = [color1_rgb + (color2_rgb - color1_rgb) * i / (size - 1) for i in range(size)]
 return [np.array([color[0], color[1], color[2], 0.7]) for color in colors]
 def set_yticks(self, axi : plt.Axes, values):
 yticks = np.linspace(0, max(values), 6)
 yticks = [round(t) for t in yticks]
 axi.set_yticks([yticks[0], yticks[-1]] + list(yticks), minor=False)
 def init_axi(self, pos : int, axi : plt.Axes, label : str):
 axi.set_aspect('auto', adjustable='box')
 if pos == 0:
 axi.set_ylabel(label)
 axi.set_yticks([])
 axi.set_xticks([])
class DummyEvalPlot(EvalPlot):
 def __init__(self, eval_datas):
 super().__init__(eval_datas)
 def create_fig(self) -> plt.Figure:
 fig, axes = plt.subplots(1, 1, figsize=(7, 7))
 self.axi : plt.Axes = axes
 return fig
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
</src\visualization\plotting_utils.py>

<src\visualization\trajectory_visualizer.py>
from typing import List, Optional, Tuple
import numpy as np
from concrete_level.trajectory_generation.path_interpolator import PathInterpolator
from concrete_level.models.rrt_models import CircularObstacle, LineObstacle, Obstacle, PolygonalObstacle, TrajectoryState, RRTNode
import pygame
from concrete_level.models.vessel_order_graph import VesselNode
class TrajectoryVisualizer():
 def __init__(self, dim : int, scaler : float, sample_area : List[Tuple[float, float]]) -> None:
 self.scaler = scaler
 self.sample_area = sample_area
 self.dim = dim
 window_size = [dim, dim]
 pygame.init()
 self.screen = pygame.display.set_mode(window_size)
 def set_caption(self, v_node : VesselNode, interpolator : PathInterpolator):
 conf_rels = ""
 for rel in v_node.relations:
 conf_rels = str(rel) if not conf_rels else f'{conf_rels}, {str(rel)}'
 conf_trajs = ""
 for vessel in interpolator.vessels:
 conf_trajs = vessel.name if not conf_trajs else f'{conf_trajs}, {vessel.name}'
 pygame.display.set_caption(f'{conf_rels}, Conflicting trajectories: {conf_trajs}')
 def draw_obstacles(self, obstacle_list : List[Obstacle], collision_points : List[np.ndarray], min_go_around_line : LineObstacle, go_around_split_line : LineObstacle):
 for o in obstacle_list:
 if isinstance(o, LineObstacle):
 self.draw_line(o, (0,0,0), 5)
 elif isinstance(o, CircularObstacle):
 pygame.draw.circle(self.screen,(255,0,0), self.reverse_coord(o.p), o.radius * self.scaler, width=5)
 elif isinstance(o, PolygonalObstacle):
 pygame.draw.polygon(self.screen, (0,0,0), [self.reverse_coord(p) for p in o.polygon])
 self.draw_line(min_go_around_line, (255, 165, 0), 5)
 self.draw_line(go_around_split_line, (255, 165, 0), 5)
 for cp in collision_points:
 pygame.draw.circle(self.screen,(255,0,0), self.reverse_coord(cp), 3)
 def draw_line(self, line : LineObstacle, color : Tuple[int,int,int], width : int):
 start = self.reverse_coord(line.shifted_point + line.dir_vec * 2 * self.dim / self.scaler)
 end = self.reverse_coord(line.shifted_point - line.dir_vec * 2 * self.dim / self.scaler)
 pygame.draw.line(self.screen, color, start, end, width-1)
 pygame.draw.circle(self.screen,(23,231,5), self.reverse_coord(line.shifted_point), width)
 def draw_branches(self, start : RRTNode, end : RRTNode, node_list : dict[int, RRTNode], last_index : Optional[int], gen_final_course):
 pygame.draw.circle(self.screen, (0,0,255), self.reverse_coord(start.p), 7)
 pygame.draw.circle(self.screen, (0,255,255), self.reverse_coord(end.p), 7)
 # Branches
 for node in node_list.values():
 if node.parent is not None:
 pygame.draw.line(self.screen,(0,255,0), self.reverse_coord(node_list[node.parent].p), self.reverse_coord(node.p))
 for node in node_list.values():
 if len(node.children) == 0:
 pygame.draw.circle(self.screen, (255,0,255), self.reverse_coord(node.p), 2)
 # Final path
 if last_index is not None:
 path : List[RRTNode] = gen_final_course(last_index)
 ind = len(path)
 while ind > 1:
 color = (0,0,0)
 pygame.draw.line(self.screen, color, self.reverse_coord(path[ind-2].p), self.reverse_coord(path[ind-1].p), 5)
 ind-=1
 def update(self, obstacle_list : List[Obstacle], collision_points : List[np.ndarray], min_go_around_line : LineObstacle, go_around_split_line : LineObstacle,
 start : RRTNode, end : RRTNode, node_list : dict[int, RRTNode], last_index : Optional[int], gen_final_course):
 self.screen.fill((255, 255, 255))
 self.draw_obstacles(obstacle_list, collision_points, min_go_around_line, go_around_split_line)
 self.draw_branches(start, end, node_list, last_index, gen_final_course)
 pygame.display.update()
 def handle_user_input(self, end : RRTNode, obstacle_list : List[Obstacle], path_validation) -> bool:
 for e in pygame.event.get():
 if e.type == pygame.MOUSEBUTTONDOWN:
 if e.button == 1:
 coords = self.inverse_reverse_coord(np.array(e.pos))
 obstacle_list.append(CircularObstacle(coords, 3000))
 path_validation()
 elif e.button == 3:
 end.p = self.inverse_reverse_coord(np.array(e.pos))
 path_validation()
 elif e.type == pygame.KEYDOWN:
 if e.key == pygame.K_SPACE:
 return True
 elif e.key == pygame.K_ESCAPE:
 exit(0)
 return False
 def reverse_coord(self, coords: np.ndarray):
 return np.array([(coords[0] - self.sample_area[0][0]) * self.scaler + 50, self.dim - (coords[1] - self.sample_area[1][0]) * self.scaler - 50])
 def inverse_reverse_coord(self, coords: np.ndarray):
 return np.array([(coords[0] - 50) / self.scaler + self.sample_area[0][0], (self.dim - coords[1] - 50) / self.scaler + self.sample_area[1][0]])
</src\visualization\trajectory_visualizer.py>

<src\visualization\colreg_scenarios\scenario_animation.py>
from typing import List
from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.trajectories import Trajectories
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
import threading
TWO_HOURS = 2 * 60 * 60
TWO_MINUTES = 2 * 60
ANIM_REAL_TIME = TWO_HOURS * 2
ANIM_SIM_TIME = TWO_MINUTES / 4
FRAMES_PER_SEC = 25.0
REAL_TIME = 1.0 / FRAMES_PER_SEC
class ScenarioAnimation():
 def speed_up_ratio(self):
 return self.real_time_value / self.sim_time_value
 def anim_max_frames(self):
 return self.sim_time_value * FRAMES_PER_SEC
 def get_sim_time_count(self) -> str:
 sim_time = self.anim_frame_counter / FRAMES_PER_SEC
 real_time = sim_time * self.speed_up_ratio()
 return f'Simulation time: {round(sim_time)} s, Real time: {round(real_time)} s'
 def __init__(self, fig : plt.Figure,
 trajectories: Trajectories, components : List[PlotComponent]) -> None:
 self.fig = fig
 self.trajectories = trajectories
 self.components = components
 self.real_time_value = ANIM_REAL_TIME
 self.sim_time_value = ANIM_SIM_TIME
 self.trajectories = trajectories
 self.__frame_counter_lock = threading.Lock()
 self.__current_scene_lock = threading.Lock()
 self.reset_anim_frame_counter()
 self.refresh_current_scene(0)
 self.is_anim_paused = True
 self.anim = None
 self.init_anim()
 def refresh_current_scene(self, frame_index : int):
 with self.__current_scene_lock:
 self.__current_scene = self.trajectories.get_scene(frame_index)
 def increment_anim_frame_counter(self):
 with self.__frame_counter_lock:
 self.__anim_frame_counter += 1
 def reset_anim_frame_counter(self):
 with self.__frame_counter_lock:
 self.__anim_frame_counter = 0
 @property
 def anim_frame_counter(self) -> int:
 with self.__frame_counter_lock:
 return self.__anim_frame_counter
 @property
 def current_scene(self) -> ConcreteScene:
 with self.__current_scene_lock:
 return self.__current_scene
 def start(self):
 self.anim = FuncAnimation(self.fig, self.update_graphs, self.update_anim, init_func=self.init_anim, blit=True, interval=int((1 / FRAMES_PER_SEC) * 1000), cache_frame_data=False)
 def update_anim(self):
 self.init_anim()
 while self.anim_frame_counter < self.anim_max_frames():
 frame_index = int(self.anim_frame_counter * REAL_TIME * self.speed_up_ratio())
 if frame_index < self.trajectories.timespan and not self.is_anim_paused:
 self.refresh_current_scene(frame_index)
 self.increment_anim_frame_counter()
 yield self.current_scene
 def update_graphs(self, scene):
 #self.auto_scale()
 return [graph for component in self.components for graph in component.update(scene) if graph.get_visible()]
 def init_anim(self):
 self.reset_anim_frame_counter()
 self.refresh_current_scene(0)
 return [graph for component in self.components for graph in component.reset()]
 # Function to start or pause the animation
 def toggle_anim(self, event):
 if event.key == 'down':
 self.init_anim()
 self.is_anim_paused = True
 print('Animation reset')
 elif event.key == 'up':
 if self.is_anim_paused:
 if self.anim == None:
 self.start()
 self.is_anim_paused = False
 print('Animation started')
 else:
 self.is_anim_paused = True
 print('Animation paused')
 def auto_scale(self):
 for ax in self.fig.get_axes():
 # Recalculate the limits based on the current data
 ax.relim()
 # Automatically adjust xlim and ylim
 ax.autoscale_view()
</src\visualization\colreg_scenarios\scenario_animation.py>

<src\visualization\colreg_scenarios\scenario_metrics_plot.py>
from typing import List
from matplotlib import gridspec
import matplotlib.pyplot as plt
from concrete_level.models.trajectory_manager import TrajectoryManager
from evaluation.risk_evaluation import TrajectoryRiskEvaluator
from utils.asv_utils import *
from visualization.plotting_utils import PlotBase
from visualization.colreg_scenarios.plot_components.metric_components.risk_metric_component import RiskMetricComponent
from visualization.colreg_scenarios.plot_components.metric_components.proximity_metrics_component import DistanceAxesComponent, DCPAAxesComponent, TCPAAxesComponent
class ScenarioMetricsPlot(PlotBase):
 def __init__(self, trajectory_manager : TrajectoryManager):
 PlotBase.__init__(self)
 self.trajectory_manager = trajectory_manager
 self.risk_evaluator = TrajectoryRiskEvaluator(self.trajectory_manager)
 self.ref_risk_evaluator = TrajectoryRiskEvaluator(TrajectoryManager(self.trajectory_manager.concrete_scene))
 DistanceAxesComponent(self.axes[0], self.trajectory_manager.scenario, self.risk_evaluator.risk_vectors, self.ref_risk_evaluator.risk_vectors).draw()
 DCPAAxesComponent(self.axes[1], self.trajectory_manager.scenario, self.risk_evaluator.risk_vectors, self.ref_risk_evaluator.risk_vectors).draw()
 TCPAAxesComponent(self.axes[2], self.trajectory_manager.scenario, self.risk_evaluator.risk_vectors, self.ref_risk_evaluator.risk_vectors).draw()
 #RiskMetricComponent(self.axes[3], self.trajectories, self.risk_evaluator.proximity_metrics, 'Proximity index', True, self.ref_risk_evaluator.proximity_metrics).draw()
 RiskMetricComponent(self.axes[3], self.trajectory_manager.scenario, self.risk_evaluator.risk_vectors, 'DS-based index', True, self.ref_risk_evaluator.risk_vectors).draw()
 self.fig.tight_layout()
 def create_fig(self) -> plt.Figure:
 fig : plt.Figure = plt.figure(figsize=(12, 3))
 # Create a GridSpec with 2 rows and 2 columns
 gs = gridspec.GridSpec(2, 3, height_ratios=[1,1], width_ratios=[1, 1, 1])
 ax4 = fig.add_subplot(gs[0, 2])
 # Create axes for the first column (occupying both rows)
 ax1 = fig.add_subplot(gs[1, 0])
 ax2 = fig.add_subplot(gs[1, 1])
 ax3 = fig.add_subplot(gs[1, 2])
 #ax5 = self.fig.add_subplot(gs[1, 3])
 fig.subplots_adjust(wspace=0.5)
 self.axes : List[plt.Axes] = [ax1, ax2, ax3, ax4]
 return fig
</src\visualization\colreg_scenarios\scenario_metrics_plot.py>

<src\visualization\colreg_scenarios\scenario_plot.py>
from typing import List
import matplotlib.pyplot as plt
from concrete_level.models.trajectory_manager import TrajectoryManager
from utils.asv_utils import *
from logical_level.constraint_satisfaction.evolutionary_computation.aggregates import AggregateAll
from visualization.plotting_utils import PlotBase
from visualization.colreg_scenarios.plot_components.main_plot_components.drawing_component import DrawingComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.legend_component import LegendComponent
from visualization.colreg_scenarios.scenario_animation import ScenarioAnimation
from visualization.colreg_scenarios.plot_components.main_plot_components.ship_image_component import ShipImageComponent
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.prime_component import PrimeComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.centered_angle_circle_component import CenteredAngleCircleComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.ship_markings_component import ShipMarkingsComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.angle_circle_component import AngleCircleComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.distance_component import DistanceComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.vo_cone_component import VOConeComponent
from visualization.colreg_scenarios.plot_components.main_plot_components.additional_vo_cone_component import AdditionalVOConeComponent
class ScenarioPlot(PlotBase):
 def __init__(self, trajectory_manager : TrajectoryManager):
 PlotBase.__init__(self)
 self.trajectory_manager = trajectory_manager
 self.ship_markings_component = ShipMarkingsComponent(self.ax, self.trajectory_manager.scenario)
 self.drawing_component = DrawingComponent(self.fig, self.ax, self.trajectory_manager.scenario)
 self.legend_component = LegendComponent(self.ax, self.trajectory_manager.scenario)
 self.vo_cone_component = VOConeComponent(self.ax, self.trajectory_manager.scenario)
 self.add_vo_cone_component = AdditionalVOConeComponent(self.ax, self.trajectory_manager.scenario)
 self.distance_component = DistanceComponent(self.ax, self.trajectory_manager.scenario)
 self.angle_circle_component = AngleCircleComponent(self.ax, self.trajectory_manager.scenario, linewidth=1.5)
 self.centered_angle_circle_component = CenteredAngleCircleComponent(self.ax, self.trajectory_manager.scenario)
 self.prime_component = PrimeComponent(self.ax, self.trajectory_manager.scenario)
 self.ship_image_component = ShipImageComponent(self.ax, self.trajectory_manager.scenario)
 self.components : List[PlotComponent] = [
 self.ship_markings_component,
 self.drawing_component,
 self.legend_component,
 self.vo_cone_component,
 self.add_vo_cone_component,
 self.distance_component,
 self.angle_circle_component,
 self.centered_angle_circle_component,
 self.prime_component,
 self.ship_image_component
 ]
 self.draw()
 self.animation = ScenarioAnimation(self.fig, self.trajectory_manager.trajectories, self.components)
 # Connect the key press event to the toggle function
 self.fig.canvas.mpl_connect('key_press_event', lambda e: self.animation.toggle_anim(e))
 # Connect the click and move events to their handlers
 self.fig.canvas.mpl_connect('button_press_event', self.drawing_component.on_click)
 self.fig.canvas.mpl_connect('motion_notify_event', self.drawing_component.on_move)
 def create_fig(self) -> plt.Figure:
 fig, ax = plt.subplots(1, 1, gridspec_kw={'width_ratios': [1]})
 self.ax : plt.Axes = ax
 return fig
 def draw(self):
 for component in self.components:
 component.draw()
 #self.title = '\n'.join([rel.name for rel in self.functional_scenario if rel.has_os()])
 self.title = self.trajectory_manager.functional_scenario.name
 aggregate = AggregateAll(self.trajectory_manager.logical_scenario, minimize=True)
 print(aggregate.derive_penalty(individual=self.trajectory_manager.concrete_scene.individual).info)
 self.set_layout()
 def set_layout(self):
 #self.fig.tight_layout(pad=10)
 self.ax.grid(False)
 #self.ax.set_title(f'USV situation\n{self.title}')
 self.ax.set_xlabel('X Position (m)')
 self.ax.set_ylabel('Y Position (m)')
 self.ax.set_aspect('equal', adjustable='box')
 # Recalculate the limits based on the current data
 self.ax.relim()
 self.fig.tight_layout()
 # Automatically adjust xlim and ylim
 #self.ax.autoscale_view()
 # # Get current x and y limits
 # x_min, x_max = self.ax.get_xlim()
 # y_min, y_max = self.ax.get_ylim()
 # # Define a padding percentage (e.g., 5% of the range)
 # x_padding = (x_max - x_min) * 0.03
 # y_padding = (y_max - y_min) * 0.03
 # # Set new limits with padding applied
 # self.ax.set_xlim(x_min + x_padding, x_max - x_padding)
 # self.ax.set_ylim(y_min + y_padding, y_max - y_padding)
</src\visualization\colreg_scenarios\scenario_plot.py>

<src\visualization\colreg_scenarios\scenario_plot_manager.py>
from datetime import datetime
import os
import tkinter as tk
from typing import Dict, List, Optional, Tuple
from matplotlib import pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.trajectory_manager import TrajectoryManager
from utils.file_system_utils import ASSET_FOLDER
from visualization.colreg_scenarios.scenario_metrics_plot import ScenarioMetricsPlot
from visualization.colreg_scenarios.scenario_animation import ANIM_REAL_TIME, ANIM_SIM_TIME, TWO_HOURS, TWO_MINUTES
from visualization.colreg_scenarios.plot_components.plot_component import light_colors
from visualization.colreg_scenarios.scenario_plot import ScenarioPlot
class StandaloneCheckbox:
 def __init__(self, master, artists: List[plt.Artist], color, init_checked : bool, fig : Optional[plt.Figure] = None, text = ''):
 self.artists = artists
 self.text = text
 self.fig = fig
 self.value = tk.BooleanVar(master=master, value=init_checked) # BooleanVar linked to checkbox
 self.checkbox = tk.Checkbutton(
 master,
 variable=self.value, # Correctly linked variable
 onvalue=True,
 text=text,
 offvalue=False,
 command=self.on_click, # Calls show_selection when clicked
 background=color
 )
 self.checkbox.pack(side=tk.TOP, anchor='w', fill=tk.NONE)
 self.set_state(init_checked)
 def on_click(self):
 if self.fig is not None:
 self.set_state(self.value.get())
 self.fig.canvas.draw()
 def set_state(self, state : bool):
 self.value.set(state)
 for a in self.artists:
 a.set_visible(state)
class CheckboxArray:
 def __init__(self, master, text: str, fig: plt.Figure):
 self.fig = fig
 self.managed_checkboxes : List[Checkbox]= []
 self.value = tk.BooleanVar(master=master, value=False) # BooleanVar linked to checkbox
 self.checkbox = tk.Checkbutton(
 master,
 text=text,
 variable=self.value, # Correctly linked variable
 onvalue=True,
 offvalue=False,
 command=self.on_click, # Calls show_selection when clicked,
 background='grey'
 )
 self.checkbox.pack(side=tk.TOP, anchor='w')
 def add(self, cb):
 self.managed_checkboxes.append(cb)
 self.notify()
 def on_click(self):
 state = self.value.get()
 for cb in self.managed_checkboxes:
 cb.set_state(state)
 self.fig.canvas.draw()
 def notify(self):
 all_false = all(cb.value.get() == False for cb in self.managed_checkboxes)
 self.value.set(not all_false)
 self.fig.canvas.draw()
class Checkbox(StandaloneCheckbox):
 def __init__(self, master, artists: List[plt.Artist], checkbox_array : CheckboxArray, color : str, init_checked : bool):
 super().__init__(master, artists, color, init_checked)
 self.checkbox_array = checkbox_array
 self.checkbox_array.add(self)
 def on_click(self):
 self.set_state(self.value.get())
 self.checkbox_array.notify()
class ScenarioPlotManager():
 def __init__(self, trajectory_manager : TrajectoryManager):
 self.trajectory_manger = trajectory_manager
 self.colreg_plot = ScenarioPlot(trajectory_manager)
 self.metrics_plot = None
 self.root = tk.Tk()
 self.root.resizable(True, True)
 self.image_folder = f'{ASSET_FOLDER}/images/exported_plots'
 self.sim_time_update_id = None
 self.root.option_add("*Font", ("Times New Roman", 14))
 self.root.title("COLREG situation visualizer")
 # CANVAS FRAME
 self.canvas_frame = tk.Frame(master=self.root)
 self.canvas_frame.pack(fill=tk.BOTH, expand=True)
 ## PLOT FRAME
 self.plot_frame = tk.Frame(master=self.canvas_frame)
 self.plot_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 self.canvas = FigureCanvasTkAgg(self.colreg_plot.fig, master=self.plot_frame)
 self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
 # TOOLBAR FRAME
 self.toolbar_frame = tk.Frame(master=self.root, height=50)
 self.toolbar_frame.pack(side=tk.BOTTOM, fill=tk.X)
 self.toolbar_frame.pack_propagate(False)
 ## SLIDERS
 self.real_time_slider = self.create_slider('Real time:', 10, TWO_HOURS * 4, ANIM_REAL_TIME, 10, self.get_anim_real_time)
 self.sim_time_slider = self.create_slider('Sim time:', 10, TWO_MINUTES, ANIM_SIM_TIME, 10, self.get_anim_sim_time)
 ## TOOLBAR
 self.navigation_frame = tk.Frame(self.toolbar_frame)
 self.navigation_frame.pack(fill=tk.BOTH, side=tk.LEFT)
 self.navigation_toolbar = NavigationToolbar2Tk(self.canvas, self.navigation_frame)
 self.navigation_toolbar.update()
 self.navigation_toolbar.pack(fill=tk.BOTH, side=tk.LEFT)
 ## PLOT SELECTION
 self.plot_options = ["Scenario", "Metrics"]
 self.selected_plot = tk.StringVar()
 self.selected_plot.set(self.plot_options[0]) # Set the default value
 # Create the dropdown menu
 self.plot_dropdown = tk.OptionMenu(self.toolbar_frame, self.selected_plot, *self.plot_options, command=self.on_select_plot)
 self.plot_dropdown.pack(side=tk.LEFT, padx=5)
 self.to_pdf_button = tk.Button(self.toolbar_frame, text="PDF", command=self.to_pdf)
 self.to_pdf_button.pack(side=tk.LEFT, padx=5)
 ## HIDE BUTTON
 self.hide_button = tk.Button(self.toolbar_frame, text="Hide control", command=self.hide_control)
 self.hide_button.pack(side=tk.LEFT, padx=5)
 ## EXIT BUTTONS
 exit_button = tk.Button(self.toolbar_frame, text="Exit", command=self.exit_application)
 exit_button.pack(side=tk.RIGHT, padx=5)
 continue_button = tk.Button(self.toolbar_frame, text="Continue", command=self.continue_application)
 continue_button.pack(side=tk.RIGHT, padx=5)
 ## CONTROL FRAME
 self.control_frame = tk.Frame(master=self.canvas_frame, width=70)
 self.control_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=False)
 self.add_control()
 self.root.wait_window()
 def add_control(self):
 ### TIME CONTROL
 self.time_control_frame = tk.Frame(self.control_frame, background='white')
 self.time_control_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
 self.time_label = tk.Label(master=self.time_control_frame,
 text=self.colreg_plot.animation.get_sim_time_count(), background='white', width=30)
 self.time_label.pack(side=tk.TOP, anchor='w', fill=tk.NONE)
 self.update_sim_time()
 ### ACTOR INFO FRAME
 self.actor_info_frame = tk.Frame(self.control_frame, background='white')
 self.actor_info_frame.pack(side=tk.TOP, fill=tk.BOTH, pady=(10, 0), expand=True)
 #### ACTOR INFOS
 self.actor_info_columns : List[tk.Frame] = []
 col=self.create_actor_info_col('grey')
 actors_label = tk.Label(master=col, text='Attribute', background='grey')
 actors_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 for vessel in self.trajectory_manger.logical_scenario.actor_vars:
 col = self.create_actor_info_col(light_colors[vessel.id])
 actors_label = tk.Label(master=col, text=vessel.name, background=light_colors[vessel.id])
 actors_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 self.actor_info_labels = self.create_actor_info_labels()
 self.update_actor_info_labels()
 #### LEGEND CHECKBOX
 self.legend_frame = tk.Frame(self.control_frame)
 self.legend_frame.pack(side=tk.TOP, fill=tk.NONE, pady=(10, 0), expand=True)
 StandaloneCheckbox(self.legend_frame,
 self.colreg_plot.legend_component.graphs, 'white', False,
 fig = self.colreg_plot.fig, text='Legend')
 ### ACTOR CONTROL
 self.actor_control_frame = tk.Frame(self.control_frame)
 self.actor_control_frame.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 0), expand=True)
 #### ACTOR CHECKBOXES
 self.actor_control_columns : List[tk.Frame] = []
 col=self.create_actor_control_col('grey')
 actors_label = tk.Label(master=col, text='Component', background='grey')
 actors_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 for vessel in self.trajectory_manger.logical_scenario.actor_vars:
 col = self.create_actor_control_col(light_colors[vessel.id])
 actors_label = tk.Label(master=col, text=vessel.name, background=light_colors[vessel.id])
 actors_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 self.create_actor_checkbox_row([self.colreg_plot.ship_markings_component.ship_dot_graphs], 'Dot')
 self.create_actor_checkbox_row([self.colreg_plot.ship_markings_component.velocity_graphs], 'Velocity')
 self.create_actor_checkbox_row([self.colreg_plot.ship_markings_component.radius_graphs], 'Radius')
 self.create_actor_checkbox_row([self.colreg_plot.ship_image_component.ship_image_graphs], 'Image')
 self.create_actor_checkbox_row([self.colreg_plot.ship_image_component.traj_line_graphs], 'Traj')
 self.create_actor_checkbox_row(self.colreg_plot.angle_circle_component.graphs_by_vessel, 'c')
 self.create_actor_checkbox_row(self.colreg_plot.centered_angle_circle_component.graphs_by_vessel, 'C', False)
 ### COLREG CONTROL
 self.rel_control_frame = tk.Frame(self.control_frame)
 self.rel_control_frame.pack(side=tk.TOP, fill=tk.NONE, pady=(10, 0), expand=True)
 #### CORLEG CHECKBOXES
 self.rel_control_columns : List[tk.Frame] = []
 col=self.create_colreg_control_col('grey')
 rel_label = tk.Label(master=col, text='Component', background='grey')
 rel_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 self.all_actor_pairs = self.trajectory_manger.scenario.concrete_scene.all_actor_pairs
 for vessel1, vessel2 in self.all_actor_pairs:
 col = self.create_colreg_control_col(light_colors[vessel2.id])
 rel_label = tk.Label(master=col, text=
 f'{self.trajectory_manger.scenario.get_vessel_name(vessel1)}->{self.trajectory_manger.scenario.get_vessel_name(vessel2)}',
 background=light_colors[vessel2.id])
 rel_label.pack(side=tk.TOP, fill=tk.NONE, pady=(0, 5))
 self.create_relation_checkbox_row(self.colreg_plot.distance_component.graphs_by_rels, 'Dist', True)
 self.create_relation_checkbox_row(self.colreg_plot.vo_cone_component.graphs_by_rels[:1], 'VO vec', False)
 self.create_relation_checkbox_row(self.colreg_plot.vo_cone_component.graphs_by_rels[1:], 'VO cone', False)
 self.create_relation_checkbox_row(self.colreg_plot.add_vo_cone_component.graphs_by_rels, 'VO calc', False)
 self.create_relation_checkbox_row([self.colreg_plot.prime_component.p12_vec_graphs], 'P12', False)
 self.create_relation_checkbox_row([self.colreg_plot.prime_component.p21_vec_graphs], 'P21', False)
 def create_actor_checkbox_row(self, plot_components: List[Dict[ConcreteVessel, plt.Artist]], text: str, init_checked=True):
 for pc in plot_components:
 if len(self.actor_control_columns) != len(pc) + 1:
 raise Exception('data and column dimensions do not match!')
 cb_array = CheckboxArray(self.actor_control_columns[0], text, self.colreg_plot.fig)
 actor_columns = self.actor_control_columns[1:]
 for i, vessel in enumerate(self.trajectory_manger.concrete_scene.actors):
 Checkbox(actor_columns[i], [cp[vessel] for cp in plot_components], cb_array, light_colors[vessel.id], init_checked)
 def create_relation_checkbox_row(self, plot_components: List[Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Artist]], text: str, init_checked=True):
 for pc in plot_components:
 if len(self.rel_control_columns) != len(pc) + 1:
 raise Exception('data and column dimensions do not match!')
 cb_array = CheckboxArray(self.rel_control_columns[0], text, self.colreg_plot.fig)
 colreg_columns = self.rel_control_columns[1:]
 for i, (vessel1, vessel2) in enumerate(self.all_actor_pairs):
 Checkbox(colreg_columns[i], [cp[(vessel1, vessel2)] for cp in plot_components], cb_array,
 light_colors[vessel1.id], init_checked)
 def create_actor_control_col(self, color):
 col = tk.Frame(self.actor_control_frame, background=color)
 col.pack(side=tk.LEFT, fill=tk.NONE, expand=True)
 self.actor_control_columns.append(col)
 return col
 def create_actor_info_col(self, color):
 col = tk.Frame(self.actor_info_frame, background=color)
 col.pack(side=tk.LEFT, fill=tk.NONE, expand=True)
 self.actor_info_columns.append(col)
 return col
 def create_colreg_control_col(self, color):
 col = tk.Frame(self.rel_control_frame, background=color)
 col.pack(side=tk.LEFT, fill=tk.NONE, expand=True)
 self.rel_control_columns.append(col)
 return col
 def create_slider(self, label, min_val, max_val, init_val, step_value, command):
 label = tk.Label(self.toolbar_frame, text=label)
 label.pack(side=tk.LEFT)
 slider = tk.Scale(self.toolbar_frame, from_=min_val, to=max_val, orient='horizontal', resolution=step_value,
 command=command)
 slider.set(init_val)
 slider.pack(fill=tk.BOTH, side=tk.LEFT)
 return slider
 def get_anim_real_time(self, event):
 self.colreg_plot.animation.real_time_value = self.real_time_slider.get()
 def get_anim_sim_time(self, event):
 self.colreg_plot.animation.sim_time_value = self.sim_time_slider.get()
 def update_sim_time(self):
 if not self.root.winfo_exists():
 return
 # Fetch new data
 self.colreg_plot.animation.get_sim_time_count()
 self.time_label.config(text=self.colreg_plot.animation.get_sim_time_count())
 # Schedule the next update
 self.control_frame.after(1000, self.update_sim_time)
 def update_actor_info_labels(self):
 if not self.root.winfo_exists():
 return
 actor_infos = self.get_actor_infos()
 for vessel in self.trajectory_manger.logical_scenario.actor_vars:
 for i, info in enumerate(actor_infos[vessel.id]):
 self.actor_info_labels[vessel.id][i].config(text=info)
 self.control_frame.after(50, self.update_actor_info_labels)
 def exit_application(self):
 if self.root and self.root.winfo_exists():
 self.root.destroy()
 self.root.quit()
 os._exit(0)
 def continue_application(self):
 if self.root and self.root.winfo_exists():
 self.root.destroy()
 self.root.quit()
 def to_pdf(self):
 file_name = f'{self.trajectory_manger.functional_scenario.name}_{datetime.now().isoformat().replace(":","-")}'
 if not os.path.exists(self.image_folder):
 os.makedirs(self.image_folder)
 self.canvas.figure.savefig(f'{self.image_folder}/{file_name}.svg', format='svg', bbox_inches='tight', dpi=350)
 self.canvas.figure.savefig(f'{self.image_folder}/{file_name}.pdf', format='pdf', bbox_inches='tight', dpi=350)
 print('image saved')
 def on_select_plot(self, value):
 if value == 'Scenario':
 plot = self.colreg_plot
 elif value == 'Metrics':
 if self.metrics_plot is None:
 self.metrics_plot = ScenarioMetricsPlot(self.trajectory_manger)
 plot = self.metrics_plot
 else:
 raise Exception('Not implemented plot.')
 self.navigation_toolbar.destroy()
 self.canvas.get_tk_widget().destroy()
 self.canvas = FigureCanvasTkAgg(plot.fig, master=self.plot_frame)
 self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
 self.navigation_toolbar = NavigationToolbar2Tk(self.canvas, self.navigation_frame)
 self.navigation_toolbar.update()
 self.navigation_toolbar.pack(fill=tk.BOTH, side=tk.LEFT)
 def hide_control(self):
 if self.hide_button['text'] == 'Hide control':
 self.control_frame.pack_forget() # Hide the frame
 self.hide_button.config(text="Show control")
 elif self.hide_button['text'] == 'Show control':
 self.control_frame.pack(side=tk.TOP, fill=tk.NONE, pady=(10, 0), expand=True)
 self.hide_button.config(text="Hide control")
 def create_actor_info_labels(self) -> List[List[tk.Label]]:
 tk.Label(master=self.actor_info_columns[0], text='Type', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 tk.Label(master=self.actor_info_columns[0], text='Length (m)', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 tk.Label(master=self.actor_info_columns[0], text='Radius (m)', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 tk.Label(master=self.actor_info_columns[0], text='Position (m)', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 tk.Label(master=self.actor_info_columns[0], text='Heading (rad)', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 tk.Label(master=self.actor_info_columns[0], text='Speed (m/s)', background='grey').pack(side=tk.TOP, fill=tk.NONE)
 actor_infos = self.get_actor_infos()
 actor_info_labels = []
 actor_info_columns = self.actor_info_columns[1:]
 for o in self.trajectory_manger.logical_scenario.actor_vars:
 actor_info_label_list : List[tk.Label] = []
 actor_info_labels.append(actor_info_label_list)
 for info in actor_infos[o.id]:
 actor_info_label = tk.Label(master=actor_info_columns[o.id], text=info, background=light_colors[o.id], width=16)
 actor_info_label.pack(side=tk.TOP, fill=tk.NONE)
 actor_info_label_list.append(actor_info_label)
 return actor_info_labels
 def get_actor_infos(self) -> List[List[str]]:
 actor_infos : List[List[str]] = []
 for vessel, state in self.colreg_plot.animation.current_scene.sorted_items:
 actor_infos.append([f'{vessel.vessel_type}', f'{vessel.length:.2f}', f'{vessel.radius:.2f}', f'({state.x:.2f}, {state.y:.2f})', f'{state.heading:.2f}', f'{state.speed:.2f}'])
 return actor_infos
</src\visualization\colreg_scenarios\scenario_plot_manager.py>

<src\visualization\colreg_scenarios\plot_components\plot_component.py>
from typing import List
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from abc import ABC, abstractmethod
colors = ['blue', 'red', 'green', 'orange', 'purple', 'grey', 'olive']
light_colors = ['lightblue', 'salmon', 'lightgreen', 'moccasin', 'thistle', 'lightgrey', 'y']
class PlotComponent(ABC):
 def __init__(self, ax: plt.Axes, scenario: MultiLevelScenario) -> None:
 self.ax = ax
 self.scenario = scenario
 self.graphs : List[plt.Artist] = []
 self.zorder = 0
 def draw(self):
 self.do_draw()
 @abstractmethod
 def do_draw(self):
 pass
 def update(self, scene : ConcreteScene) -> List[plt.Artist]:
 return self.do_update(scene)
 @abstractmethod
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 pass
 def reset(self) -> List[plt.Artist]:
 return self.update(self.scenario.concrete_scene)
</src\visualization\colreg_scenarios\plot_components\plot_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\additional_vo_cone_component.py>
from typing import Dict, List, Tuple
from matplotlib import pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
class AdditionalVOConeComponent(PlotComponent):
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.circle_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Circle] = {}
 self.line1_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.line2_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.graphs_by_rels = [self.circle_graphs, self.line1_graphs, self.line2_graphs]
 self.zorder = -2
 def do_draw(self):
 eval_cache = EvaluationCache(self.scenario.concrete_scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 vo_circle = plt.Circle(props.val2.p, props.safety_dist, color='black', fill=False, linestyle='--', linewidth=0.7, zorder=self.zorder)
 self.ax.add_artist(vo_circle)
 self.circle_graphs[key] = vo_circle
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 sin_half_cone_theta = np.clip(props.safety_dist / props.o_distance, -1, 1)
 angle_half_cone = abs(np.arcsin(sin_half_cone_theta)) # [0, pi/2]
 angle1 = angle_rel + angle_half_cone
 angle2 = angle_rel - angle_half_cone
 # Plot the velocity obstacle cone
 cone1 = props.val1.p + np.array([np.cos(angle1), np.sin(angle1)]) * props.o_distance
 cone2 = props.val1.p + np.array([np.cos(angle2), np.sin(angle2)]) * props.o_distance
 line1, = self.ax.plot([props.val1.x, cone1[0]], [props.val1.y, cone1[1]], 'k--', linewidth=0.7, zorder=self.zorder)
 self.line1_graphs[key] = line1
 line2, = self.ax.plot([props.val1.x, cone2[0]], [props.val1.y, cone2[1]], 'k--', linewidth=0.7, zorder=self.zorder)
 self.line2_graphs[key] = line2
 self.graphs += [vo_circle, line1, line2]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 eval_cache = EvaluationCache(scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 self.circle_graphs[key].set_center(props.val2.p)
 self.circle_graphs[key].set_radius(props.safety_dist)
 # Calculate the angles of the cone
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 sin_half_cone_theta = np.clip(props.safety_dist / props.o_distance, -1, 1)
 angle_half_cone = abs(np.arcsin(sin_half_cone_theta)) # [0, pi/2]
 angle1 = angle_rel + angle_half_cone
 angle2 = angle_rel - angle_half_cone
 # Plot the velocity obstacle cone
 cone1 = props.val1.p + np.array([np.cos(angle1), np.sin(angle1)]) * props.o_distance
 cone2 = props.val1.p + np.array([np.cos(angle2), np.sin(angle2)]) * props.o_distance
 self.line1_graphs[key].set_data([props.val1.x, cone1[0]], [props.val1.y, cone1[1]])
 self.line2_graphs[key].set_data([props.val1.x, cone2[0]], [props.val1.y, cone2[1]])
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\additional_vo_cone_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\angle_circle_component.py>
from typing import Dict, List
from matplotlib import pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from concrete_level.models.vessel_state import VesselState
from utils.asv_utils import BOW_ANGLE, MAX_COORD, STERN_ANGLE
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, light_colors
class AngleCircleComponent(PlotComponent):
 # Define the angle and radius
 angle_circle_slice_1 = BOW_ANGLE # 20 degree slice
 angle_circle_slice_2 = STERN_ANGLE # 140 degree slice
 def __init__(self, ax: plt.Axes, scenario : MultiLevelScenario, linewidth=0.8, radius_ratio = 10) -> None:
 super().__init__(ax, scenario)
 self.circle_graphs : Dict[ConcreteVessel, plt.Circle] = {}
 self.line1_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.line2_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.line3_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.line4_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.graphs_by_vessel = [self.circle_graphs, self.line1_graphs, self.line2_graphs, self.line3_graphs, self.line4_graphs]
 self.zorder = -20
 self.linewidth = linewidth
 self.angle_circle_radius = MAX_COORD / radius_ratio
 def do_draw(self):
 for vessel, state in self.scenario.concrete_scene.items():
 self.one_draw(vessel, state, self.zorder, light_colors[vessel.id])
 def one_draw(self, vessel : ConcreteVessel, state : VesselState, zorder : int, circle_color):
 # Draw two lines centered on the vector
 circle_line1 = self.draw_line(state.p, state.v_norm, -self.angle_circle_slice_1 / 2, circle_color, self.angle_circle_radius, zorder) # Left line
 self.line1_graphs[vessel] = circle_line1
 circle_line2 = self.draw_line(state.p, state.v_norm, self.angle_circle_slice_1 / 2, circle_color, self.angle_circle_radius, zorder) # Right line
 self.line2_graphs[vessel] = circle_line2
 # Draw two lines centered on the negated vector
 circle_line3 = self.draw_line(state.p, -state.v_norm, -self.angle_circle_slice_2 / 2, circle_color, self.angle_circle_radius, zorder) # Left line
 self.line3_graphs[vessel] = circle_line3
 circle_line4 = self.draw_line(state.p, -state.v_norm, self.angle_circle_slice_2 / 2, circle_color, self.angle_circle_radius, zorder) # Right line
 self.line4_graphs[vessel] = circle_line4
 # # Plot vectors for better visibility
 # v1_scaled = state.v_norm * MAX_COORD / 11
 # big_quiver = self.ax.quiver(state.x, state.y, v1_scaled[0], v1_scaled[1], angles='xy', scale_units='xy', scale=1,
 # color=light_colors[vessel.id], zorder=zorder)
 #self.graphs += [circle, circle_line1, circle_line2, circle_line3, circle_line4, big_quiver]
 circle = plt.Circle(state.p, self.angle_circle_radius, fill=False, color=circle_color, linewidth=self.linewidth, zorder=zorder)
 self.ax.add_artist(circle)
 self.circle_graphs[vessel] = circle
 self.graphs += [circle, circle_line1, circle_line2, circle_line3, circle_line4]
 # Function to draw lines for slices
 def draw_line(self, origin, center_vector, angle, color, length, zorder):
 x, y = self.get_line_x_y(origin, center_vector, angle, length)
 line, = self.ax.plot(x, y, color=color, linewidth=self.linewidth, zorder=zorder)
 return line
 def get_line_x_y(self, origin, center_vector, angle, length):
 direction = np.array([np.cos(angle), np.sin(angle)])
 rotation_matrix = np.array([[center_vector[0], -center_vector[1]],
 [center_vector[1], center_vector[0]]])
 rotated_direction = rotation_matrix.dot(direction)
 end_point = origin + length * rotated_direction
 return [origin[0], end_point[0]], [origin[1], end_point[1]]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 for vessel, state in scene.items():
 self.update_one(vessel, state)
 return self.graphs
 def update_one(self, vessel : ConcreteVessel, state : VesselState):
 self.circle_graphs[vessel].set_center(state.p)
 self.circle_graphs[vessel].set_radius(self.angle_circle_radius)
 x1, y1 = self.get_line_x_y(state.p, state.v_norm, -self.angle_circle_slice_1 / 2, self.angle_circle_radius)
 self.line1_graphs[vessel].set_data(x1, y1)
 x2, y2 = self.get_line_x_y(state.p, state.v_norm, self.angle_circle_slice_1 / 2, self.angle_circle_radius)
 self.line2_graphs[vessel].set_data(x2, y2)
 x3, y3 = self.get_line_x_y(state.p, -state.v_norm, -self.angle_circle_slice_2 / 2, self.angle_circle_radius)
 self.line3_graphs[vessel].set_data(x3, y3)
 x4, y4 = self.get_line_x_y(state.p, -state.v_norm, self.angle_circle_slice_2 / 2, self.angle_circle_radius)
 self.line4_graphs[vessel].set_data(x4, y4)
</src\visualization\colreg_scenarios\plot_components\main_plot_components\angle_circle_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\centered_angle_circle_component.py>
from typing import Dict, List
from matplotlib import patches, pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from utils.asv_utils import BOW_ANGLE, MASTHEAD_LIGHT_ANGLE
from visualization.colreg_scenarios.plot_components.main_plot_components.angle_circle_component import AngleCircleComponent
class CenteredAngleCircleComponent(AngleCircleComponent):
 radius_ratio = 1.7
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario, linewidth=2.0, radius_ratio = self.radius_ratio)
 self.wedge_sterns : Dict[ConcreteVessel, patches.Wedge] = {}
 self.wedge_bows : Dict[ConcreteVessel, patches.Wedge] = {}
 self.wedge_mastheads : Dict[ConcreteVessel, patches.Wedge] = {}
 self.graphs_by_vessel += [self.wedge_sterns, self.wedge_bows, self.wedge_mastheads]
 def do_draw(self):
 for vessel, state in self.scenario.concrete_scene.items():
 angle1_masthead = np.degrees(state.heading + MASTHEAD_LIGHT_ANGLE / 2)
 angle2_masthead = np.degrees(state.heading - MASTHEAD_LIGHT_ANGLE / 2)
 angle1_bow = np.degrees(state.heading + BOW_ANGLE / 2)
 angle2_bow = np.degrees(state.heading - BOW_ANGLE / 2)
 # Create the wedge (filled circle slice)
 wedge_stern = patches.Wedge(state.p,
 self.angle_circle_radius,
 angle1_masthead, angle2_masthead,
 color='lightskyblue',
 alpha=0.3, zorder=self.zorder)
 self.ax.add_patch(wedge_stern)
 self.wedge_sterns[vessel] = wedge_stern
 wedge_bow = patches.Wedge(state.p,
 self.angle_circle_radius,
 angle2_bow, angle1_bow,
 color='hotpink',
 alpha=0.3, zorder=self.zorder)
 self.ax.add_patch(wedge_bow)
 self.wedge_bows[vessel] = wedge_bow
 wedge_masthead = patches.Wedge(state.p,
 self.angle_circle_radius,
 angle2_masthead, angle1_masthead,
 color='sandybrown',
 alpha=0.3, zorder=self.zorder)
 self.ax.add_patch(wedge_masthead)
 self.wedge_mastheads[vessel] = wedge_masthead
 self.graphs += [wedge_stern, wedge_masthead, wedge_bow]
 super().do_draw()
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 for vessel, state in scene.items():
 angle1_masthead = np.degrees(state.heading + MASTHEAD_LIGHT_ANGLE / 2)
 angle2_masthead = np.degrees(state.heading - MASTHEAD_LIGHT_ANGLE / 2)
 angle1_bow = np.degrees(state.heading + BOW_ANGLE / 2)
 angle2_bow = np.degrees(state.heading - BOW_ANGLE / 2)
 self.wedge_sterns[vessel].set_center(state.p)
 self.wedge_sterns[vessel].set_radius(self.angle_circle_radius)
 self.wedge_sterns[vessel].set_theta1(angle1_masthead)
 self.wedge_sterns[vessel].set_theta2(angle2_masthead)
 self.wedge_bows[vessel].set_center(state.p)
 self.wedge_bows[vessel].set_radius(self.angle_circle_radius)
 self.wedge_bows[vessel].set_theta1(angle2_bow)
 self.wedge_bows[vessel].set_theta2(angle1_bow)
 self.wedge_mastheads[vessel].set_center(state.p)
 self.wedge_mastheads[vessel].set_radius(self.angle_circle_radius)
 self.wedge_mastheads[vessel].set_theta1(angle2_masthead)
 self.wedge_mastheads[vessel].set_theta2(angle1_masthead)
 super().do_update(scene)
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\centered_angle_circle_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\distance_component.py>
from typing import Dict, List, Tuple
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
from utils.asv_utils import N_MILE_TO_M_CONVERSION
class DistanceComponent(PlotComponent):
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.text_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Text] = {}
 self.line_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.graphs_by_rels = [self.text_graphs, self.line_graphs]
 self.zorder = -3
 def do_draw(self):
 eval_cache = EvaluationCache(self.scenario.concrete_scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 text_str = f'{props.o_distance / N_MILE_TO_M_CONVERSION:.1f} NM'
 text = self.ax.text(props.val1.p[0] + props.p12[0] / 2, props.val1.p[1] + props.p12[1] / 2, text_str, fontsize=10, color='black', zorder=self.zorder + 10)
 self.text_graphs[key] = text
 line, = self.ax.plot([props.val1.x, props.val2.x], [props.val1.y, props.val2.y], color='black', linewidth=0.8, zorder=self.zorder)
 self.line_graphs[key] = line
 self.graphs += [text, line]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 eval_cache = EvaluationCache(scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 self.text_graphs[key].set_position((props.val1.p[0] + props.p12[0] / 2, props.val1.p[1] + props.p12[1] / 2))
 text_str = f'{props.o_distance / N_MILE_TO_M_CONVERSION:.1f} NM'
 self.text_graphs[key].set_text(text_str)
 self.line_graphs[key].set_data([props.val1.x, props.val2.x], [props.val1.y, props.val2.y])
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\distance_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\drawing_component.py>
from typing import List
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
class DrawingComponent(PlotComponent):
 def __init__(self, fig : plt.Figure, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.fig = fig
 self.draw_x : List[List[float]] = []
 self.draw_y : List[List[float]] = []
 def do_draw(self):
 pass
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 return self.graphs
 # Function to handle mouse clicks
 def on_click(self, event):
 if self.fig.canvas.toolbar.mode:
 return
 if event.button == 1: # Left mouse button
 self.draw_x.append([event.xdata])
 self.draw_y.append([event.ydata])
 (line, ) = self.ax.plot(self.draw_x[-1], self.draw_y[-1], 'g:', lw=2)
 self.graphs.append(line) # Draw a line connecting the points
 self.fig.canvas.draw()
 if event.button == 3:
 if len(self.graphs) == 0:
 return
 self.draw_x = self.draw_x[:-1]
 self.draw_y = self.draw_y[:-1]
 self.graphs[-1].remove()
 self.graphs = self.graphs[:-1]
 self.fig.canvas.draw()
 # Function to handle mouse movements
 def on_move(self, event):
 if self.fig.canvas.toolbar.mode:
 return
 if event.button == 1 and event.xdata is not None and event.ydata is not None:
 self.draw_x[-1].append(event.xdata)
 self.draw_y[-1].append(event.ydata)
 self.graphs[-1].set_data(self.draw_x[-1], self.draw_y[-1])
 self.fig.canvas.draw()
</src\visualization\colreg_scenarios\plot_components\main_plot_components\drawing_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\legend_component.py>
from typing import List
from matplotlib import pyplot as plt
from matplotlib.legend import Legend
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from utils.asv_utils import KNOT_TO_MS_CONVERSION
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
class LegendComponent(PlotComponent):
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.zorder = 0
 def do_draw(self):
 self.legend : Legend = self.ax.legend()
 self.graphs += [self.legend]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 for i, (vessel, state) in enumerate(scene.items()):
 # Plot the positions
 dot_label = f'{vessel}\; p: ({state.p[0]:.1f}, {state.p[1]:.1f}), r: {vessel.radius:.1f} m'
 angle = f'h: {np.degrees(state.heading):.1f}^\circ'
 speed = f'sp: {(state.speed / KNOT_TO_MS_CONVERSION):.1f} kn'
 velocity_label =f'{vessel}\; {angle}, {speed}'
 self.legend.get_texts()[i * 2 + 0].set_text(rf'${dot_label}$')
 self.legend.get_texts()[i * 2 + 1].set_text(rf'${velocity_label}$')
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\legend_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\prime_component.py>
from typing import Dict, List, Tuple
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent
class PrimeComponent(PlotComponent):
 def __init__(self, ax: plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.p12_vec_graphs: Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Quiver] = {}
 self.p21_vec_graphs: Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Quiver] = {}
 self.zorder = -15
 def do_draw(self):
 eval_cache = EvaluationCache(self.scenario.concrete_scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 p12_scaled = props.p12 * 0.95
 p12_vec = self.ax.quiver(props.val1.x, props.val1.y, p12_scaled[0], p12_scaled[1],
 angles='xy', scale_units='xy', scale=1, color='black', zorder=self.zorder,
 width=0.006)
 self.p12_vec_graphs[key] = p12_vec
 p21_scaled = props.p21 * 0.95
 p21_vec = self.ax.quiver(props.val2.x, props.val2.y, p21_scaled[0], p21_scaled[1],
 angles='xy', scale_units='xy', scale=1, color='black', zorder=self.zorder,
 width=0.006)
 self.p21_vec_graphs[key] = p21_vec
 self.graphs += [p12_vec, p21_vec]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 eval_cache = EvaluationCache(scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 p12_scaled = props.p12 * 0.95
 self.p12_vec_graphs[key].set_offsets(props.val1.p)
 self.p12_vec_graphs[key].set_UVC(p12_scaled[0], p12_scaled[1])
 p21_scaled = props.p21 * 0.95
 self.p21_vec_graphs[key].set_offsets(props.val2.p)
 self.p21_vec_graphs[key].set_UVC(p21_scaled[0], p21_scaled[1])
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\prime_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\ship_image_component.py>
from typing import Dict, List
from matplotlib import pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from utils.asv_utils import MAX_LENGTH
from utils.file_system_utils import ASSET_FOLDER
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, light_colors
from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)
from scipy.ndimage import rotate
import matplotlib.image as mpimg
class ShipImageComponent(PlotComponent):
 img_dir = f'{ASSET_FOLDER}/images'
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.image = mpimg.imread(f'{self.img_dir}/ship2.png')
 self.ship_image_graphs : Dict[ConcreteVessel, AnnotationBbox] = {}
 self.ship_offset_images : Dict[ConcreteVessel, OffsetImage] = {}
 self.traj_line_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.xs : Dict[ConcreteVessel, List[float]] = {vessel : [] for vessel in scenario.concrete_scene.actors}
 self.ys : Dict[ConcreteVessel, List[float]] = {vessel : [] for vessel in scenario.concrete_scene.actors}
 self.zorder = -4
 def do_draw(self):
 for vessel, state in self.scenario.concrete_scene.items():
 zoom = 0.32 + vessel.length / MAX_LENGTH / 10
 (line,) = self.ax.plot(self.xs[vessel], self.ys[vessel], ':', lw=3, color=light_colors[vessel.id], zorder=self.zorder-10)
 self.traj_line_graphs[vessel] = line
 # Rotate and plot image
 rotated_image = np.clip(rotate(self.image, np.degrees(state.heading)-90, reshape=True), 0, 1)
 image_box = OffsetImage(rotated_image, zoom = zoom, alpha=1)
 ab = AnnotationBbox(image_box, state.p, xybox= state.p, xycoords='data', frameon = False, zorder=self.zorder)
 self.ax.add_artist(ab)
 self.ship_image_graphs[vessel] = ab
 self.ship_offset_images[vessel] = image_box
 self.graphs += [line, ab]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 for vessel, state in scene.items():
 xs = self.xs[vessel]
 ys = self.ys[vessel]
 if state.x not in xs or state.y not in ys:
 xs.append(state.x)
 ys.append(state.y)
 self.traj_line_graphs[vessel].set_data(xs, ys)
 rotated_image = np.clip(rotate(self.image, np.degrees(state.heading)-90, reshape=True), 0, 1)
 self.ship_offset_images[vessel].set_data(rotated_image)
 self.ship_image_graphs[vessel].xybox = (state.x, state.y)
 self.ship_image_graphs[vessel].xy = (state.x, state.y)
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\ship_image_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\ship_markings_component.py>
from typing import Dict, List
from matplotlib import pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from utils.asv_utils import KNOT_TO_MS_CONVERSION
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, colors
class ShipMarkingsComponent(PlotComponent):
 STATIC_ZOOM = 100
 DYNAMIC_ZOOM = 50
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.radius_graphs : Dict[ConcreteVessel, plt.Circle] = {}
 self.velocity_graphs : Dict[ConcreteVessel, plt.Quiver] = {}
 self.ship_dot_graphs : Dict[ConcreteVessel, plt.PathCollection] = {}
 self.zorder = 0
 def do_draw(self):
 for vessel, state in self.scenario.concrete_scene.items():
 #Plot the positions and radius as circles
 radius_circle = plt.Circle(state.p, vessel.radius, color=colors[vessel.id], fill=False, linestyle='--', zorder=self.zorder)
 self.ax.add_artist(radius_circle)
 self.radius_graphs[vessel] = radius_circle
 # Plot the positions
 dot_label = f'{vessel}\; p: ({state.p[0]:.1f}, {state.p[1]:.1f}), r: {vessel.radius:.1f} m'
 ship_dot = self.ax.scatter(state.p[0], state.p[1], color=colors[vessel.id], s=self.DYNAMIC_ZOOM, label=rf'${dot_label}$', zorder=self.zorder)
 self.ship_dot_graphs[vessel] = ship_dot
 angle = f'h: {np.degrees(state.heading):.1f}^\circ'
 speed = f'sp: {(state.speed / KNOT_TO_MS_CONVERSION):.1f} kn'
 velocity_label = f'{vessel}\; {angle}, {speed}'
 # Plot the velocity vector with their actual lengths
 ship_vel = self.ax.quiver(state.p[0], state.p[1], state.v[0], state.v[1], angles='xy', scale_units='xy', scale=1, color=colors[vessel.id], label=rf'${velocity_label}$', zorder=self.zorder-10)
 self.velocity_graphs[vessel] = ship_vel
 self.graphs += [radius_circle, ship_vel, ship_dot]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 for vessel, state in scene.items():
 self.radius_graphs[vessel].set_center(state.p)
 self.radius_graphs[vessel].set_radius(vessel.radius)
 self.ship_dot_graphs[vessel].set_offsets([state.p])
 self.velocity_graphs[vessel].set_offsets(state.p)
 self.velocity_graphs[vessel].set_UVC(state.v[0], state.v[1])
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\ship_markings_component.py>

<src\visualization\colreg_scenarios\plot_components\main_plot_components\vo_cone_component.py>
from typing import Dict, List, Tuple
from matplotlib import pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from logical_level.constraint_satisfaction.evaluation_cache import EvaluationCache
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, colors
class VOConeComponent(PlotComponent):
 def __init__(self, ax : plt.Axes, scenario : MultiLevelScenario) -> None:
 super().__init__(ax, scenario)
 self.other_velocity_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Quiver] = {}
 self.line1_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.line2_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.filling_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Polygon] = {}
 self.graphs_by_rels = [self.other_velocity_graphs, self.line1_graphs, self.line2_graphs, self.filling_graphs]
 self.zorder = -1
 def do_draw(self):
 eval_cache = EvaluationCache(self.scenario.concrete_scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.scenario.concrete_scene.all_actor_pairs:
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 sin_half_cone_theta = np.clip(props.safety_dist / props.o_distance, -1, 1)
 angle_half_cone = abs(np.arcsin(sin_half_cone_theta)) # [0, pi/2]
 angle1 = angle_rel + angle_half_cone
 angle2 = angle_rel - angle_half_cone
 cone_size = max(props.o_distance / 2, (props.val1.sp + props.val2.sp) * 1.2)
 cone1 = props.val2.v + props.val1.p + np.array([np.cos(angle1), np.sin(angle1)]) * cone_size
 cone2 = props.val2.v + props.val1.p + np.array([np.cos(angle2), np.sin(angle2)]) * cone_size
 line1, = self.ax.plot([props.val2.v[0] + props.val1.x, cone1[0]], [props.val2.v[1] + props.val1.y, cone1[1]], '--', color=colors[vessel2.id], linewidth=0.7, zorder=self.zorder)
 line2, = self.ax.plot([props.val2.v[0] + props.val1.x, cone2[0]], [props.val2.v[1] + props.val1.y, cone2[1]], '--', color=colors[vessel2.id], linewidth=0.7, zorder=self.zorder)
 self.line1_graphs[key] = line1
 self.line2_graphs[key] = line2
 # Move the other vessels velocity vector in the o1 position to see if the vector is in the VO cone
 other_velocity = self.ax.quiver(props.val1.x, props.val1.y, props.val2.v[0], props.val2.v[1], angles='xy', scale_units='xy', scale=1, color=colors[vessel2.id], zorder=self.zorder-10)
 self.other_velocity_graphs[key] = other_velocity
 # Fill the cone with a semi-transparent color
 filling = self.ax.fill([props.val2.v[0] + props.val1.x, cone1[0], cone2[0]],
 [props.val2.v[1] + props.val1.y, cone1[1], cone2[1]],
 color=colors[vessel2.id], alpha=0.15, zorder=self.zorder)
 self.filling_graphs[key] = filling[0]
 self.graphs += [line1, line2, other_velocity, filling[0]]
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 eval_cache = EvaluationCache(scene.assignments(self.scenario.logical_scenario.actor_vars))
 for vessel1, vessel2 in self.other_velocity_graphs.keys():
 var1, var2 = self.scenario.to_variable(vessel1), self.scenario.to_variable(vessel2)
 key = (vessel1, vessel2)
 props = eval_cache.get_props(var1, var2)
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 # Calculate the angles of the cone
 angle_rel = np.arctan2(props.p12[1], props.p12[0])
 sin_half_cone_theta = np.clip(props.safety_dist / props.o_distance, -1, 1)
 angle_half_cone = abs(np.arcsin(sin_half_cone_theta)) # [0, pi/2]
 angle1 = angle_rel + angle_half_cone
 angle2 = angle_rel - angle_half_cone
 cone_size = max(props.o_distance / 2, (props.val1.sp + props.val2.sp) * 1.2)
 cone1 = props.val2.v + props.val1.p + np.array([np.cos(angle1), np.sin(angle1)]) * cone_size
 cone2 = props.val2.v + props.val1.p + np.array([np.cos(angle2), np.sin(angle2)]) * cone_size
 self.line1_graphs[key].set_data([props.val2.v[0] + props.val1.x, cone1[0]], [props.val2.v[1] + props.val1.y, cone1[1]])
 self.line2_graphs[key].set_data([props.val2.v[0] + props.val1.x, cone2[0]], [props.val2.v[1] + props.val1.y, cone2[1]])
 self.other_velocity_graphs[key].set_offsets(props.val1.p)
 self.other_velocity_graphs[key].set_UVC(props.val2.v[0], props.val2.v[1])
 polx = [props.val2.v[0] + props.val1.x, cone1[0], cone2[0]]
 poly = [props.val2.v[1] + props.val1.y, cone1[1], cone2[1]]
 self.filling_graphs[key].set_xy(np.array([polx, poly]).T)
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\main_plot_components\vo_cone_component.py>

<src\visualization\colreg_scenarios\plot_components\metric_components\proximity_metrics_component.py>
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from evaluation.risk_evaluation import ProximityVector, RiskVector
from utils.asv_utils import N_MILE_TO_M_CONVERSION
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, colors, light_colors
class ProximityMetricComponent(PlotComponent, ABC):
 time_treshold = 10 * 60
 dist_treshold = 1 * N_MILE_TO_M_CONVERSION
 def __init__(self, ax : plt.Axes, scenario: MultiLevelScenario, risk_vectors : List[RiskVector], ref_risk_vectors : Optional[List[RiskVector]] = None) -> None:
 super().__init__(ax, scenario)
 self.risk_vectors = risk_vectors
 self. ref_risk_vectors = ref_risk_vectors
 self.line_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.reference_line_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.threshold_graphs : Dict[Tuple[ConcreteVessel, ConcreteVessel], plt.Line2D] = {}
 self.ax = ax
 self.length = len(self.risk_vectors)
 #self.ax.set_title(self.get_title())
 self.ax.set_xlabel('Time (s)')
 self.ax.set_ylabel(rf'{self.get_metric_str()}')
 self.ax.set_aspect('auto', adjustable='box')
 @abstractmethod
 def get_y_metric(self, proximity_vector : ProximityVector) -> float:
 pass
 @abstractmethod
 def get_metric_str(self) -> str:
 pass
 @abstractmethod
 def get_threshold_y(self, proximity_vector : ProximityVector) -> float:
 pass
 @abstractmethod
 def get_threshold2_y(self) -> float:
 pass
 @abstractmethod
 def get_threshold2_label(self) -> str:
 pass
 @abstractmethod
 def get_y_lim(self) -> Tuple[float, float]:
 pass
 @abstractmethod
 def get_title(self) -> str:
 pass
 def do_draw(self):
 x = range(0, self.length)
 for vessel1, vessel2 in self.scenario.os_non_os_pairs:
 if self.length == 0:
 break
 if self.ref_risk_vectors is not None:
 y = [self.get_y_metric(rv.proximity_vectors[(vessel1, vessel2)]) for rv in self.ref_risk_vectors if (vessel1, vessel2) in rv.proximity_vectors]
 line, = self.ax.plot(x, y, color=light_colors[vessel2.id], linewidth=2, linestyle=':')
 self.reference_line_graphs[(vessel1, vessel2)] = line
 self.graphs += [line]
 threshold_y = [self.get_threshold_y(self.risk_vectors[0].proximity_vectors[(vessel1, vessel2)])] * self.length
 y = [self.get_y_metric(rv.proximity_vectors[(vessel1, vessel2)]) for rv in self.risk_vectors if (vessel1, vessel2) in rv.proximity_vectors]
 line, = self.ax.plot(x, y, color=colors[vessel2.id],
 linewidth=1.7, label=fr'${self.scenario.get_vessel_name(vessel1)} \rightarrow {self.scenario.get_vessel_name(vessel2)}$', linestyle='-')
 #threshold, = self.ax.plot(x, threshold_y, color=light_colors[vessel2.id], linewidth=1, linestyle='--')
 self.line_graphs[(vessel1, vessel2)] = line
 #self.threshold_graphs[(vessel1, vessel2)] = threshold
 self.graphs += [line]
 threshold2, = self.ax.plot(x, [self.get_threshold2_y()] * self.length, color='black', linewidth=1.5, linestyle='--')
 threshold2, = self.ax.plot(x, [0] * self.length, color='black', linewidth=1.5, linestyle='--')
 self.threshold_graphs['basic'] = threshold2
 self.graphs += [threshold2]
 self.ax.margins(x=0.2, y=0.2)
 self.ax.set_xlim(0, self.length)
 self.ax.set_ylim(*self.get_y_lim())
 self.ax.legend()
 ymin, ymax = self.ax.get_ylim()
 offset = (ymax - ymin) * 0.03 # 5% of the y-axis range
 self.ax.text(self.length / 2, self.get_threshold2_y() + offset, self.get_threshold2_label(), ha='center', va='center', fontsize=11, horizontalalignment='center')
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 return self.graphs
class DistanceAxesComponent(ProximityMetricComponent):
 def __init__(self, ax : plt.Axes, scenario: MultiLevelScenario, risk_vectors : List[RiskVector], ref_risk_vectors : Optional[List[RiskVector]] = None) -> None:
 super().__init__(ax, scenario, risk_vectors, ref_risk_vectors)
 def get_y_metric(self, proximity_vector : ProximityVector) -> float:
 return proximity_vector.dist
 def get_metric_str(self) -> str:
 return 'Distance (m)'
 def get_title(self) -> str:
 return 'Distance'
 def get_y_lim(self) -> Tuple[float, float]:
 dist = max(self.risk_vectors[0].proximity_vectors.values(), key=lambda pv: pv.dist).dist
 return -0.1, max(dist*2, self.get_threshold2_y()*1.1)
 def get_threshold_y(self, proximity_vector : ProximityVector) -> float:
 return proximity_vector.props.safety_dist
 def get_threshold2_y(self) -> float:
 return self.dist_treshold
 def get_threshold2_label(self) -> str:
 return f'{(self.dist_treshold / N_MILE_TO_M_CONVERSION):.0f} NM'
class DCPAAxesComponent(ProximityMetricComponent):
 def __init__(self, ax : plt.Axes, scenario: MultiLevelScenario, risk_vectors : List[RiskVector], ref_risk_vectors : Optional[List[RiskVector]] = None) -> None:
 super().__init__(ax, scenario, risk_vectors, ref_risk_vectors)
 def get_y_metric(self, proximity_vector : ProximityVector) -> float:
 return proximity_vector.dcpa
 def get_metric_str(self) -> str:
 return 'DCPA (m)'
 def get_title(self) -> str:
 return 'Distance at closest point of approach'
 def get_y_lim(self) -> Tuple[float, float]:
 dcpa = max(self.risk_vectors[0].proximity_vectors.values(), key=lambda pv: pv.dcpa).dcpa
 #threshold = max(self.metrics, key=lambda metric: metric.relation.safety_dist).relation.safety_dist
 return -0.1, max(dcpa * 2, self.get_threshold2_y()*1.1)
 def get_threshold_y(self, proximity_vector : ProximityVector) -> float:
 return proximity_vector.props.safety_dist
 def get_threshold2_y(self) -> float:
 return self.dist_treshold
 def get_threshold2_label(self) -> str:
 return f'{(self.dist_treshold / N_MILE_TO_M_CONVERSION):.0f} NM'
class TCPAAxesComponent(ProximityMetricComponent):
 def __init__(self, ax : plt.Axes, scenario: MultiLevelScenario, risk_vectors : List[RiskVector], ref_risk_vectors : Optional[List[RiskVector]] = None) -> None:
 super().__init__(ax, scenario, risk_vectors, ref_risk_vectors)
 def get_y_metric(self, proximity_vector : ProximityVector) -> float:
 return proximity_vector.tcpa
 def get_metric_str(self) -> str:
 return 'TCPA (s)'
 def get_title(self) -> str:
 return 'Time to closest point of approach'
 def get_y_lim(self) -> Tuple[float, float]:
 tcpa0 = max(self.risk_vectors[0].proximity_vectors.values(), key=lambda pv: pv.tcpa).tcpa
 return -100, max(tcpa0, self.get_threshold2_y()) * 1.1
 def get_threshold_y(self, proximity_vector : ProximityVector) -> float:
 return 0.0
 def get_threshold2_y(self) -> float:
 return self.time_treshold
 def get_threshold2_label(self) -> str:
 return f'{(self.time_treshold / 60):.0f} min'
</src\visualization\colreg_scenarios\plot_components\metric_components\proximity_metrics_component.py>

<src\visualization\colreg_scenarios\plot_components\metric_components\risk_metric_component.py>
from typing import Dict, List, Optional
from matplotlib import pyplot as plt
from concrete_level.models.concrete_scene import ConcreteScene
from concrete_level.models.concrete_vessel import ConcreteVessel
from concrete_level.models.multi_level_scenario import MultiLevelScenario
from evaluation.risk_evaluation import RiskVector
from visualization.colreg_scenarios.plot_components.plot_component import PlotComponent, colors, light_colors
class RiskMetricComponent(PlotComponent):
 def __init__(self, ax : plt.Axes, scenario: MultiLevelScenario, risk_vectors : List[RiskVector], y_label : str, x_label : bool, ref_risk_vectors : Optional[List[RiskVector]] = None) -> None:
 super().__init__(ax, scenario)
 self.risk_vectors = risk_vectors
 self.ref_risk_vectors = ref_risk_vectors
 self.line_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.reference_line_graphs : Dict[ConcreteVessel, plt.Line2D] = {}
 self.ax = ax
 self.length = len(self.risk_vectors)
 #self.ax.set_title('Collision risk evolution')
 if x_label:
 self.ax.set_xlabel('Time (s)')
 self.ax.set_ylabel(y_label)
 self.ax.set_aspect('auto', adjustable='box')
 def do_draw(self):
 x = range(0, self.length)
 for vessel in self.scenario.concrete_scene.actors:
 if self.length == 0:
 break
 if self.ref_risk_vectors is not None:
 y = [rv.danger_sectors[vessel] for rv in self.ref_risk_vectors if vessel in rv.danger_sectors]
 line, = self.ax.plot(x, y, color=light_colors[vessel.id], linestyle=':', label=f'{self.scenario.get_vessel_name(vessel)} no intervention', linewidth=2)
 self.reference_line_graphs[vessel] = line
 self.graphs += [line]
 y = [rv.danger_sectors[vessel] for rv in self.risk_vectors if vessel in rv.danger_sectors]
 line, = self.ax.plot(x, y, color=colors[vessel.id], linewidth=1.7, label=f'{self.scenario.get_vessel_name(vessel)} COLREGS compliant', linestyle='-')
 self.line_graphs[vessel] = line
 self.graphs += [line]
 self.ax.margins(x=0.2, y=0.2)
 self.ax.set_xlim(0, self.length)
 self.ax.set_ylim(-0.05, 1.05)
 self.ax.legend()
 def do_update(self, scene : ConcreteScene) -> List[plt.Artist]:
 return self.graphs
</src\visualization\colreg_scenarios\plot_components\metric_components\risk_metric_component.py>

<src\visualization\evaluation_plots\diversity_plot.py>
from typing import List
import matplotlib.pyplot as plt
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from visualization.plotting_utils import EvalPlot
class DiversityPlot(EvalPlot):
 def __init__(self, eval_datas : List[EvaluationData], get_equivalence_class_distribution=ConcreteSceneAbstractor.get_equivalence_class_distribution):
 self.get_equivalence_class_distribution = get_equivalence_class_distribution
 super().__init__(eval_datas)
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self) -> plt.Figure:
 fig, axes = plt.subplots(self.comparison_group_count, self.vessel_num_count, figsize=(3 * 4, 3.8), constrained_layout=True)
 axes = np.atleast_2d(axes)
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, config_group in enumerate(self.comparison_groups):
 axi : plt.Axes = axes[j][i]
 if j == 0:
 axi.set_title(self.vessel_num_labels[i])
 self.init_axi(i, axi, r"$\bf{" + self.group_labels[j] + r"}$")
 equivalence_classes = self.get_equivalence_class_distribution([eval_data.best_scene for eval_data in self.measurements[vessel_number][config_group]], vessel_number)
 equivalence_classes = dict(sorted(equivalence_classes.items(), key=lambda item: item[1][1], reverse=True))
 values = [int(count) for _, count in equivalence_classes.values()]
 axi.text(0.98, 0.98, self.get_shape_coverage_text(values),
 transform=axi.transAxes, # Use axis coordinates
 verticalalignment='top', # Align text vertically to the top
 horizontalalignment='right',
 fontsize=11,
 fontweight='bold')
 if sum(values) == 0:
 continue
 labels = range(1, len(equivalence_classes.keys()) + 1)
 bars : plt.BarContainer = axi.bar(labels, values, color=self.colors[j], edgecolor='black', linewidth=0)
 xticks = list(np.linspace(labels[0], labels[-1], 6))
 xticks = [int(t) for t in xticks]
 axi.set_xticks([xticks[0], xticks[-1]] + list(xticks), minor=False)
 self.set_yticks(axi, values)
 return fig
 def get_shape_coverage_text(self, values : List[int]) -> str:
 sample_num = sum(values)
 if sample_num == 0:
 return f'total samples: {0}\ncovered shapes: {0}/{len(values)}\n{0}%'
 found_length = sum(1 for value in values if value > 0)
 coverage_percent = found_length/len(values)*100 if len(values) != 0 else 0
 return f'total samples: {sample_num}\ncovered shapes: {found_length}/{len(values)}\n{coverage_percent:.1f}%'
class AmbiguousDiversityPlot(DiversityPlot):
 def __init__(self, eval_datas):
 super().__init__(eval_datas, ConcreteSceneAbstractor.get_ambiguous_equivalence_class_distribution)
class UnspecifiedDiversityPlot(DiversityPlot):
 def __init__(self, eval_datas):
 super().__init__(eval_datas, ConcreteSceneAbstractor.get_unspecified_equivalence_class_distribution)
 def get_shape_coverage_text(self, values : List[int]) -> str:
 sample_num = sum(values)
 found_length = sum(1 for value in values if value > 0)
 return f'total samples: {sample_num}\ncovered shapes: {found_length}/?'
</src\visualization\evaluation_plots\diversity_plot.py>

<src\visualization\evaluation_plots\diversity_statistics_table.py>
import itertools
from typing import List
import matplotlib.pyplot as plt
from evaluation.chi_square_kl_div import ChiSquareKLDiv
from evaluation.permutation_evenness_test import PermutationEvennessTest
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from visualization.plotting_utils import DummyEvalPlot
from itertools import combinations
class DiversityStatisticsTable(DummyEvalPlot):
 def __init__(self, eval_datas : List[EvaluationData], get_equivalence_class_distribution=ConcreteSceneAbstractor.get_equivalence_class_distribution):
 self.get_equivalence_class_distribution = get_equivalence_class_distribution
 super().__init__(eval_datas)
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self) -> plt.Figure:
 groups_to_compare = list(combinations(self.comparison_groups, 2))
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, (group1, group2) in enumerate(groups_to_compare):
 equivalence_classes1 = self.get_equivalence_class_distribution([eval_data.best_scene for eval_data in self.measurements[vessel_number][group1]], vessel_number)
 equivalence_classes2 = self.get_equivalence_class_distribution([eval_data.best_scene for eval_data in self.measurements[vessel_number][group2]], vessel_number)
 if len(equivalence_classes1) == 0 or len(equivalence_classes2) == 0:
 continue
 values1 = [int(count) for _, count in equivalence_classes1.values()]
 values2 = [int(count) for _, count in equivalence_classes2.values()]
 if sum(values1) == 0 or sum(values2) == 0:
 continue
 #evenness_test = PermutationEvennessTest(values1, values2)
 #print(f'{vessel_number} vessels, {group1} - {group2}: {group1} evenness={evenness_test.evenness_1}, {group2} evenness={evenness_test.evenness_2}, p-value:{evenness_test.p_value}, effect-size:{evenness_test.observed_diff}')
 test = ChiSquareKLDiv(values1, values2)
 print(f'{vessel_number} vessels, {group1} - {group2}: {group1} p-value:{test.p_value}, KL Divergence::{test.kl_div}')
 return DummyEvalPlot.create_fig(self)
class AmbiguousDiversityStatisticsTable(DiversityStatisticsTable):
 def __init__(self, eval_datas):
 super().__init__(eval_datas, ConcreteSceneAbstractor.get_ambiguous_equivalence_class_distribution)
class UnspecifiedDiversityStatisticsTable(DiversityStatisticsTable):
 def __init__(self, eval_datas):
 super().__init__(eval_datas, ConcreteSceneAbstractor.get_unspecified_equivalence_class_distribution)
</src\visualization\evaluation_plots\diversity_statistics_table.py>

<src\visualization\evaluation_plots\eval_plot_manager.py>
from datetime import datetime
import os
import tkinter as tk
from typing import Dict, List
from matplotlib import pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from utils.file_system_utils import ASSET_FOLDER
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from visualization.evaluation_plots.diversity_statistics_table import AmbiguousDiversityStatisticsTable, DiversityStatisticsTable
from visualization.evaluation_plots.runtime_statistics_table import RuntimeStatisticsTable
from visualization.evaluation_plots.scenario_type_statistics_plot import ScenarioTypeStatisticsPlot
from visualization.evaluation_plots.scenario_type_statistics_table import ScenarioTypeStatisticsTable
from visualization.plotting_utils import DummyEvalPlot, EvalPlot
from visualization.evaluation_plots.diversity_plot import AmbiguousDiversityPlot, DiversityPlot, UnspecifiedDiversityPlot
from visualization.evaluation_plots.risk_vector_plot import RiskVectorPlot
from visualization.evaluation_plots.runtime_plot import RuntimePlot
from visualization.evaluation_plots.success_rate_plot import SuccessRatePlot
class PlotWrapper():
 def __init__(self, plot_class, args):
 self.plot_class = plot_class
 self.args = args
 self.plot = None
 def get(self) -> EvalPlot:
 if self.plot is None:
 self.plot = self.plot_class(**self.args)
 return self.plot
class EvalPlotManager():
 def __init__(self, eval_datas : List[EvaluationData]):
 self.eval_datas = eval_datas
 self.plots : Dict[str, PlotWrapper] = {
 "Home" : PlotWrapper(DummyEvalPlot, {'eval_datas': self.eval_datas}),
 "Scenario Type Statistics" : PlotWrapper(ScenarioTypeStatisticsPlot, {'eval_datas': self.eval_datas}),
 "Diversity" : PlotWrapper(DiversityPlot, {'eval_datas': self.eval_datas}),
 "Ambiguous Diversity" : PlotWrapper(AmbiguousDiversityPlot, {'eval_datas': self.eval_datas}),
 "Unspecified Diversity" : PlotWrapper(UnspecifiedDiversityPlot, {'eval_datas': self.eval_datas}),
 "Success Rate" : PlotWrapper(SuccessRatePlot, {'eval_datas': self.eval_datas, 'is_algo': False}),
 "Runtime (successful)" : PlotWrapper(RuntimePlot, {'eval_datas': self.eval_datas, 'is_all': False, 'is_algo': False}),
 "Runtime (all)" : PlotWrapper(RuntimePlot, {'eval_datas': self.eval_datas, 'is_all': True, 'is_algo': False}),
 "Risk Vector Proximity index" : PlotWrapper(RiskVectorPlot, {'eval_datas': self.eval_datas, 'metric' : 'proximity'}),
 "Risk Vector DS index" : PlotWrapper(RiskVectorPlot, {'eval_datas': self.eval_datas, 'metric' : 'ds'}),
 "Risk Vector DCPA" : PlotWrapper(RiskVectorPlot, {'eval_datas': self.eval_datas, 'metric' : 'dcpa'}),
 "Risk Vector TCPA" : PlotWrapper(RiskVectorPlot, {'eval_datas': self.eval_datas, 'metric' : 'tcpa'}),
 "Diversity Statistics Test" : PlotWrapper(DiversityStatisticsTable, {'eval_datas': self.eval_datas}),
 "Ambiguous Diversity Statistics Test" : PlotWrapper(AmbiguousDiversityStatisticsTable, {'eval_datas': self.eval_datas}),
 "Runtime Statistical Test" : PlotWrapper(RuntimeStatisticsTable, {'eval_datas': self.eval_datas}),
 'Scenario Type Statistical Test' : PlotWrapper(ScenarioTypeStatisticsTable, {'eval_datas': self.eval_datas}),
 }
 self.root = tk.Tk()
 self.root.resizable(True, True)
 self.image_folder = f'{ASSET_FOLDER}/images/exported_plots'
 self.root.option_add("*Font", ("Times New Roman", 14))
 self.root.title(f"Evaluation - {list(self.plots.keys())[0]}")
 # CANVAS FRAME
 self.canvas_frame = tk.Frame(master=self.root)
 self.canvas_frame.pack(fill=tk.BOTH, expand=True)
 ## PLOT FRAME
 self.plot_frame = tk.Frame(master=self.canvas_frame)
 self.plot_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 self.canvas = FigureCanvasTkAgg(list(self.plots.values())[0].get().fig, master=self.plot_frame)
 self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
 # TOOLBAR FRAME
 self.toolbar_frame = tk.Frame(master=self.root, height=50)
 self.toolbar_frame.pack(side=tk.BOTTOM, fill=tk.X)
 self.toolbar_frame.pack_propagate(False)
 ## TOOLBAR
 self.navigation_frame = tk.Frame(self.toolbar_frame)
 self.navigation_frame.pack(fill=tk.BOTH, side=tk.LEFT)
 self.navigation_toolbar = NavigationToolbar2Tk(self.canvas, self.navigation_frame)
 self.navigation_toolbar.update()
 self.navigation_toolbar.pack(fill=tk.BOTH, side=tk.LEFT)
 ## PLOT SELECTION
 self.plot_options = list(self.plots.keys())
 self.selected_plot = tk.StringVar()
 self.selected_plot.set(self.plot_options[0]) # Set the default value
 # Create the dropdown menu
 self.plot_dropdown = tk.OptionMenu(self.toolbar_frame, self.selected_plot, *self.plot_options, command=self.on_select_plot)
 self.plot_dropdown.pack(side=tk.LEFT, padx=5)
 self.to_pdf_button = tk.Button(self.toolbar_frame, text="PDF", command=self.to_pdf)
 self.to_pdf_button.pack(side=tk.LEFT, padx=5)
 self.root.bind('<e>', lambda event: self.to_pdf())
 ## EXIT BUTTONS
 exit_button = tk.Button(self.toolbar_frame, text="Exit", command=self.exit_application)
 exit_button.pack(side=tk.RIGHT, padx=5)
 continue_button = tk.Button(self.toolbar_frame, text="Continue", command=self.continue_application)
 continue_button.pack(side=tk.RIGHT, padx=5)
 self.root.wait_window()
 def sort_dict(self, dicts : List[Dict[str, plt.Artist]]) -> List[List[plt.Artist]]:
 artists = []
 for dict in dicts:
 artists.append([value for key, value in sorted(dict.items())])
 return artists
 def exit_application(self):
 self.root.destroy()
 os._exit(0)
 def continue_application(self):
 self.root.destroy()
 def to_pdf(self):
 file_name = f'{self.selected_plot.get()}_{datetime.now().isoformat().replace(":","-")}'
 if not os.path.exists(self.image_folder):
 os.makedirs(self.image_folder)
 self.canvas.figure.savefig(f'{self.image_folder}/{file_name}.svg', format='svg', bbox_inches='tight', dpi=350)
 self.canvas.figure.savefig(f'{self.image_folder}/{file_name}.pdf', format='pdf', bbox_inches='tight', dpi=350)
 print('image saved')
 def on_select_plot(self, value):
 plot = self.plots[value].get()
 self.navigation_toolbar.destroy()
 self.canvas.get_tk_widget().destroy()
 self.canvas = FigureCanvasTkAgg(plot.fig, master=self.plot_frame)
 self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
 self.navigation_toolbar = NavigationToolbar2Tk(self.canvas, self.navigation_frame)
 self.navigation_toolbar.update()
 self.navigation_toolbar.pack(fill=tk.BOTH, side=tk.LEFT)
 self.root.title(f"Evaluation - {value}")
</src\visualization\evaluation_plots\eval_plot_manager.py>

<src\visualization\evaluation_plots\risk_vector_plot.py>
from itertools import chain
from typing import List
import matplotlib.pyplot as plt
import numpy as np
from concrete_level.models.concrete_scene import ConcreteScene
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from utils.asv_utils import N_MILE_TO_M_CONVERSION
from visualization.plotting_utils import EvalPlot
class RiskVectorPlot(EvalPlot):
 @staticmethod
 def metric_map_type(scene: ConcreteScene, metric_type: str):
 metric_mapping = {
 'dcpa': scene.dcpa,
 'tcpa': scene.tcpa,
 'ds': scene.danger_sector,
 'proximity': scene.proximity_index,
 }
 if metric_type not in metric_mapping:
 raise ValueError('Unrecognized type.')
 if metric_mapping[metric_type] is None:
 raise ValueError('None vector found among optimal solutions')
 return metric_mapping[metric_type]
 metric_map_title = {
 'dcpa' : r'DCPA of OS to closest TS (s)',
 'tcpa' : r'TCPA of OS to closest TS (s)',
 'ds' : r'DS index of OS at $t_0$',
 'proximity' : r'Max proximity index of OS at $t_0$',
 }
 metric_map_max = {
 'dcpa' : 1 * N_MILE_TO_M_CONVERSION,
 'tcpa' : 1500,
 'ds' : 1.0,
 'proximity' : 1.0,
 }
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def __init__(self, eval_datas : List[EvaluationData], metric = 'dcpa'):
 self.metric = metric
 EvalPlot.__init__(self, eval_datas, is_all=False)
 def create_fig(self) -> plt.Figure:
 fig, axes = plt.subplots(1, self.vessel_num_count, figsize=(self.vessel_num_count, 4), gridspec_kw={'width_ratios': [1]*self.vessel_num_count}, constrained_layout=True)
 axes = np.atleast_1d(axes)
 for i, vessel_number in enumerate(self.vessel_numbers):
 axi : plt.Axes = axes[i]
 axi.set_title(self.vessel_num_labels[i])
 self.init_axi(i, axi, self.metric_map_title[self.metric])
 data = []
 new_group_labels = []
 for measurement, label in zip(self.measurements[vessel_number].values(), self.group_labels):
 values = [self.metric_map_type(eval_data.best_scene, self.metric) for eval_data in measurement]
 if len(values) != 0:
 data.append(values)
 new_group_labels.append(label)
 if len(data) == 0:
 continue
 violin_plot = axi.violinplot(data, widths=0.7, showmeans=True, showmedians=True)
 #axi.set_yticks(range(max([max(d) for d in data])))
 axi.set_xticks(range(1, len(new_group_labels)+1), new_group_labels)
 axi.set_xticklabels(new_group_labels, rotation=0, ha='right', fontweight='bold')
 self.set_yticks(axi, range(int(np.ceil(self.metric_map_max[self.metric]) + 1)))
 for patch, color in zip(violin_plot['bodies'], self.colors):
 patch.set_facecolor(color) # Set fill color
 patch.set_linewidth(1.5)
 violin_plot['cmeans'].set_color('black')
 violin_plot['cmeans'].set_linewidth(2)
 violin_plot['cmedians'].set_color('grey')
 violin_plot['cmedians'].set_linewidth(2)
 violin_plot['cmedians'].set_linestyle(':')
 axi.set_ylim(0, self.metric_map_max[self.metric] * 1.15)
 # Annotate each box with the number of samples
 for j, group in enumerate(data, 1): # '1' because boxplot groups start at 1
 sample_size = len(group)
 axi.text(j, self.metric_map_max[self.metric]*1.05, f'{sample_size}', ha='left', va='center', fontsize=10, horizontalalignment='left')
 return fig
</src\visualization\evaluation_plots\risk_vector_plot.py>

<src\visualization\evaluation_plots\runtime_plot.py>
from typing import List, Tuple
import matplotlib.pyplot as plt
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from visualization.plotting_utils import EvalPlot
class RuntimePlot(EvalPlot):
 def __init__(self, eval_datas : List[EvaluationData], is_all=False, is_algo=False):
 EvalPlot.__init__(self, eval_datas, is_algo=is_algo, is_all=is_all)
 @property
 def algos(self) -> List[Tuple[str, str]]:
 return [('nsga2', 'all'), ('nsga2', 'vessel'), ('nsga2', 'category'), ('nsga3', 'all'), ('nsga3', 'vessel'), ('nsga3', 'category'), ('ga', 'all'), ('de', 'all'), ('pso', 'all_swarm')]
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self):
 fig, axes = plt.subplots(1, self.vessel_num_count, figsize=(self.vessel_num_count, 4), gridspec_kw={'width_ratios': [1]*self.vessel_num_count}, constrained_layout=True)
 axes = np.atleast_1d(axes)
 for i, vessel_number in enumerate(self.vessel_numbers):
 axi : plt.Axes = axes[i]
 axi.set_title(self.vessel_num_labels[i])
 self.init_axi(i, axi, 'Runtime (s)')
 data = []
 new_group_labels = []
 for measurement, label in zip(self.measurements[vessel_number].values(), self.group_labels):
 values = [eval_data.evaluation_time for eval_data in measurement]
 if len(values) != 0:
 data.append(values)
 new_group_labels.append(label)
 print(f'{vessel_number} vessels, {label}: median: {np.median(values)} , mean: {np.mean(values)}')
 if len(data) == 0:
 continue
 violin_plot = axi.violinplot(data, widths=0.7, showmeans=True, showmedians=True)
 axi.set_xticks(range(1, len(new_group_labels)+1), new_group_labels)
 axi.set_xticklabels(new_group_labels, rotation=0, ha='right', fontweight='bold')
 self.set_yticks(axi, range(round(max([max(d) for d in data]))))
 for patch, color in zip(violin_plot['bodies'], self.colors):
 patch.set_facecolor(color) # Set fill color
 patch.set_linewidth(1.0)
 violin_plot['cmeans'].set_color('black')
 violin_plot['cmeans'].set_linewidth(2)
 violin_plot['cmedians'].set_color('grey')
 violin_plot['cmedians'].set_linewidth(2)
 violin_plot['cmedians'].set_linestyle(':')
 maxy = axi.get_ylim()[1]
 axi.set_ylim(0, maxy*1.1)
 # Annotate each box with the number of samples
 for j, group in enumerate(data, 1): # '1' because boxplot groups start at 1
 axi.text(j, maxy*1.02, f'{len(group)}', ha='center', va='center', fontsize=10, horizontalalignment='center')
 return fig
</src\visualization\evaluation_plots\runtime_plot.py>

<src\visualization\evaluation_plots\runtime_statistics_table.py>
from itertools import combinations
from typing import List
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from evaluation.mann_whitney_u_cliff_delta import MannWhitneyUCliffDelta
from visualization.plotting_utils import DummyEvalPlot
class RuntimeStatisticsTable(DummyEvalPlot):
 def __init__(self, eval_datas : List[EvaluationData]):
 super().__init__(eval_datas)
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self):
 groups_to_compare = list(combinations(self.comparison_groups, 2))
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, (group1, group2) in enumerate(groups_to_compare):
 values1 = [eval_data.evaluation_time for eval_data in self.measurements[vessel_number][group1]]
 values2 = [eval_data.evaluation_time for eval_data in self.measurements[vessel_number][group2]]
 if len(values1) == 0 or len(values2) == 0:
 continue
 statistical_test = MannWhitneyUCliffDelta(values1, values2)
 print(f'{vessel_number} vessels, {group1} - {group2}: p-value:{statistical_test.p_value_mann_w}, effect-size:{statistical_test.effect_size_cohens_d}')
 return DummyEvalPlot.create_fig(self)
</src\visualization\evaluation_plots\runtime_statistics_table.py>

<src\visualization\evaluation_plots\scenario_type_statistics_plot.py>
from typing import List
import matplotlib.pyplot as plt
import numpy as np
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from evaluation.vessel_type_sampler import VesselTypeSampler
from functional_level.models.functional_model_manager import FunctionalModelManager
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from visualization.plotting_utils import EvalPlot
class ScenarioTypeStatisticsPlot(EvalPlot):
 def __init__(self, eval_datas : List[EvaluationData]):
 self.sample_size = 4000
 self.distribution = {'OtherType' : 51.1, 'CargoShip' : 31.1,
 'Tanker' : 6.2, 'ContainerShip' : 7.4,
 'PassengerShip' : 0.7, 'FishingShip' : 3.5}
 self.labels = ['Overtake', 'Head-on', 'Crossing']
 super().__init__(eval_datas)
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark', 'zhu_et_al', 'base_reference']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self) -> plt.Figure:
 fig, axes = plt.subplots(self.vessel_num_count, self.comparison_group_count, figsize=(1 * 14, 2*self.vessel_num_count), constrained_layout=True)
 axes = np.atleast_2d(axes)
 def configure_axi(i : int, j : int, group_label, color, values):
 axi : plt.Axes = axes[i][j]
 self.init_axi(j, axi, f'{self.vessel_numbers[i]}-vessel samples')
 if sum(values) == 0:
 return
 bars : plt.BarContainer = axi.bar(self.labels, values, color=color, edgecolor='black', linewidth=0)
 axi.set_title(group_label, fontdict={'fontsize': 12, 'fontweight': 'bold'})
 self.set_yticks(axi, values)
 axi.set_xticks([0,1,2], self.labels)
 axi.set_xticklabels(self.labels, rotation=0, ha='center')
 axi.set_ylim(0, max(values) * 1.15)
 for i, bar in enumerate(bars):
 axi.text(bar.get_x() + bar.get_width() / 2, values[i] * 1.02,
 f'{(values[i] / sum(values) * 100):.1f}%', ha='center', va='bottom', fontsize=10)
 axi.text(0.5, 0.92, f'total: {int(sum(values))}',
 transform=axi.transAxes, # Use axis coordinates
 verticalalignment='top', # Align text vertically to the top
 horizontalalignment='center',
 fontsize=11,
 fontweight='bold')
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, comparison_group in enumerate(self.comparison_groups):
 scenarios = [ConcreteSceneAbstractor.get_abstractions_from_eval(eval_data).functional_scenario for eval_data in self.measurements[vessel_number][comparison_group]]
 values = VesselTypeSampler.sample(scenarios, self.sample_size, {})
 configure_axi(i, j, self.group_labels[j], self.colors[j], values)
 if self.vessel_numbers[i] == 2:
 configure_axi(i, 3, self.group_labels[3], self.colors[3], [56952*0.131, 56952*0.002, 56952*0.867])
 configure_axi(i, 4, self.group_labels[4], self.colors[4],
 VesselTypeSampler.sample(FunctionalModelManager.get_x_vessel_scenarios(vessel_number), self.sample_size, {}))
 return fig
</src\visualization\evaluation_plots\scenario_type_statistics_plot.py>

<src\visualization\evaluation_plots\scenario_type_statistics_table.py>
from collections import defaultdict
from typing import Dict, List, Tuple
import matplotlib.pyplot as plt
from evaluation.chi_square_kl_div import ChiSquareKLDiv
from evaluation.vessel_type_sampler import VesselTypeSampler
from functional_level.models.functional_model_manager import FunctionalModelManager
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from concrete_level.concrete_scene_abstractor import ConcreteSceneAbstractor
from visualization.plotting_utils import DummyEvalPlot
from itertools import combinations
class ScenarioTypeStatisticsTable(DummyEvalPlot):
 def __init__(self, eval_datas : List[EvaluationData], get_equivalence_class_distribution=ConcreteSceneAbstractor.get_equivalence_class_distribution):
 self.get_equivalence_class_distribution = get_equivalence_class_distribution
 super().__init__(eval_datas)
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution', 'common_ocean_benchmark', 'zhu_et_al', 'base_reference']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2]
 def create_fig(self) -> plt.Figure:
 samples : Dict[int, Dict[str, List[int]]] = defaultdict(lambda: defaultdict())
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, comparison_group in enumerate(self.comparison_groups):
 scenarios = [ConcreteSceneAbstractor.get_abstractions_from_eval(eval_data).functional_scenario for eval_data in self.measurements[vessel_number][comparison_group]]
 values = [round(value) for value in VesselTypeSampler.sample(scenarios, 0, {})]
 samples[vessel_number][comparison_group] = values
 values = [round(value) for value in [56952*0.131, 56952*0.002, 56952*0.867]]
 samples[vessel_number]['zhu_et_al'] = values
 values = [round(value) for value in VesselTypeSampler.sample(FunctionalModelManager.get_x_vessel_scenarios(vessel_number), 0, {})]
 samples[vessel_number]['base_reference'] = values
 groups_to_compare = list(combinations(self.comparison_groups, 2))
 for i, vessel_number in enumerate(self.vessel_numbers):
 for j, (group1, group2) in enumerate(groups_to_compare):
 samples1 = samples[vessel_number][group1]
 samples2 = samples[vessel_number][group2]
 test = ChiSquareKLDiv(samples1, samples2)
 print(f'{vessel_number} vessels, {group1} - {group2}: {group1} p-value:{test.p_value}, KL Divergence::{test.kl_div}')
 return DummyEvalPlot.create_fig(self)
</src\visualization\evaluation_plots\scenario_type_statistics_table.py>

<src\visualization\evaluation_plots\success_rate_plot.py>
from typing import List, Tuple
import matplotlib.pyplot as plt
import numpy as np
from logical_level.constraint_satisfaction.evolutionary_computation.evaluation_data import EvaluationData
from visualization.plotting_utils import EvalPlot
class SuccessRatePlot(EvalPlot):
 def __init__(self, eval_datas : List[EvaluationData], is_algo=False):
 EvalPlot.__init__(self, eval_datas, is_algo=is_algo, is_all=True)
 @property
 def algos(self) -> List[Tuple[str, str]]:
 return [('nsga2', 'all'), ('nsga2', 'vessel'), ('nsga2', 'category'), ('nsga3', 'all'), ('nsga3', 'vessel'), ('nsga3', 'category'), ('ga', 'all'), ('de', 'all'), ('pso', 'all_swarm')]
 @property
 def config_groups(self) -> List[str]:
 return ['SBO', 'scenic_distribution']
 @property
 def vessel_numbers(self) -> List[int]:
 return [2, 3, 4, 5, 6]
 def create_fig(self) -> plt.Figure:
 fig, axes = plt.subplots(1, self.vessel_num_count, figsize=(self.comparison_group_count, 4), gridspec_kw={'width_ratios': [1]*self.vessel_num_count}, constrained_layout=True)
 axes = np.atleast_1d(axes)
 for i, vessel_number in enumerate(self.vessel_numbers):
 axi : plt.Axes = axes[i]
 axi.set_title(self.vessel_num_labels[i])
 axi.set_aspect('auto', adjustable='box')
 self.init_axi(i, axi, 'Success rate (%)')
 data = []
 percentages = []
 new_group_labels = []
 for measurement, label in zip(self.measurements[vessel_number].values(), self.group_labels):
 values = [0 if eval_data.best_fitness_index > 0.0 else 1 for eval_data in measurement]
 if len(values) != 0:
 data.append(values)
 percentages.append(np.mean(values) * 100)
 print(f'{vessel_number} vessels, {label}: success rate: {percentages[-1]}')
 new_group_labels.append(label)
 if len(data) == 0:
 continue
 bars : plt.BarContainer = axi.bar(new_group_labels, percentages, color=self.colors, edgecolor='black', linewidth=2)
 axi.set_xticks(range(len(new_group_labels)), new_group_labels)
 axi.set_xticklabels(new_group_labels, rotation=0, ha='right', fontweight='bold')
 self.set_yticks(axi, range(101))
 axi.set_ylim(0, 110)
 for j, bar in enumerate(bars):
 axi.text(bar.get_x() + bar.get_width() / 2, 102,
 f'{len(data[j])}', ha='center', va='bottom', fontsize=10)
 return fig
</src\visualization\evaluation_plots\success_rate_plot.py>